import { z } from "zod";

export const Schema = z.object({
  "$schema": z.string().url().describe(
    "The URI of the JSON schema corresponding to the version.",
  ).optional(),
  "version": z.literal("2.1.0").describe(
    "The SARIF format version of this log file.",
  ),
  "runs": z.array(
    z.object({
      "tool": z.object({
        "driver": z.object({
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A unique identifier for the tool component in the form of a GUID.",
          ).optional(),
          "name": z.string().describe("The name of the tool component."),
          "organization": z.string().describe(
            "The organization or company that produced the tool component.",
          ).optional(),
          "product": z.string().describe(
            "A product suite to which the tool component belongs.",
          ).optional(),
          "productSuite": z.string().describe(
            "A localizable string containing the name of the suite of products to which the tool component belongs.",
          ).optional(),
          "shortDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullName": z.string().describe(
            "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
          ).optional(),
          "version": z.string().describe(
            "The tool component version, in whatever format the component natively provides.",
          ).optional(),
          "semanticVersion": z.string().describe(
            "The tool component version in the format specified by Semantic Versioning 2.0.",
          ).optional(),
          "dottedQuadFileVersion": z.string().regex(
            new RegExp("[0-9]+(\\.[0-9]+){3}"),
          ).describe(
            "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
          ).optional(),
          "releaseDateUtc": z.string().describe(
            "A string specifying the UTC date (and optionally, the time) of the component's release.",
          ).optional(),
          "downloadUri": z.string().url().describe(
            "The absolute URI from which the tool component can be downloaded.",
          ).optional(),
          "informationUri": z.string().url().describe(
            "The absolute URI at which information about this version of the tool component can be found.",
          ).optional(),
          "globalMessageStrings": z.record(
            z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ),
          ).describe(
            "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
          ).optional(),
          "notifications": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
          ).default([]),
          "rules": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
          ).default([]),
          "taxa": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
          ).default([]),
          "locations": z.array(
            z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact."),
          ).min(0).describe(
            "An array of the artifactLocation objects associated with the tool component.",
          ).default([]),
          "language": z.string().regex(
            new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
          ).describe(
            "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
          ).default("en-US"),
          "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
            .describe("The kinds of data contained in this object.").default([
              "localizedData",
              "nonLocalizedData",
            ]),
          "isComprehensive": z.boolean().describe(
            "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
          ).default(false),
          "localizedDataSemanticVersion": z.string().describe(
            "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
          ).optional(),
          "minimumRequiredLocalizedDataSemanticVersion": z.string().describe(
            "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
          ).optional(),
          "associatedComponent": z.object({
            "name": z.string().describe(
              "The 'name' property of the referenced toolComponent.",
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "An index into the referenced toolComponent in tool.extensions.",
            ).default(-1),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe("The 'guid' property of the referenced toolComponent.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Identifies a particular toolComponent object, either the driver or an extension.",
          ).optional(),
          "translationMetadata": z.object({
            "name": z.string().describe(
              "The name associated with the translation metadata.",
            ),
            "fullName": z.string().describe(
              "The full name associated with the translation metadata.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "downloadUri": z.string().url().describe(
              "The absolute URI from which the translation metadata can be downloaded.",
            ).optional(),
            "informationUri": z.string().url().describe(
              "The absolute URI from which information related to the translation metadata can be downloaded.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Provides additional metadata related to translation.",
          ).optional(),
          "supportedTaxonomies": z.array(
            z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ),
          ).min(0).describe(
            "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A component, such as a plug-in or the driver, of the analysis tool that was run.",
        ),
        "extensions": z.array(
          z.object({
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A unique identifier for the tool component in the form of a GUID.",
            ).optional(),
            "name": z.string().describe("The name of the tool component."),
            "organization": z.string().describe(
              "The organization or company that produced the tool component.",
            ).optional(),
            "product": z.string().describe(
              "A product suite to which the tool component belongs.",
            ).optional(),
            "productSuite": z.string().describe(
              "A localizable string containing the name of the suite of products to which the tool component belongs.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullName": z.string().describe(
              "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
            ).optional(),
            "version": z.string().describe(
              "The tool component version, in whatever format the component natively provides.",
            ).optional(),
            "semanticVersion": z.string().describe(
              "The tool component version in the format specified by Semantic Versioning 2.0.",
            ).optional(),
            "dottedQuadFileVersion": z.string().regex(
              new RegExp("[0-9]+(\\.[0-9]+){3}"),
            ).describe(
              "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
            ).optional(),
            "releaseDateUtc": z.string().describe(
              "A string specifying the UTC date (and optionally, the time) of the component's release.",
            ).optional(),
            "downloadUri": z.string().url().describe(
              "The absolute URI from which the tool component can be downloaded.",
            ).optional(),
            "informationUri": z.string().url().describe(
              "The absolute URI at which information about this version of the tool component can be found.",
            ).optional(),
            "globalMessageStrings": z.record(
              z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ),
            ).describe(
              "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
            ).optional(),
            "notifications": z.array(
              z.object({
                "id": z.string().describe(
                  "A stable, opaque identifier for the report.",
                ),
                "deprecatedIds": z.array(z.string()).min(0).describe(
                  "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "A unique identifier for the reporting descriptor in the form of a GUID.",
                ).optional(),
                "deprecatedGuids": z.array(
                  z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ),
                ).min(0).describe(
                  "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "name": z.string().describe(
                  "A report identifier that is understandable to an end user.",
                ).optional(),
                "deprecatedNames": z.array(z.string()).min(0).describe(
                  "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "shortDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "fullDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "messageStrings": z.record(
                  z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ),
                ).describe(
                  "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                ).optional(),
                "defaultConfiguration": z.object({
                  "enabled": z.boolean().describe(
                    "Specifies whether the report may be produced during the scan.",
                  ).default(true),
                  "level": z.enum(["none", "note", "warning", "error"])
                    .describe("Specifies the failure level for the report.")
                    .default("warning"),
                  "rank": z.number().gte(-1).lte(100).describe(
                    "Specifies the relative priority of the report. Used for analysis output only.",
                  ).default(-1),
                  "parameters": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about a rule or notification that can be configured at runtime.",
                ).optional(),
                "helpUri": z.string().url().describe(
                  "A URI where the primary documentation for the report can be found.",
                ).optional(),
                "help": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "relationships": z.array(
                  z.object({
                    "target": z.object({
                      "id": z.string().describe("The id of the descriptor.")
                        .optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "A guid that uniquely identifies the descriptor.",
                      ).optional(),
                      "toolComponent": z.object({
                        "name": z.string().describe(
                          "The 'name' property of the referenced toolComponent.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "An index into the referenced toolComponent in tool.extensions.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "The 'guid' property of the referenced toolComponent.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Identifies a particular toolComponent object, either the driver or an extension.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any(), z.any()]))
                      .describe(
                        "Information about how to locate a relevant reporting descriptor.",
                      ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one reporting descriptor to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this reporting descriptor and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
              ),
            ).min(0).describe(
              "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
            ).default([]),
            "rules": z.array(
              z.object({
                "id": z.string().describe(
                  "A stable, opaque identifier for the report.",
                ),
                "deprecatedIds": z.array(z.string()).min(0).describe(
                  "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "A unique identifier for the reporting descriptor in the form of a GUID.",
                ).optional(),
                "deprecatedGuids": z.array(
                  z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ),
                ).min(0).describe(
                  "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "name": z.string().describe(
                  "A report identifier that is understandable to an end user.",
                ).optional(),
                "deprecatedNames": z.array(z.string()).min(0).describe(
                  "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "shortDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "fullDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "messageStrings": z.record(
                  z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ),
                ).describe(
                  "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                ).optional(),
                "defaultConfiguration": z.object({
                  "enabled": z.boolean().describe(
                    "Specifies whether the report may be produced during the scan.",
                  ).default(true),
                  "level": z.enum(["none", "note", "warning", "error"])
                    .describe("Specifies the failure level for the report.")
                    .default("warning"),
                  "rank": z.number().gte(-1).lte(100).describe(
                    "Specifies the relative priority of the report. Used for analysis output only.",
                  ).default(-1),
                  "parameters": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about a rule or notification that can be configured at runtime.",
                ).optional(),
                "helpUri": z.string().url().describe(
                  "A URI where the primary documentation for the report can be found.",
                ).optional(),
                "help": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "relationships": z.array(
                  z.object({
                    "target": z.object({
                      "id": z.string().describe("The id of the descriptor.")
                        .optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "A guid that uniquely identifies the descriptor.",
                      ).optional(),
                      "toolComponent": z.object({
                        "name": z.string().describe(
                          "The 'name' property of the referenced toolComponent.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "An index into the referenced toolComponent in tool.extensions.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "The 'guid' property of the referenced toolComponent.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Identifies a particular toolComponent object, either the driver or an extension.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any(), z.any()]))
                      .describe(
                        "Information about how to locate a relevant reporting descriptor.",
                      ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one reporting descriptor to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this reporting descriptor and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
              ),
            ).min(0).describe(
              "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
            ).default([]),
            "taxa": z.array(
              z.object({
                "id": z.string().describe(
                  "A stable, opaque identifier for the report.",
                ),
                "deprecatedIds": z.array(z.string()).min(0).describe(
                  "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "A unique identifier for the reporting descriptor in the form of a GUID.",
                ).optional(),
                "deprecatedGuids": z.array(
                  z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ),
                ).min(0).describe(
                  "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "name": z.string().describe(
                  "A report identifier that is understandable to an end user.",
                ).optional(),
                "deprecatedNames": z.array(z.string()).min(0).describe(
                  "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "shortDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "fullDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "messageStrings": z.record(
                  z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ),
                ).describe(
                  "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                ).optional(),
                "defaultConfiguration": z.object({
                  "enabled": z.boolean().describe(
                    "Specifies whether the report may be produced during the scan.",
                  ).default(true),
                  "level": z.enum(["none", "note", "warning", "error"])
                    .describe("Specifies the failure level for the report.")
                    .default("warning"),
                  "rank": z.number().gte(-1).lte(100).describe(
                    "Specifies the relative priority of the report. Used for analysis output only.",
                  ).default(-1),
                  "parameters": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about a rule or notification that can be configured at runtime.",
                ).optional(),
                "helpUri": z.string().url().describe(
                  "A URI where the primary documentation for the report can be found.",
                ).optional(),
                "help": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "relationships": z.array(
                  z.object({
                    "target": z.object({
                      "id": z.string().describe("The id of the descriptor.")
                        .optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "A guid that uniquely identifies the descriptor.",
                      ).optional(),
                      "toolComponent": z.object({
                        "name": z.string().describe(
                          "The 'name' property of the referenced toolComponent.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "An index into the referenced toolComponent in tool.extensions.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "The 'guid' property of the referenced toolComponent.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Identifies a particular toolComponent object, either the driver or an extension.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any(), z.any()]))
                      .describe(
                        "Information about how to locate a relevant reporting descriptor.",
                      ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one reporting descriptor to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this reporting descriptor and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
              ),
            ).min(0).describe(
              "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
            ).default([]),
            "locations": z.array(
              z.object({
                "uri": z.string().describe(
                  "A string containing a valid relative or absolute URI.",
                ).optional(),
                "uriBaseId": z.string().describe(
                  'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index within the run artifacts array of the artifact object associated with the artifact location.",
                ).default(-1),
                "description": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("Specifies the location of an artifact."),
            ).min(0).describe(
              "An array of the artifactLocation objects associated with the tool component.",
            ).default([]),
            "language": z.string().regex(
              new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
            ).describe(
              "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
            ).default("en-US"),
            "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
              .describe("The kinds of data contained in this object.").default([
                "localizedData",
                "nonLocalizedData",
              ]),
            "isComprehensive": z.boolean().describe(
              "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
            ).default(false),
            "localizedDataSemanticVersion": z.string().describe(
              "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
            ).optional(),
            "minimumRequiredLocalizedDataSemanticVersion": z.string().describe(
              "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
            ).optional(),
            "associatedComponent": z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ).optional(),
            "translationMetadata": z.object({
              "name": z.string().describe(
                "The name associated with the translation metadata.",
              ),
              "fullName": z.string().describe(
                "The full name associated with the translation metadata.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "downloadUri": z.string().url().describe(
                "The absolute URI from which the translation metadata can be downloaded.",
              ).optional(),
              "informationUri": z.string().url().describe(
                "The absolute URI from which information related to the translation metadata can be downloaded.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Provides additional metadata related to translation.",
            ).optional(),
            "supportedTaxonomies": z.array(
              z.object({
                "name": z.string().describe(
                  "The 'name' property of the referenced toolComponent.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "An index into the referenced toolComponent in tool.extensions.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "The 'guid' property of the referenced toolComponent.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Identifies a particular toolComponent object, either the driver or an extension.",
              ),
            ).min(0).describe(
              "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A component, such as a plug-in or the driver, of the analysis tool that was run.",
          ),
        ).min(0).describe(
          "Tool extensions that contributed to or reconfigured the analysis tool that was run.",
        ).default([]),
        "properties": z.object({
          "tags": z.array(z.string()).min(0).describe(
            "A set of distinct strings that provide additional information.",
          ).default([]),
        }).catchall(z.any()).describe(
          "Key/value pairs that provide additional information about the object.",
        ).optional(),
      }).strict().describe("The analysis tool that was run."),
      "invocations": z.array(
        z.object({
          "commandLine": z.string().describe(
            "The command line used to invoke the tool.",
          ).optional(),
          "arguments": z.array(z.string()).min(0).describe(
            "An array of strings, containing in order the command line arguments passed to the tool from the operating system.",
          ).optional(),
          "responseFiles": z.array(
            z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact."),
          ).min(0).describe(
            "The locations of any response files specified on the tool's command line.",
          ).optional(),
          "startTimeUtc": z.string().datetime({ offset: true }).describe(
            'The Coordinated Universal Time (UTC) date and time at which the run started. See "Date/time properties" in the SARIF spec for the required format.',
          ).optional(),
          "endTimeUtc": z.string().datetime({ offset: true }).describe(
            'The Coordinated Universal Time (UTC) date and time at which the run ended. See "Date/time properties" in the SARIF spec for the required format.',
          ).optional(),
          "exitCode": z.number().int().describe("The process exit code.")
            .optional(),
          "ruleConfigurationOverrides": z.array(
            z.object({
              "configuration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Information about how a specific rule or notification was reconfigured at runtime.",
            ),
          ).min(0).describe(
            "An array of configurationOverride objects that describe rules related runtime overrides.",
          ).default([]),
          "notificationConfigurationOverrides": z.array(
            z.object({
              "configuration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Information about how a specific rule or notification was reconfigured at runtime.",
            ),
          ).min(0).describe(
            "An array of configurationOverride objects that describe notifications related runtime overrides.",
          ).default([]),
          "toolExecutionNotifications": z.array(
            z.object({
              "locations": z.array(
                z.object({
                  "id": z.number().int().gte(-1).describe(
                    "Value that distinguishes this location from all other locations within a single result object.",
                  ).default(-1),
                  "physicalLocation": z.object({
                    "address": z.object({
                      "absoluteAddress": z.number().int().gte(-1).describe(
                        "The address expressed as a byte offset from the start of the addressable region.",
                      ).default(-1),
                      "relativeAddress": z.number().int().describe(
                        "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                      ).optional(),
                      "length": z.number().int().describe(
                        "The number of bytes in this range of addresses.",
                      ).optional(),
                      "kind": z.string().describe(
                        "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                      ).optional(),
                      "name": z.string().describe(
                        "A name that is associated with the address, e.g., '.text'.",
                      ).optional(),
                      "fullyQualifiedName": z.string().describe(
                        "A human-readable fully qualified name that is associated with the address.",
                      ).optional(),
                      "offsetFromParent": z.number().int().describe(
                        "The byte offset of this address from the absolute or relative address of the parent object.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the cached object for this address.",
                      ).default(-1),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the parent object.",
                      ).default(-1),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                    ).optional(),
                    "artifactLocation": z.object({
                      "uri": z.string().describe(
                        "A string containing a valid relative or absolute URI.",
                      ).optional(),
                      "uriBaseId": z.string().describe(
                        'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the run artifacts array of the artifact object associated with the artifact location.",
                      ).default(-1),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Specifies the location of an artifact.",
                    ).optional(),
                    "region": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "contextRegion": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                  ).optional(),
                  "logicalLocations": z.array(
                    z.object({
                      "name": z.string().describe(
                        "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the logical locations array.",
                      ).default(-1),
                      "fullyQualifiedName": z.string().describe(
                        "The human-readable fully qualified name of the logical location.",
                      ).optional(),
                      "decoratedName": z.string().describe(
                        "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                      ).optional(),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                      ).default(-1),
                      "kind": z.string().describe(
                        "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A logical location of a construct that produced a result.",
                    ),
                  ).min(0).describe(
                    "The logical locations associated with the result.",
                  ).default([]),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "annotations": z.array(
                    z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ),
                  ).min(0).describe(
                    "A set of regions relevant to the location.",
                  ).default([]),
                  "relationships": z.array(
                    z.object({
                      "target": z.number().int().gte(0).describe(
                        "A reference to the related location.",
                      ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one location to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this location and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A location within a programming artifact.",
                ),
              ).min(0).describe("The locations relevant to this notification.")
                .default([]),
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ),
              "level": z.enum(["none", "note", "warning", "error"]).describe(
                "A value specifying the severity level of the notification.",
              ).default("warning"),
              "threadId": z.number().int().describe(
                "The thread identifier of the code that generated the notification.",
              ).optional(),
              "timeUtc": z.string().datetime({ offset: true }).describe(
                "The Coordinated Universal Time (UTC) date and time at which the analysis tool generated the notification.",
              ).optional(),
              "exception": z.object({
                "kind": z.string().describe(
                  "A string that identifies the kind of exception, for example, the fully qualified type name of an object that was thrown, or the symbolic name of a signal.",
                ).optional(),
                "message": z.string().describe(
                  "A message that describes the exception.",
                ).optional(),
                "stack": z.object({
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "frames": z.array(
                    z.object({
                      "location": z.object({
                        "id": z.number().int().gte(-1).describe(
                          "Value that distinguishes this location from all other locations within a single result object.",
                        ).default(-1),
                        "physicalLocation": z.object({
                          "address": z.object({
                            "absoluteAddress": z.number().int().gte(-1)
                              .describe(
                                "The address expressed as a byte offset from the start of the addressable region.",
                              ).default(-1),
                            "relativeAddress": z.number().int().describe(
                              "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                            ).optional(),
                            "length": z.number().int().describe(
                              "The number of bytes in this range of addresses.",
                            ).optional(),
                            "kind": z.string().describe(
                              "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                            ).optional(),
                            "name": z.string().describe(
                              "A name that is associated with the address, e.g., '.text'.",
                            ).optional(),
                            "fullyQualifiedName": z.string().describe(
                              "A human-readable fully qualified name that is associated with the address.",
                            ).optional(),
                            "offsetFromParent": z.number().int().describe(
                              "The byte offset of this address from the absolute or relative address of the parent object.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the cached object for this address.",
                            ).default(-1),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the parent object.",
                            ).default(-1),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                          ).optional(),
                          "artifactLocation": z.object({
                            "uri": z.string().describe(
                              "A string containing a valid relative or absolute URI.",
                            ).optional(),
                            "uriBaseId": z.string().describe(
                              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the run artifacts array of the artifact object associated with the artifact location.",
                            ).default(-1),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Specifies the location of an artifact.",
                          ).optional(),
                          "region": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "contextRegion": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                        ).optional(),
                        "logicalLocations": z.array(
                          z.object({
                            "name": z.string().describe(
                              "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the logical locations array.",
                            ).default(-1),
                            "fullyQualifiedName": z.string().describe(
                              "The human-readable fully qualified name of the logical location.",
                            ).optional(),
                            "decoratedName": z.string().describe(
                              "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                            ).optional(),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                            ).default(-1),
                            "kind": z.string().describe(
                              "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A logical location of a construct that produced a result.",
                          ),
                        ).min(0).describe(
                          "The logical locations associated with the result.",
                        ).default([]),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "annotations": z.array(
                          z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ),
                        ).min(0).describe(
                          "A set of regions relevant to the location.",
                        ).default([]),
                        "relationships": z.array(
                          z.object({
                            "target": z.number().int().gte(0).describe(
                              "A reference to the related location.",
                            ),
                            "kinds": z.array(z.string()).describe(
                              "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                            ).default(["relevant"]),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Information about the relation of one location to another.",
                          ),
                        ).min(0).describe(
                          "An array of objects that describe relationships between this location and others.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A location within a programming artifact.",
                      ).optional(),
                      "module": z.string().describe(
                        "The name of the module that contains the code of this stack frame.",
                      ).optional(),
                      "threadId": z.number().int().describe(
                        "The thread identifier of the stack frame.",
                      ).optional(),
                      "parameters": z.array(z.string().default([])).min(0)
                        .describe(
                          "The parameters of the call that is executing.",
                        ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A function call within a stack trace.",
                    ),
                  ).min(0).describe(
                    "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A call stack that is relevant to a result.",
                ).optional(),
                "innerExceptions": z.array(z.any()).min(0).describe(
                  "An array of exception objects each of which is considered a cause of this exception.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Describes a runtime exception encountered during the execution of an analysis tool.",
              ).optional(),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "associatedRule": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Describes a condition relevant to the tool itself, as opposed to being relevant to a target being analyzed by the tool.",
            ),
          ).min(0).describe(
            "A list of runtime conditions detected by the tool during the analysis.",
          ).default([]),
          "toolConfigurationNotifications": z.array(
            z.object({
              "locations": z.array(
                z.object({
                  "id": z.number().int().gte(-1).describe(
                    "Value that distinguishes this location from all other locations within a single result object.",
                  ).default(-1),
                  "physicalLocation": z.object({
                    "address": z.object({
                      "absoluteAddress": z.number().int().gte(-1).describe(
                        "The address expressed as a byte offset from the start of the addressable region.",
                      ).default(-1),
                      "relativeAddress": z.number().int().describe(
                        "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                      ).optional(),
                      "length": z.number().int().describe(
                        "The number of bytes in this range of addresses.",
                      ).optional(),
                      "kind": z.string().describe(
                        "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                      ).optional(),
                      "name": z.string().describe(
                        "A name that is associated with the address, e.g., '.text'.",
                      ).optional(),
                      "fullyQualifiedName": z.string().describe(
                        "A human-readable fully qualified name that is associated with the address.",
                      ).optional(),
                      "offsetFromParent": z.number().int().describe(
                        "The byte offset of this address from the absolute or relative address of the parent object.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the cached object for this address.",
                      ).default(-1),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the parent object.",
                      ).default(-1),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                    ).optional(),
                    "artifactLocation": z.object({
                      "uri": z.string().describe(
                        "A string containing a valid relative or absolute URI.",
                      ).optional(),
                      "uriBaseId": z.string().describe(
                        'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the run artifacts array of the artifact object associated with the artifact location.",
                      ).default(-1),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Specifies the location of an artifact.",
                    ).optional(),
                    "region": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "contextRegion": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                  ).optional(),
                  "logicalLocations": z.array(
                    z.object({
                      "name": z.string().describe(
                        "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the logical locations array.",
                      ).default(-1),
                      "fullyQualifiedName": z.string().describe(
                        "The human-readable fully qualified name of the logical location.",
                      ).optional(),
                      "decoratedName": z.string().describe(
                        "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                      ).optional(),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                      ).default(-1),
                      "kind": z.string().describe(
                        "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A logical location of a construct that produced a result.",
                    ),
                  ).min(0).describe(
                    "The logical locations associated with the result.",
                  ).default([]),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "annotations": z.array(
                    z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ),
                  ).min(0).describe(
                    "A set of regions relevant to the location.",
                  ).default([]),
                  "relationships": z.array(
                    z.object({
                      "target": z.number().int().gte(0).describe(
                        "A reference to the related location.",
                      ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one location to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this location and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A location within a programming artifact.",
                ),
              ).min(0).describe("The locations relevant to this notification.")
                .default([]),
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ),
              "level": z.enum(["none", "note", "warning", "error"]).describe(
                "A value specifying the severity level of the notification.",
              ).default("warning"),
              "threadId": z.number().int().describe(
                "The thread identifier of the code that generated the notification.",
              ).optional(),
              "timeUtc": z.string().datetime({ offset: true }).describe(
                "The Coordinated Universal Time (UTC) date and time at which the analysis tool generated the notification.",
              ).optional(),
              "exception": z.object({
                "kind": z.string().describe(
                  "A string that identifies the kind of exception, for example, the fully qualified type name of an object that was thrown, or the symbolic name of a signal.",
                ).optional(),
                "message": z.string().describe(
                  "A message that describes the exception.",
                ).optional(),
                "stack": z.object({
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "frames": z.array(
                    z.object({
                      "location": z.object({
                        "id": z.number().int().gte(-1).describe(
                          "Value that distinguishes this location from all other locations within a single result object.",
                        ).default(-1),
                        "physicalLocation": z.object({
                          "address": z.object({
                            "absoluteAddress": z.number().int().gte(-1)
                              .describe(
                                "The address expressed as a byte offset from the start of the addressable region.",
                              ).default(-1),
                            "relativeAddress": z.number().int().describe(
                              "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                            ).optional(),
                            "length": z.number().int().describe(
                              "The number of bytes in this range of addresses.",
                            ).optional(),
                            "kind": z.string().describe(
                              "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                            ).optional(),
                            "name": z.string().describe(
                              "A name that is associated with the address, e.g., '.text'.",
                            ).optional(),
                            "fullyQualifiedName": z.string().describe(
                              "A human-readable fully qualified name that is associated with the address.",
                            ).optional(),
                            "offsetFromParent": z.number().int().describe(
                              "The byte offset of this address from the absolute or relative address of the parent object.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the cached object for this address.",
                            ).default(-1),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the parent object.",
                            ).default(-1),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                          ).optional(),
                          "artifactLocation": z.object({
                            "uri": z.string().describe(
                              "A string containing a valid relative or absolute URI.",
                            ).optional(),
                            "uriBaseId": z.string().describe(
                              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the run artifacts array of the artifact object associated with the artifact location.",
                            ).default(-1),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Specifies the location of an artifact.",
                          ).optional(),
                          "region": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "contextRegion": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                        ).optional(),
                        "logicalLocations": z.array(
                          z.object({
                            "name": z.string().describe(
                              "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the logical locations array.",
                            ).default(-1),
                            "fullyQualifiedName": z.string().describe(
                              "The human-readable fully qualified name of the logical location.",
                            ).optional(),
                            "decoratedName": z.string().describe(
                              "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                            ).optional(),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                            ).default(-1),
                            "kind": z.string().describe(
                              "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A logical location of a construct that produced a result.",
                          ),
                        ).min(0).describe(
                          "The logical locations associated with the result.",
                        ).default([]),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "annotations": z.array(
                          z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ),
                        ).min(0).describe(
                          "A set of regions relevant to the location.",
                        ).default([]),
                        "relationships": z.array(
                          z.object({
                            "target": z.number().int().gte(0).describe(
                              "A reference to the related location.",
                            ),
                            "kinds": z.array(z.string()).describe(
                              "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                            ).default(["relevant"]),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Information about the relation of one location to another.",
                          ),
                        ).min(0).describe(
                          "An array of objects that describe relationships between this location and others.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A location within a programming artifact.",
                      ).optional(),
                      "module": z.string().describe(
                        "The name of the module that contains the code of this stack frame.",
                      ).optional(),
                      "threadId": z.number().int().describe(
                        "The thread identifier of the stack frame.",
                      ).optional(),
                      "parameters": z.array(z.string().default([])).min(0)
                        .describe(
                          "The parameters of the call that is executing.",
                        ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A function call within a stack trace.",
                    ),
                  ).min(0).describe(
                    "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A call stack that is relevant to a result.",
                ).optional(),
                "innerExceptions": z.array(z.any()).min(0).describe(
                  "An array of exception objects each of which is considered a cause of this exception.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Describes a runtime exception encountered during the execution of an analysis tool.",
              ).optional(),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "associatedRule": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Describes a condition relevant to the tool itself, as opposed to being relevant to a target being analyzed by the tool.",
            ),
          ).min(0).describe(
            "A list of conditions detected by the tool that are relevant to the tool's configuration.",
          ).default([]),
          "exitCodeDescription": z.string().describe(
            "The reason for the process exit.",
          ).optional(),
          "exitSignalName": z.string().describe(
            "The name of the signal that caused the process to exit.",
          ).optional(),
          "exitSignalNumber": z.number().int().describe(
            "The numeric value of the signal that caused the process to exit.",
          ).optional(),
          "processStartFailureMessage": z.string().describe(
            "The reason given by the operating system that the process failed to start.",
          ).optional(),
          "executionSuccessful": z.boolean().describe(
            "Specifies whether the tool's execution completed successfully.",
          ),
          "machine": z.string().describe(
            "The machine that hosted the analysis tool run.",
          ).optional(),
          "account": z.string().describe(
            "The account that ran the analysis tool.",
          ).optional(),
          "processId": z.number().int().describe(
            "The process id for the analysis tool run.",
          ).optional(),
          "executableLocation": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "workingDirectory": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "environmentVariables": z.record(z.string()).describe(
            "The environment variables associated with the analysis tool process, expressed as key/value pairs.",
          ).optional(),
          "stdin": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "stdout": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "stderr": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "stdoutStderr": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "The runtime environment of the analysis tool run.",
        ),
      ).min(0).describe("Describes the invocation of the analysis tool.")
        .default([]),
      "conversion": z.object({
        "tool": z.object({
          "driver": z.object({
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A unique identifier for the tool component in the form of a GUID.",
            ).optional(),
            "name": z.string().describe("The name of the tool component."),
            "organization": z.string().describe(
              "The organization or company that produced the tool component.",
            ).optional(),
            "product": z.string().describe(
              "A product suite to which the tool component belongs.",
            ).optional(),
            "productSuite": z.string().describe(
              "A localizable string containing the name of the suite of products to which the tool component belongs.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullName": z.string().describe(
              "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
            ).optional(),
            "version": z.string().describe(
              "The tool component version, in whatever format the component natively provides.",
            ).optional(),
            "semanticVersion": z.string().describe(
              "The tool component version in the format specified by Semantic Versioning 2.0.",
            ).optional(),
            "dottedQuadFileVersion": z.string().regex(
              new RegExp("[0-9]+(\\.[0-9]+){3}"),
            ).describe(
              "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
            ).optional(),
            "releaseDateUtc": z.string().describe(
              "A string specifying the UTC date (and optionally, the time) of the component's release.",
            ).optional(),
            "downloadUri": z.string().url().describe(
              "The absolute URI from which the tool component can be downloaded.",
            ).optional(),
            "informationUri": z.string().url().describe(
              "The absolute URI at which information about this version of the tool component can be found.",
            ).optional(),
            "globalMessageStrings": z.record(
              z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ),
            ).describe(
              "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
            ).optional(),
            "notifications": z.array(
              z.object({
                "id": z.string().describe(
                  "A stable, opaque identifier for the report.",
                ),
                "deprecatedIds": z.array(z.string()).min(0).describe(
                  "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "A unique identifier for the reporting descriptor in the form of a GUID.",
                ).optional(),
                "deprecatedGuids": z.array(
                  z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ),
                ).min(0).describe(
                  "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "name": z.string().describe(
                  "A report identifier that is understandable to an end user.",
                ).optional(),
                "deprecatedNames": z.array(z.string()).min(0).describe(
                  "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "shortDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "fullDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "messageStrings": z.record(
                  z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ),
                ).describe(
                  "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                ).optional(),
                "defaultConfiguration": z.object({
                  "enabled": z.boolean().describe(
                    "Specifies whether the report may be produced during the scan.",
                  ).default(true),
                  "level": z.enum(["none", "note", "warning", "error"])
                    .describe("Specifies the failure level for the report.")
                    .default("warning"),
                  "rank": z.number().gte(-1).lte(100).describe(
                    "Specifies the relative priority of the report. Used for analysis output only.",
                  ).default(-1),
                  "parameters": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about a rule or notification that can be configured at runtime.",
                ).optional(),
                "helpUri": z.string().url().describe(
                  "A URI where the primary documentation for the report can be found.",
                ).optional(),
                "help": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "relationships": z.array(
                  z.object({
                    "target": z.object({
                      "id": z.string().describe("The id of the descriptor.")
                        .optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "A guid that uniquely identifies the descriptor.",
                      ).optional(),
                      "toolComponent": z.object({
                        "name": z.string().describe(
                          "The 'name' property of the referenced toolComponent.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "An index into the referenced toolComponent in tool.extensions.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "The 'guid' property of the referenced toolComponent.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Identifies a particular toolComponent object, either the driver or an extension.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any(), z.any()]))
                      .describe(
                        "Information about how to locate a relevant reporting descriptor.",
                      ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one reporting descriptor to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this reporting descriptor and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
              ),
            ).min(0).describe(
              "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
            ).default([]),
            "rules": z.array(
              z.object({
                "id": z.string().describe(
                  "A stable, opaque identifier for the report.",
                ),
                "deprecatedIds": z.array(z.string()).min(0).describe(
                  "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "A unique identifier for the reporting descriptor in the form of a GUID.",
                ).optional(),
                "deprecatedGuids": z.array(
                  z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ),
                ).min(0).describe(
                  "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "name": z.string().describe(
                  "A report identifier that is understandable to an end user.",
                ).optional(),
                "deprecatedNames": z.array(z.string()).min(0).describe(
                  "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "shortDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "fullDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "messageStrings": z.record(
                  z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ),
                ).describe(
                  "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                ).optional(),
                "defaultConfiguration": z.object({
                  "enabled": z.boolean().describe(
                    "Specifies whether the report may be produced during the scan.",
                  ).default(true),
                  "level": z.enum(["none", "note", "warning", "error"])
                    .describe("Specifies the failure level for the report.")
                    .default("warning"),
                  "rank": z.number().gte(-1).lte(100).describe(
                    "Specifies the relative priority of the report. Used for analysis output only.",
                  ).default(-1),
                  "parameters": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about a rule or notification that can be configured at runtime.",
                ).optional(),
                "helpUri": z.string().url().describe(
                  "A URI where the primary documentation for the report can be found.",
                ).optional(),
                "help": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "relationships": z.array(
                  z.object({
                    "target": z.object({
                      "id": z.string().describe("The id of the descriptor.")
                        .optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "A guid that uniquely identifies the descriptor.",
                      ).optional(),
                      "toolComponent": z.object({
                        "name": z.string().describe(
                          "The 'name' property of the referenced toolComponent.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "An index into the referenced toolComponent in tool.extensions.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "The 'guid' property of the referenced toolComponent.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Identifies a particular toolComponent object, either the driver or an extension.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any(), z.any()]))
                      .describe(
                        "Information about how to locate a relevant reporting descriptor.",
                      ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one reporting descriptor to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this reporting descriptor and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
              ),
            ).min(0).describe(
              "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
            ).default([]),
            "taxa": z.array(
              z.object({
                "id": z.string().describe(
                  "A stable, opaque identifier for the report.",
                ),
                "deprecatedIds": z.array(z.string()).min(0).describe(
                  "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "A unique identifier for the reporting descriptor in the form of a GUID.",
                ).optional(),
                "deprecatedGuids": z.array(
                  z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ),
                ).min(0).describe(
                  "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "name": z.string().describe(
                  "A report identifier that is understandable to an end user.",
                ).optional(),
                "deprecatedNames": z.array(z.string()).min(0).describe(
                  "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "shortDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "fullDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "messageStrings": z.record(
                  z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ),
                ).describe(
                  "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                ).optional(),
                "defaultConfiguration": z.object({
                  "enabled": z.boolean().describe(
                    "Specifies whether the report may be produced during the scan.",
                  ).default(true),
                  "level": z.enum(["none", "note", "warning", "error"])
                    .describe("Specifies the failure level for the report.")
                    .default("warning"),
                  "rank": z.number().gte(-1).lte(100).describe(
                    "Specifies the relative priority of the report. Used for analysis output only.",
                  ).default(-1),
                  "parameters": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about a rule or notification that can be configured at runtime.",
                ).optional(),
                "helpUri": z.string().url().describe(
                  "A URI where the primary documentation for the report can be found.",
                ).optional(),
                "help": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "relationships": z.array(
                  z.object({
                    "target": z.object({
                      "id": z.string().describe("The id of the descriptor.")
                        .optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "A guid that uniquely identifies the descriptor.",
                      ).optional(),
                      "toolComponent": z.object({
                        "name": z.string().describe(
                          "The 'name' property of the referenced toolComponent.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "An index into the referenced toolComponent in tool.extensions.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "The 'guid' property of the referenced toolComponent.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Identifies a particular toolComponent object, either the driver or an extension.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any(), z.any()]))
                      .describe(
                        "Information about how to locate a relevant reporting descriptor.",
                      ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one reporting descriptor to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this reporting descriptor and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
              ),
            ).min(0).describe(
              "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
            ).default([]),
            "locations": z.array(
              z.object({
                "uri": z.string().describe(
                  "A string containing a valid relative or absolute URI.",
                ).optional(),
                "uriBaseId": z.string().describe(
                  'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index within the run artifacts array of the artifact object associated with the artifact location.",
                ).default(-1),
                "description": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("Specifies the location of an artifact."),
            ).min(0).describe(
              "An array of the artifactLocation objects associated with the tool component.",
            ).default([]),
            "language": z.string().regex(
              new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
            ).describe(
              "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
            ).default("en-US"),
            "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
              .describe("The kinds of data contained in this object.").default([
                "localizedData",
                "nonLocalizedData",
              ]),
            "isComprehensive": z.boolean().describe(
              "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
            ).default(false),
            "localizedDataSemanticVersion": z.string().describe(
              "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
            ).optional(),
            "minimumRequiredLocalizedDataSemanticVersion": z.string().describe(
              "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
            ).optional(),
            "associatedComponent": z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ).optional(),
            "translationMetadata": z.object({
              "name": z.string().describe(
                "The name associated with the translation metadata.",
              ),
              "fullName": z.string().describe(
                "The full name associated with the translation metadata.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "downloadUri": z.string().url().describe(
                "The absolute URI from which the translation metadata can be downloaded.",
              ).optional(),
              "informationUri": z.string().url().describe(
                "The absolute URI from which information related to the translation metadata can be downloaded.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Provides additional metadata related to translation.",
            ).optional(),
            "supportedTaxonomies": z.array(
              z.object({
                "name": z.string().describe(
                  "The 'name' property of the referenced toolComponent.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "An index into the referenced toolComponent in tool.extensions.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "The 'guid' property of the referenced toolComponent.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Identifies a particular toolComponent object, either the driver or an extension.",
              ),
            ).min(0).describe(
              "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A component, such as a plug-in or the driver, of the analysis tool that was run.",
          ),
          "extensions": z.array(
            z.object({
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the tool component in the form of a GUID.",
              ).optional(),
              "name": z.string().describe("The name of the tool component."),
              "organization": z.string().describe(
                "The organization or company that produced the tool component.",
              ).optional(),
              "product": z.string().describe(
                "A product suite to which the tool component belongs.",
              ).optional(),
              "productSuite": z.string().describe(
                "A localizable string containing the name of the suite of products to which the tool component belongs.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullName": z.string().describe(
                "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
              ).optional(),
              "version": z.string().describe(
                "The tool component version, in whatever format the component natively provides.",
              ).optional(),
              "semanticVersion": z.string().describe(
                "The tool component version in the format specified by Semantic Versioning 2.0.",
              ).optional(),
              "dottedQuadFileVersion": z.string().regex(
                new RegExp("[0-9]+(\\.[0-9]+){3}"),
              ).describe(
                "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
              ).optional(),
              "releaseDateUtc": z.string().describe(
                "A string specifying the UTC date (and optionally, the time) of the component's release.",
              ).optional(),
              "downloadUri": z.string().url().describe(
                "The absolute URI from which the tool component can be downloaded.",
              ).optional(),
              "informationUri": z.string().url().describe(
                "The absolute URI at which information about this version of the tool component can be found.",
              ).optional(),
              "globalMessageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "notifications": z.array(
                z.object({
                  "id": z.string().describe(
                    "A stable, opaque identifier for the report.",
                  ),
                  "deprecatedIds": z.array(z.string()).min(0).describe(
                    "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "A unique identifier for the reporting descriptor in the form of a GUID.",
                  ).optional(),
                  "deprecatedGuids": z.array(
                    z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ),
                  ).min(0).describe(
                    "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "name": z.string().describe(
                    "A report identifier that is understandable to an end user.",
                  ).optional(),
                  "deprecatedNames": z.array(z.string()).min(0).describe(
                    "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "shortDescription": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "fullDescription": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "messageStrings": z.record(
                    z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ),
                  ).describe(
                    "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                  ).optional(),
                  "defaultConfiguration": z.object({
                    "enabled": z.boolean().describe(
                      "Specifies whether the report may be produced during the scan.",
                    ).default(true),
                    "level": z.enum(["none", "note", "warning", "error"])
                      .describe("Specifies the failure level for the report.")
                      .default("warning"),
                    "rank": z.number().gte(-1).lte(100).describe(
                      "Specifies the relative priority of the report. Used for analysis output only.",
                    ).default(-1),
                    "parameters": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about a rule or notification that can be configured at runtime.",
                  ).optional(),
                  "helpUri": z.string().url().describe(
                    "A URI where the primary documentation for the report can be found.",
                  ).optional(),
                  "help": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "relationships": z.array(
                    z.object({
                      "target": z.object({
                        "id": z.string().describe("The id of the descriptor.")
                          .optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "A guid that uniquely identifies the descriptor.",
                        ).optional(),
                        "toolComponent": z.object({
                          "name": z.string().describe(
                            "The 'name' property of the referenced toolComponent.",
                          ).optional(),
                          "index": z.number().int().gte(-1).describe(
                            "An index into the referenced toolComponent in tool.extensions.",
                          ).default(-1),
                          "guid": z.string().regex(
                            new RegExp(
                              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                            ),
                          ).describe(
                            "The 'guid' property of the referenced toolComponent.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Identifies a particular toolComponent object, either the driver or an extension.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any(), z.any()]))
                        .describe(
                          "Information about how to locate a relevant reporting descriptor.",
                        ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one reporting descriptor to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this reporting descriptor and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
                ),
              ).min(0).describe(
                "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
              ).default([]),
              "rules": z.array(
                z.object({
                  "id": z.string().describe(
                    "A stable, opaque identifier for the report.",
                  ),
                  "deprecatedIds": z.array(z.string()).min(0).describe(
                    "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "A unique identifier for the reporting descriptor in the form of a GUID.",
                  ).optional(),
                  "deprecatedGuids": z.array(
                    z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ),
                  ).min(0).describe(
                    "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "name": z.string().describe(
                    "A report identifier that is understandable to an end user.",
                  ).optional(),
                  "deprecatedNames": z.array(z.string()).min(0).describe(
                    "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "shortDescription": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "fullDescription": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "messageStrings": z.record(
                    z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ),
                  ).describe(
                    "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                  ).optional(),
                  "defaultConfiguration": z.object({
                    "enabled": z.boolean().describe(
                      "Specifies whether the report may be produced during the scan.",
                    ).default(true),
                    "level": z.enum(["none", "note", "warning", "error"])
                      .describe("Specifies the failure level for the report.")
                      .default("warning"),
                    "rank": z.number().gte(-1).lte(100).describe(
                      "Specifies the relative priority of the report. Used for analysis output only.",
                    ).default(-1),
                    "parameters": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about a rule or notification that can be configured at runtime.",
                  ).optional(),
                  "helpUri": z.string().url().describe(
                    "A URI where the primary documentation for the report can be found.",
                  ).optional(),
                  "help": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "relationships": z.array(
                    z.object({
                      "target": z.object({
                        "id": z.string().describe("The id of the descriptor.")
                          .optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "A guid that uniquely identifies the descriptor.",
                        ).optional(),
                        "toolComponent": z.object({
                          "name": z.string().describe(
                            "The 'name' property of the referenced toolComponent.",
                          ).optional(),
                          "index": z.number().int().gte(-1).describe(
                            "An index into the referenced toolComponent in tool.extensions.",
                          ).default(-1),
                          "guid": z.string().regex(
                            new RegExp(
                              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                            ),
                          ).describe(
                            "The 'guid' property of the referenced toolComponent.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Identifies a particular toolComponent object, either the driver or an extension.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any(), z.any()]))
                        .describe(
                          "Information about how to locate a relevant reporting descriptor.",
                        ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one reporting descriptor to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this reporting descriptor and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
                ),
              ).min(0).describe(
                "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
              ).default([]),
              "taxa": z.array(
                z.object({
                  "id": z.string().describe(
                    "A stable, opaque identifier for the report.",
                  ),
                  "deprecatedIds": z.array(z.string()).min(0).describe(
                    "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "A unique identifier for the reporting descriptor in the form of a GUID.",
                  ).optional(),
                  "deprecatedGuids": z.array(
                    z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ),
                  ).min(0).describe(
                    "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "name": z.string().describe(
                    "A report identifier that is understandable to an end user.",
                  ).optional(),
                  "deprecatedNames": z.array(z.string()).min(0).describe(
                    "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "shortDescription": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "fullDescription": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "messageStrings": z.record(
                    z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ),
                  ).describe(
                    "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                  ).optional(),
                  "defaultConfiguration": z.object({
                    "enabled": z.boolean().describe(
                      "Specifies whether the report may be produced during the scan.",
                    ).default(true),
                    "level": z.enum(["none", "note", "warning", "error"])
                      .describe("Specifies the failure level for the report.")
                      .default("warning"),
                    "rank": z.number().gte(-1).lte(100).describe(
                      "Specifies the relative priority of the report. Used for analysis output only.",
                    ).default(-1),
                    "parameters": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about a rule or notification that can be configured at runtime.",
                  ).optional(),
                  "helpUri": z.string().url().describe(
                    "A URI where the primary documentation for the report can be found.",
                  ).optional(),
                  "help": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "relationships": z.array(
                    z.object({
                      "target": z.object({
                        "id": z.string().describe("The id of the descriptor.")
                          .optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "A guid that uniquely identifies the descriptor.",
                        ).optional(),
                        "toolComponent": z.object({
                          "name": z.string().describe(
                            "The 'name' property of the referenced toolComponent.",
                          ).optional(),
                          "index": z.number().int().gte(-1).describe(
                            "An index into the referenced toolComponent in tool.extensions.",
                          ).default(-1),
                          "guid": z.string().regex(
                            new RegExp(
                              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                            ),
                          ).describe(
                            "The 'guid' property of the referenced toolComponent.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Identifies a particular toolComponent object, either the driver or an extension.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any(), z.any()]))
                        .describe(
                          "Information about how to locate a relevant reporting descriptor.",
                        ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one reporting descriptor to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this reporting descriptor and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
                ),
              ).min(0).describe(
                "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
              ).default([]),
              "locations": z.array(
                z.object({
                  "uri": z.string().describe(
                    "A string containing a valid relative or absolute URI.",
                  ).optional(),
                  "uriBaseId": z.string().describe(
                    'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within the run artifacts array of the artifact object associated with the artifact location.",
                  ).default(-1),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Specifies the location of an artifact."),
              ).min(0).describe(
                "An array of the artifactLocation objects associated with the tool component.",
              ).default([]),
              "language": z.string().regex(
                new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
              ).describe(
                "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
              ).default("en-US"),
              "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
                .describe("The kinds of data contained in this object.")
                .default(["localizedData", "nonLocalizedData"]),
              "isComprehensive": z.boolean().describe(
                "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
              ).default(false),
              "localizedDataSemanticVersion": z.string().describe(
                "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
              ).optional(),
              "minimumRequiredLocalizedDataSemanticVersion": z.string()
                .describe(
                  "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
                ).optional(),
              "associatedComponent": z.object({
                "name": z.string().describe(
                  "The 'name' property of the referenced toolComponent.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "An index into the referenced toolComponent in tool.extensions.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "The 'guid' property of the referenced toolComponent.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Identifies a particular toolComponent object, either the driver or an extension.",
              ).optional(),
              "translationMetadata": z.object({
                "name": z.string().describe(
                  "The name associated with the translation metadata.",
                ),
                "fullName": z.string().describe(
                  "The full name associated with the translation metadata.",
                ).optional(),
                "shortDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "fullDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "downloadUri": z.string().url().describe(
                  "The absolute URI from which the translation metadata can be downloaded.",
                ).optional(),
                "informationUri": z.string().url().describe(
                  "The absolute URI from which information related to the translation metadata can be downloaded.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Provides additional metadata related to translation.",
              ).optional(),
              "supportedTaxonomies": z.array(
                z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ),
              ).min(0).describe(
                "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A component, such as a plug-in or the driver, of the analysis tool that was run.",
            ),
          ).min(0).describe(
            "Tool extensions that contributed to or reconfigured the analysis tool that was run.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe("The analysis tool that was run."),
        "invocation": z.object({
          "commandLine": z.string().describe(
            "The command line used to invoke the tool.",
          ).optional(),
          "arguments": z.array(z.string()).min(0).describe(
            "An array of strings, containing in order the command line arguments passed to the tool from the operating system.",
          ).optional(),
          "responseFiles": z.array(
            z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact."),
          ).min(0).describe(
            "The locations of any response files specified on the tool's command line.",
          ).optional(),
          "startTimeUtc": z.string().datetime({ offset: true }).describe(
            'The Coordinated Universal Time (UTC) date and time at which the run started. See "Date/time properties" in the SARIF spec for the required format.',
          ).optional(),
          "endTimeUtc": z.string().datetime({ offset: true }).describe(
            'The Coordinated Universal Time (UTC) date and time at which the run ended. See "Date/time properties" in the SARIF spec for the required format.',
          ).optional(),
          "exitCode": z.number().int().describe("The process exit code.")
            .optional(),
          "ruleConfigurationOverrides": z.array(
            z.object({
              "configuration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Information about how a specific rule or notification was reconfigured at runtime.",
            ),
          ).min(0).describe(
            "An array of configurationOverride objects that describe rules related runtime overrides.",
          ).default([]),
          "notificationConfigurationOverrides": z.array(
            z.object({
              "configuration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Information about how a specific rule or notification was reconfigured at runtime.",
            ),
          ).min(0).describe(
            "An array of configurationOverride objects that describe notifications related runtime overrides.",
          ).default([]),
          "toolExecutionNotifications": z.array(
            z.object({
              "locations": z.array(
                z.object({
                  "id": z.number().int().gte(-1).describe(
                    "Value that distinguishes this location from all other locations within a single result object.",
                  ).default(-1),
                  "physicalLocation": z.object({
                    "address": z.object({
                      "absoluteAddress": z.number().int().gte(-1).describe(
                        "The address expressed as a byte offset from the start of the addressable region.",
                      ).default(-1),
                      "relativeAddress": z.number().int().describe(
                        "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                      ).optional(),
                      "length": z.number().int().describe(
                        "The number of bytes in this range of addresses.",
                      ).optional(),
                      "kind": z.string().describe(
                        "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                      ).optional(),
                      "name": z.string().describe(
                        "A name that is associated with the address, e.g., '.text'.",
                      ).optional(),
                      "fullyQualifiedName": z.string().describe(
                        "A human-readable fully qualified name that is associated with the address.",
                      ).optional(),
                      "offsetFromParent": z.number().int().describe(
                        "The byte offset of this address from the absolute or relative address of the parent object.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the cached object for this address.",
                      ).default(-1),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the parent object.",
                      ).default(-1),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                    ).optional(),
                    "artifactLocation": z.object({
                      "uri": z.string().describe(
                        "A string containing a valid relative or absolute URI.",
                      ).optional(),
                      "uriBaseId": z.string().describe(
                        'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the run artifacts array of the artifact object associated with the artifact location.",
                      ).default(-1),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Specifies the location of an artifact.",
                    ).optional(),
                    "region": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "contextRegion": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                  ).optional(),
                  "logicalLocations": z.array(
                    z.object({
                      "name": z.string().describe(
                        "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the logical locations array.",
                      ).default(-1),
                      "fullyQualifiedName": z.string().describe(
                        "The human-readable fully qualified name of the logical location.",
                      ).optional(),
                      "decoratedName": z.string().describe(
                        "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                      ).optional(),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                      ).default(-1),
                      "kind": z.string().describe(
                        "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A logical location of a construct that produced a result.",
                    ),
                  ).min(0).describe(
                    "The logical locations associated with the result.",
                  ).default([]),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "annotations": z.array(
                    z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ),
                  ).min(0).describe(
                    "A set of regions relevant to the location.",
                  ).default([]),
                  "relationships": z.array(
                    z.object({
                      "target": z.number().int().gte(0).describe(
                        "A reference to the related location.",
                      ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one location to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this location and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A location within a programming artifact.",
                ),
              ).min(0).describe("The locations relevant to this notification.")
                .default([]),
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ),
              "level": z.enum(["none", "note", "warning", "error"]).describe(
                "A value specifying the severity level of the notification.",
              ).default("warning"),
              "threadId": z.number().int().describe(
                "The thread identifier of the code that generated the notification.",
              ).optional(),
              "timeUtc": z.string().datetime({ offset: true }).describe(
                "The Coordinated Universal Time (UTC) date and time at which the analysis tool generated the notification.",
              ).optional(),
              "exception": z.object({
                "kind": z.string().describe(
                  "A string that identifies the kind of exception, for example, the fully qualified type name of an object that was thrown, or the symbolic name of a signal.",
                ).optional(),
                "message": z.string().describe(
                  "A message that describes the exception.",
                ).optional(),
                "stack": z.object({
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "frames": z.array(
                    z.object({
                      "location": z.object({
                        "id": z.number().int().gte(-1).describe(
                          "Value that distinguishes this location from all other locations within a single result object.",
                        ).default(-1),
                        "physicalLocation": z.object({
                          "address": z.object({
                            "absoluteAddress": z.number().int().gte(-1)
                              .describe(
                                "The address expressed as a byte offset from the start of the addressable region.",
                              ).default(-1),
                            "relativeAddress": z.number().int().describe(
                              "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                            ).optional(),
                            "length": z.number().int().describe(
                              "The number of bytes in this range of addresses.",
                            ).optional(),
                            "kind": z.string().describe(
                              "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                            ).optional(),
                            "name": z.string().describe(
                              "A name that is associated with the address, e.g., '.text'.",
                            ).optional(),
                            "fullyQualifiedName": z.string().describe(
                              "A human-readable fully qualified name that is associated with the address.",
                            ).optional(),
                            "offsetFromParent": z.number().int().describe(
                              "The byte offset of this address from the absolute or relative address of the parent object.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the cached object for this address.",
                            ).default(-1),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the parent object.",
                            ).default(-1),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                          ).optional(),
                          "artifactLocation": z.object({
                            "uri": z.string().describe(
                              "A string containing a valid relative or absolute URI.",
                            ).optional(),
                            "uriBaseId": z.string().describe(
                              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the run artifacts array of the artifact object associated with the artifact location.",
                            ).default(-1),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Specifies the location of an artifact.",
                          ).optional(),
                          "region": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "contextRegion": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                        ).optional(),
                        "logicalLocations": z.array(
                          z.object({
                            "name": z.string().describe(
                              "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the logical locations array.",
                            ).default(-1),
                            "fullyQualifiedName": z.string().describe(
                              "The human-readable fully qualified name of the logical location.",
                            ).optional(),
                            "decoratedName": z.string().describe(
                              "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                            ).optional(),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                            ).default(-1),
                            "kind": z.string().describe(
                              "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A logical location of a construct that produced a result.",
                          ),
                        ).min(0).describe(
                          "The logical locations associated with the result.",
                        ).default([]),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "annotations": z.array(
                          z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ),
                        ).min(0).describe(
                          "A set of regions relevant to the location.",
                        ).default([]),
                        "relationships": z.array(
                          z.object({
                            "target": z.number().int().gte(0).describe(
                              "A reference to the related location.",
                            ),
                            "kinds": z.array(z.string()).describe(
                              "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                            ).default(["relevant"]),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Information about the relation of one location to another.",
                          ),
                        ).min(0).describe(
                          "An array of objects that describe relationships between this location and others.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A location within a programming artifact.",
                      ).optional(),
                      "module": z.string().describe(
                        "The name of the module that contains the code of this stack frame.",
                      ).optional(),
                      "threadId": z.number().int().describe(
                        "The thread identifier of the stack frame.",
                      ).optional(),
                      "parameters": z.array(z.string().default([])).min(0)
                        .describe(
                          "The parameters of the call that is executing.",
                        ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A function call within a stack trace.",
                    ),
                  ).min(0).describe(
                    "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A call stack that is relevant to a result.",
                ).optional(),
                "innerExceptions": z.array(z.any()).min(0).describe(
                  "An array of exception objects each of which is considered a cause of this exception.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Describes a runtime exception encountered during the execution of an analysis tool.",
              ).optional(),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "associatedRule": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Describes a condition relevant to the tool itself, as opposed to being relevant to a target being analyzed by the tool.",
            ),
          ).min(0).describe(
            "A list of runtime conditions detected by the tool during the analysis.",
          ).default([]),
          "toolConfigurationNotifications": z.array(
            z.object({
              "locations": z.array(
                z.object({
                  "id": z.number().int().gte(-1).describe(
                    "Value that distinguishes this location from all other locations within a single result object.",
                  ).default(-1),
                  "physicalLocation": z.object({
                    "address": z.object({
                      "absoluteAddress": z.number().int().gte(-1).describe(
                        "The address expressed as a byte offset from the start of the addressable region.",
                      ).default(-1),
                      "relativeAddress": z.number().int().describe(
                        "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                      ).optional(),
                      "length": z.number().int().describe(
                        "The number of bytes in this range of addresses.",
                      ).optional(),
                      "kind": z.string().describe(
                        "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                      ).optional(),
                      "name": z.string().describe(
                        "A name that is associated with the address, e.g., '.text'.",
                      ).optional(),
                      "fullyQualifiedName": z.string().describe(
                        "A human-readable fully qualified name that is associated with the address.",
                      ).optional(),
                      "offsetFromParent": z.number().int().describe(
                        "The byte offset of this address from the absolute or relative address of the parent object.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the cached object for this address.",
                      ).default(-1),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the parent object.",
                      ).default(-1),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                    ).optional(),
                    "artifactLocation": z.object({
                      "uri": z.string().describe(
                        "A string containing a valid relative or absolute URI.",
                      ).optional(),
                      "uriBaseId": z.string().describe(
                        'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the run artifacts array of the artifact object associated with the artifact location.",
                      ).default(-1),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Specifies the location of an artifact.",
                    ).optional(),
                    "region": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "contextRegion": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                  ).optional(),
                  "logicalLocations": z.array(
                    z.object({
                      "name": z.string().describe(
                        "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the logical locations array.",
                      ).default(-1),
                      "fullyQualifiedName": z.string().describe(
                        "The human-readable fully qualified name of the logical location.",
                      ).optional(),
                      "decoratedName": z.string().describe(
                        "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                      ).optional(),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                      ).default(-1),
                      "kind": z.string().describe(
                        "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A logical location of a construct that produced a result.",
                    ),
                  ).min(0).describe(
                    "The logical locations associated with the result.",
                  ).default([]),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "annotations": z.array(
                    z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ),
                  ).min(0).describe(
                    "A set of regions relevant to the location.",
                  ).default([]),
                  "relationships": z.array(
                    z.object({
                      "target": z.number().int().gte(0).describe(
                        "A reference to the related location.",
                      ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one location to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this location and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A location within a programming artifact.",
                ),
              ).min(0).describe("The locations relevant to this notification.")
                .default([]),
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ),
              "level": z.enum(["none", "note", "warning", "error"]).describe(
                "A value specifying the severity level of the notification.",
              ).default("warning"),
              "threadId": z.number().int().describe(
                "The thread identifier of the code that generated the notification.",
              ).optional(),
              "timeUtc": z.string().datetime({ offset: true }).describe(
                "The Coordinated Universal Time (UTC) date and time at which the analysis tool generated the notification.",
              ).optional(),
              "exception": z.object({
                "kind": z.string().describe(
                  "A string that identifies the kind of exception, for example, the fully qualified type name of an object that was thrown, or the symbolic name of a signal.",
                ).optional(),
                "message": z.string().describe(
                  "A message that describes the exception.",
                ).optional(),
                "stack": z.object({
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "frames": z.array(
                    z.object({
                      "location": z.object({
                        "id": z.number().int().gte(-1).describe(
                          "Value that distinguishes this location from all other locations within a single result object.",
                        ).default(-1),
                        "physicalLocation": z.object({
                          "address": z.object({
                            "absoluteAddress": z.number().int().gte(-1)
                              .describe(
                                "The address expressed as a byte offset from the start of the addressable region.",
                              ).default(-1),
                            "relativeAddress": z.number().int().describe(
                              "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                            ).optional(),
                            "length": z.number().int().describe(
                              "The number of bytes in this range of addresses.",
                            ).optional(),
                            "kind": z.string().describe(
                              "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                            ).optional(),
                            "name": z.string().describe(
                              "A name that is associated with the address, e.g., '.text'.",
                            ).optional(),
                            "fullyQualifiedName": z.string().describe(
                              "A human-readable fully qualified name that is associated with the address.",
                            ).optional(),
                            "offsetFromParent": z.number().int().describe(
                              "The byte offset of this address from the absolute or relative address of the parent object.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the cached object for this address.",
                            ).default(-1),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the parent object.",
                            ).default(-1),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                          ).optional(),
                          "artifactLocation": z.object({
                            "uri": z.string().describe(
                              "A string containing a valid relative or absolute URI.",
                            ).optional(),
                            "uriBaseId": z.string().describe(
                              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the run artifacts array of the artifact object associated with the artifact location.",
                            ).default(-1),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Specifies the location of an artifact.",
                          ).optional(),
                          "region": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "contextRegion": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                        ).optional(),
                        "logicalLocations": z.array(
                          z.object({
                            "name": z.string().describe(
                              "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the logical locations array.",
                            ).default(-1),
                            "fullyQualifiedName": z.string().describe(
                              "The human-readable fully qualified name of the logical location.",
                            ).optional(),
                            "decoratedName": z.string().describe(
                              "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                            ).optional(),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                            ).default(-1),
                            "kind": z.string().describe(
                              "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A logical location of a construct that produced a result.",
                          ),
                        ).min(0).describe(
                          "The logical locations associated with the result.",
                        ).default([]),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "annotations": z.array(
                          z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ),
                        ).min(0).describe(
                          "A set of regions relevant to the location.",
                        ).default([]),
                        "relationships": z.array(
                          z.object({
                            "target": z.number().int().gte(0).describe(
                              "A reference to the related location.",
                            ),
                            "kinds": z.array(z.string()).describe(
                              "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                            ).default(["relevant"]),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Information about the relation of one location to another.",
                          ),
                        ).min(0).describe(
                          "An array of objects that describe relationships between this location and others.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A location within a programming artifact.",
                      ).optional(),
                      "module": z.string().describe(
                        "The name of the module that contains the code of this stack frame.",
                      ).optional(),
                      "threadId": z.number().int().describe(
                        "The thread identifier of the stack frame.",
                      ).optional(),
                      "parameters": z.array(z.string().default([])).min(0)
                        .describe(
                          "The parameters of the call that is executing.",
                        ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A function call within a stack trace.",
                    ),
                  ).min(0).describe(
                    "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A call stack that is relevant to a result.",
                ).optional(),
                "innerExceptions": z.array(z.any()).min(0).describe(
                  "An array of exception objects each of which is considered a cause of this exception.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Describes a runtime exception encountered during the execution of an analysis tool.",
              ).optional(),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "associatedRule": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Describes a condition relevant to the tool itself, as opposed to being relevant to a target being analyzed by the tool.",
            ),
          ).min(0).describe(
            "A list of conditions detected by the tool that are relevant to the tool's configuration.",
          ).default([]),
          "exitCodeDescription": z.string().describe(
            "The reason for the process exit.",
          ).optional(),
          "exitSignalName": z.string().describe(
            "The name of the signal that caused the process to exit.",
          ).optional(),
          "exitSignalNumber": z.number().int().describe(
            "The numeric value of the signal that caused the process to exit.",
          ).optional(),
          "processStartFailureMessage": z.string().describe(
            "The reason given by the operating system that the process failed to start.",
          ).optional(),
          "executionSuccessful": z.boolean().describe(
            "Specifies whether the tool's execution completed successfully.",
          ),
          "machine": z.string().describe(
            "The machine that hosted the analysis tool run.",
          ).optional(),
          "account": z.string().describe(
            "The account that ran the analysis tool.",
          ).optional(),
          "processId": z.number().int().describe(
            "The process id for the analysis tool run.",
          ).optional(),
          "executableLocation": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "workingDirectory": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "environmentVariables": z.record(z.string()).describe(
            "The environment variables associated with the analysis tool process, expressed as key/value pairs.",
          ).optional(),
          "stdin": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "stdout": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "stderr": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "stdoutStderr": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "The runtime environment of the analysis tool run.",
        ).optional(),
        "analysisToolLogFiles": z.array(
          z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact."),
        ).min(0).describe(
          "The locations of the analysis tool's per-run log files.",
        ).default([]),
        "properties": z.object({
          "tags": z.array(z.string()).min(0).describe(
            "A set of distinct strings that provide additional information.",
          ).default([]),
        }).catchall(z.any()).describe(
          "Key/value pairs that provide additional information about the object.",
        ).optional(),
      }).strict().describe(
        "Describes how a converter transformed the output of a static analysis tool from the analysis tool's native output format into the SARIF format.",
      ).optional(),
      "language": z.string().regex(
        new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
      ).describe(
        "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase culture code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
      ).default("en-US"),
      "versionControlProvenance": z.array(
        z.object({
          "repositoryUri": z.string().url().describe(
            "The absolute URI of the repository.",
          ),
          "revisionId": z.string().describe(
            "A string that uniquely and permanently identifies the revision within the repository.",
          ).optional(),
          "branch": z.string().describe(
            "The name of a branch containing the revision.",
          ).optional(),
          "revisionTag": z.string().describe(
            "A tag that has been applied to the revision.",
          ).optional(),
          "asOfTimeUtc": z.string().datetime({ offset: true }).describe(
            "A Coordinated Universal Time (UTC) date and time that can be used to synchronize an enlistment to the state of the repository at that time.",
          ).optional(),
          "mappedTo": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "Specifies the information necessary to retrieve a desired revision from a version control system.",
        ),
      ).min(0).describe(
        "Specifies the revision in version control of the artifacts that were scanned.",
      ).default([]),
      "originalUriBaseIds": z.record(
        z.object({
          "uri": z.string().describe(
            "A string containing a valid relative or absolute URI.",
          ).optional(),
          "uriBaseId": z.string().describe(
            'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
          ).optional(),
          "index": z.number().int().gte(-1).describe(
            "The index within the run artifacts array of the artifact object associated with the artifact location.",
          ).default(-1),
          "description": z.object({
            "text": z.string().describe("A plain text message string.")
              .optional(),
            "markdown": z.string().describe("A Markdown message string.")
              .optional(),
            "id": z.string().describe("The identifier for this message.")
              .optional(),
            "arguments": z.array(z.string()).min(0).describe(
              "An array of strings to substitute into the message string.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Encapsulates a message intended to be read by the end user.",
          ).optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe("Specifies the location of an artifact."),
      ).describe(
        "The artifact location specified by each uriBaseId symbol on the machine where the tool originally ran.",
      ).optional(),
      "artifacts": z.array(
        z.object({
          "description": z.object({
            "text": z.string().describe("A plain text message string.")
              .optional(),
            "markdown": z.string().describe("A Markdown message string.")
              .optional(),
            "id": z.string().describe("The identifier for this message.")
              .optional(),
            "arguments": z.array(z.string()).min(0).describe(
              "An array of strings to substitute into the message string.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Encapsulates a message intended to be read by the end user.",
          ).optional(),
          "location": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "parentIndex": z.number().int().gte(-1).describe(
            "Identifies the index of the immediate parent of the artifact, if this artifact is nested.",
          ).default(-1),
          "offset": z.number().int().gte(0).describe(
            "The offset in bytes of the artifact within its containing artifact.",
          ).optional(),
          "length": z.number().int().gte(-1).describe(
            "The length of the artifact in bytes.",
          ).default(-1),
          "roles": z.array(
            z.enum([
              "analysisTarget",
              "attachment",
              "responseFile",
              "resultFile",
              "standardStream",
              "tracedFile",
              "unmodified",
              "modified",
              "added",
              "deleted",
              "renamed",
              "uncontrolled",
              "driver",
              "extension",
              "translation",
              "taxonomy",
              "policy",
              "referencedOnCommandLine",
              "memoryContents",
              "directory",
              "userSpecifiedConfiguration",
              "toolSpecifiedConfiguration",
              "debugOutputFile",
            ]),
          ).min(0).describe(
            "The role or roles played by the artifact in the analysis.",
          ).default([]),
          "mimeType": z.string().regex(new RegExp("[^/]+/.+")).describe(
            "The MIME type (RFC 2045) of the artifact.",
          ).optional(),
          "contents": z.object({
            "text": z.string().describe(
              "UTF-8-encoded content from a text artifact.",
            ).optional(),
            "binary": z.string().describe(
              "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
            ).optional(),
            "rendered": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Represents the contents of an artifact.")
            .optional(),
          "encoding": z.string().describe(
            "Specifies the encoding for an artifact object that refers to a text file.",
          ).optional(),
          "sourceLanguage": z.string().describe(
            "Specifies the source language for any artifact object that refers to a text file that contains source code.",
          ).optional(),
          "hashes": z.record(z.string()).describe(
            "A dictionary, each of whose keys is the name of a hash function and each of whose values is the hashed value of the artifact produced by the specified hash function.",
          ).optional(),
          "lastModifiedTimeUtc": z.string().datetime({ offset: true }).describe(
            'The Coordinated Universal Time (UTC) date and time at which the artifact was most recently modified. See "Date/time properties" in the SARIF spec for the required format.',
          ).optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A single artifact. In some cases, this artifact might be nested within another artifact.",
        ),
      ).min(0).describe("An array of artifact objects relevant to the run.")
        .optional(),
      "logicalLocations": z.array(
        z.object({
          "name": z.string().describe(
            "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
          ).optional(),
          "index": z.number().int().gte(-1).describe(
            "The index within the logical locations array.",
          ).default(-1),
          "fullyQualifiedName": z.string().describe(
            "The human-readable fully qualified name of the logical location.",
          ).optional(),
          "decoratedName": z.string().describe(
            "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
          ).optional(),
          "parentIndex": z.number().int().gte(-1).describe(
            "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
          ).default(-1),
          "kind": z.string().describe(
            "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
          ).optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A logical location of a construct that produced a result.",
        ),
      ).min(0).describe(
        "An array of logical locations such as namespaces, types or functions.",
      ).default([]),
      "graphs": z.array(
        z.object({
          "description": z.object({
            "text": z.string().describe("A plain text message string.")
              .optional(),
            "markdown": z.string().describe("A Markdown message string.")
              .optional(),
            "id": z.string().describe("The identifier for this message.")
              .optional(),
            "arguments": z.array(z.string()).min(0).describe(
              "An array of strings to substitute into the message string.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Encapsulates a message intended to be read by the end user.",
          ).optional(),
          "nodes": z.array(
            z.object({
              "id": z.string().describe(
                "A string that uniquely identifies the node within its graph.",
              ),
              "label": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "location": z.object({
                "id": z.number().int().gte(-1).describe(
                  "Value that distinguishes this location from all other locations within a single result object.",
                ).default(-1),
                "physicalLocation": z.object({
                  "address": z.object({
                    "absoluteAddress": z.number().int().gte(-1).describe(
                      "The address expressed as a byte offset from the start of the addressable region.",
                    ).default(-1),
                    "relativeAddress": z.number().int().describe(
                      "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                    ).optional(),
                    "length": z.number().int().describe(
                      "The number of bytes in this range of addresses.",
                    ).optional(),
                    "kind": z.string().describe(
                      "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                    ).optional(),
                    "name": z.string().describe(
                      "A name that is associated with the address, e.g., '.text'.",
                    ).optional(),
                    "fullyQualifiedName": z.string().describe(
                      "A human-readable fully qualified name that is associated with the address.",
                    ).optional(),
                    "offsetFromParent": z.number().int().describe(
                      "The byte offset of this address from the absolute or relative address of the parent object.",
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within run.addresses of the cached object for this address.",
                    ).default(-1),
                    "parentIndex": z.number().int().gte(-1).describe(
                      "The index within run.addresses of the parent object.",
                    ).default(-1),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                  ).optional(),
                  "artifactLocation": z.object({
                    "uri": z.string().describe(
                      "A string containing a valid relative or absolute URI.",
                    ).optional(),
                    "uriBaseId": z.string().describe(
                      'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within the run artifacts array of the artifact object associated with the artifact location.",
                    ).default(-1),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe("Specifies the location of an artifact.")
                    .optional(),
                  "region": z.object({
                    "startLine": z.number().int().gte(1).describe(
                      "The line number of the first character in the region.",
                    ).optional(),
                    "startColumn": z.number().int().gte(1).describe(
                      "The column number of the first character in the region.",
                    ).optional(),
                    "endLine": z.number().int().gte(1).describe(
                      "The line number of the last character in the region.",
                    ).optional(),
                    "endColumn": z.number().int().gte(1).describe(
                      "The column number of the character following the end of the region.",
                    ).optional(),
                    "charOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                    ).default(-1),
                    "charLength": z.number().int().gte(0).describe(
                      "The length of the region in characters.",
                    ).optional(),
                    "byteOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                    ).default(-1),
                    "byteLength": z.number().int().gte(0).describe(
                      "The length of the region in bytes.",
                    ).optional(),
                    "snippet": z.object({
                      "text": z.string().describe(
                        "UTF-8-encoded content from a text artifact.",
                      ).optional(),
                      "binary": z.string().describe(
                        "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                      ).optional(),
                      "rendered": z.object({
                        "text": z.string().describe(
                          "A plain text message string or format string.",
                        ),
                        "markdown": z.string().describe(
                          "A Markdown message string or format string.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A message string or message format string rendered in multiple formats.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Represents the contents of an artifact.",
                    ).optional(),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "sourceLanguage": z.string().describe(
                      "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A region within an artifact where a result was detected.",
                  ).optional(),
                  "contextRegion": z.object({
                    "startLine": z.number().int().gte(1).describe(
                      "The line number of the first character in the region.",
                    ).optional(),
                    "startColumn": z.number().int().gte(1).describe(
                      "The column number of the first character in the region.",
                    ).optional(),
                    "endLine": z.number().int().gte(1).describe(
                      "The line number of the last character in the region.",
                    ).optional(),
                    "endColumn": z.number().int().gte(1).describe(
                      "The column number of the character following the end of the region.",
                    ).optional(),
                    "charOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                    ).default(-1),
                    "charLength": z.number().int().gte(0).describe(
                      "The length of the region in characters.",
                    ).optional(),
                    "byteOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                    ).default(-1),
                    "byteLength": z.number().int().gte(0).describe(
                      "The length of the region in bytes.",
                    ).optional(),
                    "snippet": z.object({
                      "text": z.string().describe(
                        "UTF-8-encoded content from a text artifact.",
                      ).optional(),
                      "binary": z.string().describe(
                        "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                      ).optional(),
                      "rendered": z.object({
                        "text": z.string().describe(
                          "A plain text message string or format string.",
                        ),
                        "markdown": z.string().describe(
                          "A Markdown message string or format string.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A message string or message format string rendered in multiple formats.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Represents the contents of an artifact.",
                    ).optional(),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "sourceLanguage": z.string().describe(
                      "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A region within an artifact where a result was detected.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                ).optional(),
                "logicalLocations": z.array(
                  z.object({
                    "name": z.string().describe(
                      "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within the logical locations array.",
                    ).default(-1),
                    "fullyQualifiedName": z.string().describe(
                      "The human-readable fully qualified name of the logical location.",
                    ).optional(),
                    "decoratedName": z.string().describe(
                      "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                    ).optional(),
                    "parentIndex": z.number().int().gte(-1).describe(
                      "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                    ).default(-1),
                    "kind": z.string().describe(
                      "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A logical location of a construct that produced a result.",
                  ),
                ).min(0).describe(
                  "The logical locations associated with the result.",
                ).default([]),
                "message": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "annotations": z.array(
                  z.object({
                    "startLine": z.number().int().gte(1).describe(
                      "The line number of the first character in the region.",
                    ).optional(),
                    "startColumn": z.number().int().gte(1).describe(
                      "The column number of the first character in the region.",
                    ).optional(),
                    "endLine": z.number().int().gte(1).describe(
                      "The line number of the last character in the region.",
                    ).optional(),
                    "endColumn": z.number().int().gte(1).describe(
                      "The column number of the character following the end of the region.",
                    ).optional(),
                    "charOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                    ).default(-1),
                    "charLength": z.number().int().gte(0).describe(
                      "The length of the region in characters.",
                    ).optional(),
                    "byteOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                    ).default(-1),
                    "byteLength": z.number().int().gte(0).describe(
                      "The length of the region in bytes.",
                    ).optional(),
                    "snippet": z.object({
                      "text": z.string().describe(
                        "UTF-8-encoded content from a text artifact.",
                      ).optional(),
                      "binary": z.string().describe(
                        "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                      ).optional(),
                      "rendered": z.object({
                        "text": z.string().describe(
                          "A plain text message string or format string.",
                        ),
                        "markdown": z.string().describe(
                          "A Markdown message string or format string.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A message string or message format string rendered in multiple formats.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Represents the contents of an artifact.",
                    ).optional(),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "sourceLanguage": z.string().describe(
                      "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A region within an artifact where a result was detected.",
                  ),
                ).min(0).describe("A set of regions relevant to the location.")
                  .default([]),
                "relationships": z.array(
                  z.object({
                    "target": z.number().int().gte(0).describe(
                      "A reference to the related location.",
                    ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one location to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this location and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("A location within a programming artifact.")
                .optional(),
              "children": z.array(z.any()).min(0).describe(
                "Array of child nodes.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Represents a node in a graph."),
          ).min(0).describe(
            "An array of node objects representing the nodes of the graph.",
          ).default([]),
          "edges": z.array(
            z.object({
              "id": z.string().describe(
                "A string that uniquely identifies the edge within its graph.",
              ),
              "label": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "sourceNodeId": z.string().describe(
                "Identifies the source node (the node at which the edge starts).",
              ),
              "targetNodeId": z.string().describe(
                "Identifies the target node (the node at which the edge ends).",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Represents a directed edge in a graph."),
          ).min(0).describe(
            "An array of edge objects representing the edges of the graph.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A network of nodes and directed edges that describes some aspect of the structure of the code (for example, a call graph).",
        ),
      ).min(0).describe(
        "An array of zero or more unique graph objects associated with the run.",
      ).default([]),
      "results": z.array(
        z.object({
          "ruleId": z.string().describe(
            "The stable, unique identifier of the rule, if any, to which this notification is relevant. This member can be used to retrieve rule metadata from the rules dictionary, if it exists.",
          ).optional(),
          "ruleIndex": z.number().int().gte(-1).describe(
            "The index within the tool component rules array of the rule object associated with this result.",
          ).default(-1),
          "rule": z.object({
            "id": z.string().describe("The id of the descriptor.").optional(),
            "index": z.number().int().gte(-1).describe(
              "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
            ).default(-1),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe("A guid that uniquely identifies the descriptor.")
              .optional(),
            "toolComponent": z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
            "Information about how to locate a relevant reporting descriptor.",
          ).optional(),
          "kind": z.enum([
            "notApplicable",
            "pass",
            "fail",
            "review",
            "open",
            "informational",
          ]).describe("A value that categorizes results by evaluation state.")
            .default("fail"),
          "level": z.enum(["none", "note", "warning", "error"]).describe(
            "A value specifying the severity level of the result.",
          ).default("warning"),
          "message": z.object({
            "text": z.string().describe("A plain text message string.")
              .optional(),
            "markdown": z.string().describe("A Markdown message string.")
              .optional(),
            "id": z.string().describe("The identifier for this message.")
              .optional(),
            "arguments": z.array(z.string()).min(0).describe(
              "An array of strings to substitute into the message string.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Encapsulates a message intended to be read by the end user.",
          ),
          "analysisTarget": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "locations": z.array(
            z.object({
              "id": z.number().int().gte(-1).describe(
                "Value that distinguishes this location from all other locations within a single result object.",
              ).default(-1),
              "physicalLocation": z.object({
                "address": z.object({
                  "absoluteAddress": z.number().int().gte(-1).describe(
                    "The address expressed as a byte offset from the start of the addressable region.",
                  ).default(-1),
                  "relativeAddress": z.number().int().describe(
                    "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                  ).optional(),
                  "length": z.number().int().describe(
                    "The number of bytes in this range of addresses.",
                  ).optional(),
                  "kind": z.string().describe(
                    "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                  ).optional(),
                  "name": z.string().describe(
                    "A name that is associated with the address, e.g., '.text'.",
                  ).optional(),
                  "fullyQualifiedName": z.string().describe(
                    "A human-readable fully qualified name that is associated with the address.",
                  ).optional(),
                  "offsetFromParent": z.number().int().describe(
                    "The byte offset of this address from the absolute or relative address of the parent object.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within run.addresses of the cached object for this address.",
                  ).default(-1),
                  "parentIndex": z.number().int().gte(-1).describe(
                    "The index within run.addresses of the parent object.",
                  ).default(-1),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                ).optional(),
                "artifactLocation": z.object({
                  "uri": z.string().describe(
                    "A string containing a valid relative or absolute URI.",
                  ).optional(),
                  "uriBaseId": z.string().describe(
                    'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within the run artifacts array of the artifact object associated with the artifact location.",
                  ).default(-1),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Specifies the location of an artifact.")
                  .optional(),
                "region": z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ).optional(),
                "contextRegion": z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
              ).optional(),
              "logicalLocations": z.array(
                z.object({
                  "name": z.string().describe(
                    "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within the logical locations array.",
                  ).default(-1),
                  "fullyQualifiedName": z.string().describe(
                    "The human-readable fully qualified name of the logical location.",
                  ).optional(),
                  "decoratedName": z.string().describe(
                    "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                  ).optional(),
                  "parentIndex": z.number().int().gte(-1).describe(
                    "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                  ).default(-1),
                  "kind": z.string().describe(
                    "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A logical location of a construct that produced a result.",
                ),
              ).min(0).describe(
                "The logical locations associated with the result.",
              ).default([]),
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "annotations": z.array(
                z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ),
              ).min(0).describe("A set of regions relevant to the location.")
                .default([]),
              "relationships": z.array(
                z.object({
                  "target": z.number().int().gte(0).describe(
                    "A reference to the related location.",
                  ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one location to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this location and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("A location within a programming artifact."),
          ).min(0).describe(
            "The set of locations where the result was detected. Specify only one location unless the problem indicated by the result can only be corrected by making a change at every specified location.",
          ).default([]),
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A stable, unique identifier for the result in the form of a GUID.",
          ).optional(),
          "correlationGuid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A stable, unique identifier for the equivalence class of logically identical results to which this result belongs, in the form of a GUID.",
          ).optional(),
          "occurrenceCount": z.number().int().gte(1).describe(
            "A positive integer specifying the number of times this logically unique result was observed in this run.",
          ).optional(),
          "partialFingerprints": z.record(z.string()).describe(
            "A set of strings that contribute to the stable, unique identity of the result.",
          ).optional(),
          "fingerprints": z.record(z.string()).describe(
            "A set of strings each of which individually defines a stable, unique identity for the result.",
          ).optional(),
          "stacks": z.array(
            z.object({
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "frames": z.array(
                z.object({
                  "location": z.object({
                    "id": z.number().int().gte(-1).describe(
                      "Value that distinguishes this location from all other locations within a single result object.",
                    ).default(-1),
                    "physicalLocation": z.object({
                      "address": z.object({
                        "absoluteAddress": z.number().int().gte(-1).describe(
                          "The address expressed as a byte offset from the start of the addressable region.",
                        ).default(-1),
                        "relativeAddress": z.number().int().describe(
                          "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                        ).optional(),
                        "length": z.number().int().describe(
                          "The number of bytes in this range of addresses.",
                        ).optional(),
                        "kind": z.string().describe(
                          "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                        ).optional(),
                        "name": z.string().describe(
                          "A name that is associated with the address, e.g., '.text'.",
                        ).optional(),
                        "fullyQualifiedName": z.string().describe(
                          "A human-readable fully qualified name that is associated with the address.",
                        ).optional(),
                        "offsetFromParent": z.number().int().describe(
                          "The byte offset of this address from the absolute or relative address of the parent object.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index within run.addresses of the cached object for this address.",
                        ).default(-1),
                        "parentIndex": z.number().int().gte(-1).describe(
                          "The index within run.addresses of the parent object.",
                        ).default(-1),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                      ).optional(),
                      "artifactLocation": z.object({
                        "uri": z.string().describe(
                          "A string containing a valid relative or absolute URI.",
                        ).optional(),
                        "uriBaseId": z.string().describe(
                          'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index within the run artifacts array of the artifact object associated with the artifact location.",
                        ).default(-1),
                        "description": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Specifies the location of an artifact.",
                      ).optional(),
                      "region": z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ).optional(),
                      "contextRegion": z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                    ).optional(),
                    "logicalLocations": z.array(
                      z.object({
                        "name": z.string().describe(
                          "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index within the logical locations array.",
                        ).default(-1),
                        "fullyQualifiedName": z.string().describe(
                          "The human-readable fully qualified name of the logical location.",
                        ).optional(),
                        "decoratedName": z.string().describe(
                          "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                        ).optional(),
                        "parentIndex": z.number().int().gte(-1).describe(
                          "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                        ).default(-1),
                        "kind": z.string().describe(
                          "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A logical location of a construct that produced a result.",
                      ),
                    ).min(0).describe(
                      "The logical locations associated with the result.",
                    ).default([]),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "annotations": z.array(
                      z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ),
                    ).min(0).describe(
                      "A set of regions relevant to the location.",
                    ).default([]),
                    "relationships": z.array(
                      z.object({
                        "target": z.number().int().gte(0).describe(
                          "A reference to the related location.",
                        ),
                        "kinds": z.array(z.string()).describe(
                          "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                        ).default(["relevant"]),
                        "description": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Information about the relation of one location to another.",
                      ),
                    ).min(0).describe(
                      "An array of objects that describe relationships between this location and others.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A location within a programming artifact.",
                  ).optional(),
                  "module": z.string().describe(
                    "The name of the module that contains the code of this stack frame.",
                  ).optional(),
                  "threadId": z.number().int().describe(
                    "The thread identifier of the stack frame.",
                  ).optional(),
                  "parameters": z.array(z.string().default([])).min(0).describe(
                    "The parameters of the call that is executing.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("A function call within a stack trace."),
              ).min(0).describe(
                "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("A call stack that is relevant to a result."),
          ).min(0).describe(
            "An array of 'stack' objects relevant to the result.",
          ).default([]),
          "codeFlows": z.array(
            z.object({
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "threadFlows": z.array(
                z.object({
                  "id": z.string().describe(
                    "An string that uniquely identifies the threadFlow within the codeFlow in which it occurs.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "initialState": z.record(
                    z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ),
                  ).describe(
                    "Values of relevant expressions at the start of the thread flow that may change during thread flow execution.",
                  ).optional(),
                  "immutableState": z.record(
                    z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ),
                  ).describe(
                    "Values of relevant expressions at the start of the thread flow that remain constant.",
                  ).optional(),
                  "locations": z.array(
                    z.object({
                      "index": z.number().int().gte(-1).describe(
                        "The index within the run threadFlowLocations array.",
                      ).default(-1),
                      "location": z.object({
                        "id": z.number().int().gte(-1).describe(
                          "Value that distinguishes this location from all other locations within a single result object.",
                        ).default(-1),
                        "physicalLocation": z.object({
                          "address": z.object({
                            "absoluteAddress": z.number().int().gte(-1)
                              .describe(
                                "The address expressed as a byte offset from the start of the addressable region.",
                              ).default(-1),
                            "relativeAddress": z.number().int().describe(
                              "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                            ).optional(),
                            "length": z.number().int().describe(
                              "The number of bytes in this range of addresses.",
                            ).optional(),
                            "kind": z.string().describe(
                              "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                            ).optional(),
                            "name": z.string().describe(
                              "A name that is associated with the address, e.g., '.text'.",
                            ).optional(),
                            "fullyQualifiedName": z.string().describe(
                              "A human-readable fully qualified name that is associated with the address.",
                            ).optional(),
                            "offsetFromParent": z.number().int().describe(
                              "The byte offset of this address from the absolute or relative address of the parent object.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the cached object for this address.",
                            ).default(-1),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the parent object.",
                            ).default(-1),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                          ).optional(),
                          "artifactLocation": z.object({
                            "uri": z.string().describe(
                              "A string containing a valid relative or absolute URI.",
                            ).optional(),
                            "uriBaseId": z.string().describe(
                              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the run artifacts array of the artifact object associated with the artifact location.",
                            ).default(-1),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Specifies the location of an artifact.",
                          ).optional(),
                          "region": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "contextRegion": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                        ).optional(),
                        "logicalLocations": z.array(
                          z.object({
                            "name": z.string().describe(
                              "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the logical locations array.",
                            ).default(-1),
                            "fullyQualifiedName": z.string().describe(
                              "The human-readable fully qualified name of the logical location.",
                            ).optional(),
                            "decoratedName": z.string().describe(
                              "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                            ).optional(),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                            ).default(-1),
                            "kind": z.string().describe(
                              "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A logical location of a construct that produced a result.",
                          ),
                        ).min(0).describe(
                          "The logical locations associated with the result.",
                        ).default([]),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "annotations": z.array(
                          z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ),
                        ).min(0).describe(
                          "A set of regions relevant to the location.",
                        ).default([]),
                        "relationships": z.array(
                          z.object({
                            "target": z.number().int().gte(0).describe(
                              "A reference to the related location.",
                            ),
                            "kinds": z.array(z.string()).describe(
                              "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                            ).default(["relevant"]),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Information about the relation of one location to another.",
                          ),
                        ).min(0).describe(
                          "An array of objects that describe relationships between this location and others.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A location within a programming artifact.",
                      ).optional(),
                      "stack": z.object({
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "frames": z.array(
                          z.object({
                            "location": z.object({
                              "id": z.number().int().gte(-1).describe(
                                "Value that distinguishes this location from all other locations within a single result object.",
                              ).default(-1),
                              "physicalLocation": z.object({
                                "address": z.object({
                                  "absoluteAddress": z.number().int().gte(-1)
                                    .describe(
                                      "The address expressed as a byte offset from the start of the addressable region.",
                                    ).default(-1),
                                  "relativeAddress": z.number().int().describe(
                                    "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                                  ).optional(),
                                  "length": z.number().int().describe(
                                    "The number of bytes in this range of addresses.",
                                  ).optional(),
                                  "kind": z.string().describe(
                                    "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                                  ).optional(),
                                  "name": z.string().describe(
                                    "A name that is associated with the address, e.g., '.text'.",
                                  ).optional(),
                                  "fullyQualifiedName": z.string().describe(
                                    "A human-readable fully qualified name that is associated with the address.",
                                  ).optional(),
                                  "offsetFromParent": z.number().int().describe(
                                    "The byte offset of this address from the absolute or relative address of the parent object.",
                                  ).optional(),
                                  "index": z.number().int().gte(-1).describe(
                                    "The index within run.addresses of the cached object for this address.",
                                  ).default(-1),
                                  "parentIndex": z.number().int().gte(-1)
                                    .describe(
                                      "The index within run.addresses of the parent object.",
                                    ).default(-1),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                                ).optional(),
                                "artifactLocation": z.object({
                                  "uri": z.string().describe(
                                    "A string containing a valid relative or absolute URI.",
                                  ).optional(),
                                  "uriBaseId": z.string().describe(
                                    'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                                  ).optional(),
                                  "index": z.number().int().gte(-1).describe(
                                    "The index within the run artifacts array of the artifact object associated with the artifact location.",
                                  ).default(-1),
                                  "description": z.object({
                                    "text": z.string().describe(
                                      "A plain text message string.",
                                    ).optional(),
                                    "markdown": z.string().describe(
                                      "A Markdown message string.",
                                    ).optional(),
                                    "id": z.string().describe(
                                      "The identifier for this message.",
                                    ).optional(),
                                    "arguments": z.array(z.string()).min(0)
                                      .describe(
                                        "An array of strings to substitute into the message string.",
                                      ).default([]),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().and(z.union([z.any(), z.any()]))
                                    .describe(
                                      "Encapsulates a message intended to be read by the end user.",
                                    ).optional(),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "Specifies the location of an artifact.",
                                ).optional(),
                                "region": z.object({
                                  "startLine": z.number().int().gte(1).describe(
                                    "The line number of the first character in the region.",
                                  ).optional(),
                                  "startColumn": z.number().int().gte(1)
                                    .describe(
                                      "The column number of the first character in the region.",
                                    ).optional(),
                                  "endLine": z.number().int().gte(1).describe(
                                    "The line number of the last character in the region.",
                                  ).optional(),
                                  "endColumn": z.number().int().gte(1).describe(
                                    "The column number of the character following the end of the region.",
                                  ).optional(),
                                  "charOffset": z.number().int().gte(-1)
                                    .describe(
                                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                                    ).default(-1),
                                  "charLength": z.number().int().gte(0)
                                    .describe(
                                      "The length of the region in characters.",
                                    ).optional(),
                                  "byteOffset": z.number().int().gte(-1)
                                    .describe(
                                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                                    ).default(-1),
                                  "byteLength": z.number().int().gte(0)
                                    .describe(
                                      "The length of the region in bytes.",
                                    ).optional(),
                                  "snippet": z.object({
                                    "text": z.string().describe(
                                      "UTF-8-encoded content from a text artifact.",
                                    ).optional(),
                                    "binary": z.string().describe(
                                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                                    ).optional(),
                                    "rendered": z.object({
                                      "text": z.string().describe(
                                        "A plain text message string or format string.",
                                      ),
                                      "markdown": z.string().describe(
                                        "A Markdown message string or format string.",
                                      ).optional(),
                                      "properties": z.object({
                                        "tags": z.array(z.string()).min(0)
                                          .describe(
                                            "A set of distinct strings that provide additional information.",
                                          ).default([]),
                                      }).catchall(z.any()).describe(
                                        "Key/value pairs that provide additional information about the object.",
                                      ).optional(),
                                    }).strict().describe(
                                      "A message string or message format string rendered in multiple formats.",
                                    ).optional(),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().describe(
                                    "Represents the contents of an artifact.",
                                  ).optional(),
                                  "message": z.object({
                                    "text": z.string().describe(
                                      "A plain text message string.",
                                    ).optional(),
                                    "markdown": z.string().describe(
                                      "A Markdown message string.",
                                    ).optional(),
                                    "id": z.string().describe(
                                      "The identifier for this message.",
                                    ).optional(),
                                    "arguments": z.array(z.string()).min(0)
                                      .describe(
                                        "An array of strings to substitute into the message string.",
                                      ).default([]),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().and(z.union([z.any(), z.any()]))
                                    .describe(
                                      "Encapsulates a message intended to be read by the end user.",
                                    ).optional(),
                                  "sourceLanguage": z.string().describe(
                                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                                  ).optional(),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "A region within an artifact where a result was detected.",
                                ).optional(),
                                "contextRegion": z.object({
                                  "startLine": z.number().int().gte(1).describe(
                                    "The line number of the first character in the region.",
                                  ).optional(),
                                  "startColumn": z.number().int().gte(1)
                                    .describe(
                                      "The column number of the first character in the region.",
                                    ).optional(),
                                  "endLine": z.number().int().gte(1).describe(
                                    "The line number of the last character in the region.",
                                  ).optional(),
                                  "endColumn": z.number().int().gte(1).describe(
                                    "The column number of the character following the end of the region.",
                                  ).optional(),
                                  "charOffset": z.number().int().gte(-1)
                                    .describe(
                                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                                    ).default(-1),
                                  "charLength": z.number().int().gte(0)
                                    .describe(
                                      "The length of the region in characters.",
                                    ).optional(),
                                  "byteOffset": z.number().int().gte(-1)
                                    .describe(
                                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                                    ).default(-1),
                                  "byteLength": z.number().int().gte(0)
                                    .describe(
                                      "The length of the region in bytes.",
                                    ).optional(),
                                  "snippet": z.object({
                                    "text": z.string().describe(
                                      "UTF-8-encoded content from a text artifact.",
                                    ).optional(),
                                    "binary": z.string().describe(
                                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                                    ).optional(),
                                    "rendered": z.object({
                                      "text": z.string().describe(
                                        "A plain text message string or format string.",
                                      ),
                                      "markdown": z.string().describe(
                                        "A Markdown message string or format string.",
                                      ).optional(),
                                      "properties": z.object({
                                        "tags": z.array(z.string()).min(0)
                                          .describe(
                                            "A set of distinct strings that provide additional information.",
                                          ).default([]),
                                      }).catchall(z.any()).describe(
                                        "Key/value pairs that provide additional information about the object.",
                                      ).optional(),
                                    }).strict().describe(
                                      "A message string or message format string rendered in multiple formats.",
                                    ).optional(),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().describe(
                                    "Represents the contents of an artifact.",
                                  ).optional(),
                                  "message": z.object({
                                    "text": z.string().describe(
                                      "A plain text message string.",
                                    ).optional(),
                                    "markdown": z.string().describe(
                                      "A Markdown message string.",
                                    ).optional(),
                                    "id": z.string().describe(
                                      "The identifier for this message.",
                                    ).optional(),
                                    "arguments": z.array(z.string()).min(0)
                                      .describe(
                                        "An array of strings to substitute into the message string.",
                                      ).default([]),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().and(z.union([z.any(), z.any()]))
                                    .describe(
                                      "Encapsulates a message intended to be read by the end user.",
                                    ).optional(),
                                  "sourceLanguage": z.string().describe(
                                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                                  ).optional(),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "A region within an artifact where a result was detected.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().and(z.union([z.any(), z.any()]))
                                .describe(
                                  "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                                ).optional(),
                              "logicalLocations": z.array(
                                z.object({
                                  "name": z.string().describe(
                                    "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                                  ).optional(),
                                  "index": z.number().int().gte(-1).describe(
                                    "The index within the logical locations array.",
                                  ).default(-1),
                                  "fullyQualifiedName": z.string().describe(
                                    "The human-readable fully qualified name of the logical location.",
                                  ).optional(),
                                  "decoratedName": z.string().describe(
                                    "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                                  ).optional(),
                                  "parentIndex": z.number().int().gte(-1)
                                    .describe(
                                      "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                                    ).default(-1),
                                  "kind": z.string().describe(
                                    "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                                  ).optional(),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "A logical location of a construct that produced a result.",
                                ),
                              ).min(0).describe(
                                "The logical locations associated with the result.",
                              ).default([]),
                              "message": z.object({
                                "text": z.string().describe(
                                  "A plain text message string.",
                                ).optional(),
                                "markdown": z.string().describe(
                                  "A Markdown message string.",
                                ).optional(),
                                "id": z.string().describe(
                                  "The identifier for this message.",
                                ).optional(),
                                "arguments": z.array(z.string()).min(0)
                                  .describe(
                                    "An array of strings to substitute into the message string.",
                                  ).default([]),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().and(z.union([z.any(), z.any()]))
                                .describe(
                                  "Encapsulates a message intended to be read by the end user.",
                                ).optional(),
                              "annotations": z.array(
                                z.object({
                                  "startLine": z.number().int().gte(1).describe(
                                    "The line number of the first character in the region.",
                                  ).optional(),
                                  "startColumn": z.number().int().gte(1)
                                    .describe(
                                      "The column number of the first character in the region.",
                                    ).optional(),
                                  "endLine": z.number().int().gte(1).describe(
                                    "The line number of the last character in the region.",
                                  ).optional(),
                                  "endColumn": z.number().int().gte(1).describe(
                                    "The column number of the character following the end of the region.",
                                  ).optional(),
                                  "charOffset": z.number().int().gte(-1)
                                    .describe(
                                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                                    ).default(-1),
                                  "charLength": z.number().int().gte(0)
                                    .describe(
                                      "The length of the region in characters.",
                                    ).optional(),
                                  "byteOffset": z.number().int().gte(-1)
                                    .describe(
                                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                                    ).default(-1),
                                  "byteLength": z.number().int().gte(0)
                                    .describe(
                                      "The length of the region in bytes.",
                                    ).optional(),
                                  "snippet": z.object({
                                    "text": z.string().describe(
                                      "UTF-8-encoded content from a text artifact.",
                                    ).optional(),
                                    "binary": z.string().describe(
                                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                                    ).optional(),
                                    "rendered": z.object({
                                      "text": z.string().describe(
                                        "A plain text message string or format string.",
                                      ),
                                      "markdown": z.string().describe(
                                        "A Markdown message string or format string.",
                                      ).optional(),
                                      "properties": z.object({
                                        "tags": z.array(z.string()).min(0)
                                          .describe(
                                            "A set of distinct strings that provide additional information.",
                                          ).default([]),
                                      }).catchall(z.any()).describe(
                                        "Key/value pairs that provide additional information about the object.",
                                      ).optional(),
                                    }).strict().describe(
                                      "A message string or message format string rendered in multiple formats.",
                                    ).optional(),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().describe(
                                    "Represents the contents of an artifact.",
                                  ).optional(),
                                  "message": z.object({
                                    "text": z.string().describe(
                                      "A plain text message string.",
                                    ).optional(),
                                    "markdown": z.string().describe(
                                      "A Markdown message string.",
                                    ).optional(),
                                    "id": z.string().describe(
                                      "The identifier for this message.",
                                    ).optional(),
                                    "arguments": z.array(z.string()).min(0)
                                      .describe(
                                        "An array of strings to substitute into the message string.",
                                      ).default([]),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().and(z.union([z.any(), z.any()]))
                                    .describe(
                                      "Encapsulates a message intended to be read by the end user.",
                                    ).optional(),
                                  "sourceLanguage": z.string().describe(
                                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                                  ).optional(),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "A region within an artifact where a result was detected.",
                                ),
                              ).min(0).describe(
                                "A set of regions relevant to the location.",
                              ).default([]),
                              "relationships": z.array(
                                z.object({
                                  "target": z.number().int().gte(0).describe(
                                    "A reference to the related location.",
                                  ),
                                  "kinds": z.array(z.string()).describe(
                                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                                  ).default(["relevant"]),
                                  "description": z.object({
                                    "text": z.string().describe(
                                      "A plain text message string.",
                                    ).optional(),
                                    "markdown": z.string().describe(
                                      "A Markdown message string.",
                                    ).optional(),
                                    "id": z.string().describe(
                                      "The identifier for this message.",
                                    ).optional(),
                                    "arguments": z.array(z.string()).min(0)
                                      .describe(
                                        "An array of strings to substitute into the message string.",
                                      ).default([]),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().and(z.union([z.any(), z.any()]))
                                    .describe(
                                      "Encapsulates a message intended to be read by the end user.",
                                    ).optional(),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "Information about the relation of one location to another.",
                                ),
                              ).min(0).describe(
                                "An array of objects that describe relationships between this location and others.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "A location within a programming artifact.",
                            ).optional(),
                            "module": z.string().describe(
                              "The name of the module that contains the code of this stack frame.",
                            ).optional(),
                            "threadId": z.number().int().describe(
                              "The thread identifier of the stack frame.",
                            ).optional(),
                            "parameters": z.array(z.string().default([])).min(0)
                              .describe(
                                "The parameters of the call that is executing.",
                              ).default([]),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A function call within a stack trace.",
                          ),
                        ).min(0).describe(
                          "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
                        ),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A call stack that is relevant to a result.",
                      ).optional(),
                      "kinds": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that categorize the thread flow location. Well-known kinds include 'acquire', 'release', 'enter', 'exit', 'call', 'return', 'branch', 'implicit', 'false', 'true', 'caution', 'danger', 'unknown', 'unreachable', 'taint', 'function', 'handler', 'lock', 'memory', 'resource', 'scope' and 'value'.",
                      ).default([]),
                      "taxa": z.array(
                        z.object({
                          "id": z.string().describe("The id of the descriptor.")
                            .optional(),
                          "index": z.number().int().gte(-1).describe(
                            "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                          ).default(-1),
                          "guid": z.string().regex(
                            new RegExp(
                              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                            ),
                          ).describe(
                            "A guid that uniquely identifies the descriptor.",
                          ).optional(),
                          "toolComponent": z.object({
                            "name": z.string().describe(
                              "The 'name' property of the referenced toolComponent.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "An index into the referenced toolComponent in tool.extensions.",
                            ).default(-1),
                            "guid": z.string().regex(
                              new RegExp(
                                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                              ),
                            ).describe(
                              "The 'guid' property of the referenced toolComponent.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Identifies a particular toolComponent object, either the driver or an extension.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any(), z.any()]))
                          .describe(
                            "Information about how to locate a relevant reporting descriptor.",
                          ),
                      ).min(0).describe(
                        "An array of references to rule or taxonomy reporting descriptors that are applicable to the thread flow location.",
                      ).default([]),
                      "module": z.string().describe(
                        "The name of the module that contains the code that is executing.",
                      ).optional(),
                      "state": z.record(
                        z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ),
                      ).describe(
                        "A dictionary, each of whose keys specifies a variable or expression, the associated value of which represents the variable or expression value. For an annotation of kind 'continuation', for example, this dictionary might hold the current assumed values of a set of global variables.",
                      ).optional(),
                      "nestingLevel": z.number().int().gte(0).describe(
                        "An integer representing a containment hierarchy within the thread flow.",
                      ).optional(),
                      "executionOrder": z.number().int().gte(-1).describe(
                        "An integer representing the temporal order in which execution reached this location.",
                      ).default(-1),
                      "executionTimeUtc": z.string().datetime({ offset: true })
                        .describe(
                          "The Coordinated Universal Time (UTC) date and time at which this location was executed.",
                        ).optional(),
                      "importance": z.enum([
                        "important",
                        "essential",
                        "unimportant",
                      ]).describe(
                        'Specifies the importance of this location in understanding the code flow in which it occurs. The order from most to least important is "essential", "important", "unimportant". Default: "important".',
                      ).default("important"),
                      "webRequest": z.object({
                        "index": z.number().int().gte(-1).describe(
                          "The index within the run.webRequests array of the request object associated with this result.",
                        ).default(-1),
                        "protocol": z.string().describe(
                          "The request protocol. Example: 'http'.",
                        ).optional(),
                        "version": z.string().describe(
                          "The request version. Example: '1.1'.",
                        ).optional(),
                        "target": z.string().describe(
                          "The target of the request.",
                        ).optional(),
                        "method": z.string().describe(
                          "The HTTP method. Well-known values are 'GET', 'PUT', 'POST', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'.",
                        ).optional(),
                        "headers": z.record(z.string()).describe(
                          "The request headers.",
                        ).optional(),
                        "parameters": z.record(z.string()).describe(
                          "The request parameters.",
                        ).optional(),
                        "body": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe("Describes an HTTP request.")
                        .optional(),
                      "webResponse": z.object({
                        "index": z.number().int().gte(-1).describe(
                          "The index within the run.webResponses array of the response object associated with this result.",
                        ).default(-1),
                        "protocol": z.string().describe(
                          "The response protocol. Example: 'http'.",
                        ).optional(),
                        "version": z.string().describe(
                          "The response version. Example: '1.1'.",
                        ).optional(),
                        "statusCode": z.number().int().describe(
                          "The response status code. Example: 451.",
                        ).optional(),
                        "reasonPhrase": z.string().describe(
                          "The response reason. Example: 'Not found'.",
                        ).optional(),
                        "headers": z.record(z.string()).describe(
                          "The response headers.",
                        ).optional(),
                        "body": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "noResponseReceived": z.boolean().describe(
                          "Specifies whether a response was received from the server.",
                        ).default(false),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Describes the response to an HTTP request.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A location visited by an analysis tool while simulating or monitoring the execution of a program.",
                    ),
                  ).min(1).describe(
                    "A temporally ordered array of 'threadFlowLocation' objects, each of which describes a location visited by the tool while producing the result.",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Describes a sequence of code locations that specify a path through a single thread of execution such as an operating system or fiber.",
                ),
              ).min(1).describe(
                "An array of one or more unique threadFlow objects, each of which describes the progress of a program through a thread of execution.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A set of threadFlows which together describe a pattern of code execution relevant to detecting a result.",
            ),
          ).min(0).describe(
            "An array of 'codeFlow' objects relevant to the result.",
          ).default([]),
          "graphs": z.array(
            z.object({
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "nodes": z.array(
                z.object({
                  "id": z.string().describe(
                    "A string that uniquely identifies the node within its graph.",
                  ),
                  "label": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "location": z.object({
                    "id": z.number().int().gte(-1).describe(
                      "Value that distinguishes this location from all other locations within a single result object.",
                    ).default(-1),
                    "physicalLocation": z.object({
                      "address": z.object({
                        "absoluteAddress": z.number().int().gte(-1).describe(
                          "The address expressed as a byte offset from the start of the addressable region.",
                        ).default(-1),
                        "relativeAddress": z.number().int().describe(
                          "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                        ).optional(),
                        "length": z.number().int().describe(
                          "The number of bytes in this range of addresses.",
                        ).optional(),
                        "kind": z.string().describe(
                          "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                        ).optional(),
                        "name": z.string().describe(
                          "A name that is associated with the address, e.g., '.text'.",
                        ).optional(),
                        "fullyQualifiedName": z.string().describe(
                          "A human-readable fully qualified name that is associated with the address.",
                        ).optional(),
                        "offsetFromParent": z.number().int().describe(
                          "The byte offset of this address from the absolute or relative address of the parent object.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index within run.addresses of the cached object for this address.",
                        ).default(-1),
                        "parentIndex": z.number().int().gte(-1).describe(
                          "The index within run.addresses of the parent object.",
                        ).default(-1),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                      ).optional(),
                      "artifactLocation": z.object({
                        "uri": z.string().describe(
                          "A string containing a valid relative or absolute URI.",
                        ).optional(),
                        "uriBaseId": z.string().describe(
                          'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index within the run artifacts array of the artifact object associated with the artifact location.",
                        ).default(-1),
                        "description": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Specifies the location of an artifact.",
                      ).optional(),
                      "region": z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ).optional(),
                      "contextRegion": z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                    ).optional(),
                    "logicalLocations": z.array(
                      z.object({
                        "name": z.string().describe(
                          "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index within the logical locations array.",
                        ).default(-1),
                        "fullyQualifiedName": z.string().describe(
                          "The human-readable fully qualified name of the logical location.",
                        ).optional(),
                        "decoratedName": z.string().describe(
                          "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                        ).optional(),
                        "parentIndex": z.number().int().gte(-1).describe(
                          "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                        ).default(-1),
                        "kind": z.string().describe(
                          "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A logical location of a construct that produced a result.",
                      ),
                    ).min(0).describe(
                      "The logical locations associated with the result.",
                    ).default([]),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "annotations": z.array(
                      z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ),
                    ).min(0).describe(
                      "A set of regions relevant to the location.",
                    ).default([]),
                    "relationships": z.array(
                      z.object({
                        "target": z.number().int().gte(0).describe(
                          "A reference to the related location.",
                        ),
                        "kinds": z.array(z.string()).describe(
                          "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                        ).default(["relevant"]),
                        "description": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Information about the relation of one location to another.",
                      ),
                    ).min(0).describe(
                      "An array of objects that describe relationships between this location and others.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A location within a programming artifact.",
                  ).optional(),
                  "children": z.array(z.any()).min(0).describe(
                    "Array of child nodes.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Represents a node in a graph."),
              ).min(0).describe(
                "An array of node objects representing the nodes of the graph.",
              ).default([]),
              "edges": z.array(
                z.object({
                  "id": z.string().describe(
                    "A string that uniquely identifies the edge within its graph.",
                  ),
                  "label": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceNodeId": z.string().describe(
                    "Identifies the source node (the node at which the edge starts).",
                  ),
                  "targetNodeId": z.string().describe(
                    "Identifies the target node (the node at which the edge ends).",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Represents a directed edge in a graph."),
              ).min(0).describe(
                "An array of edge objects representing the edges of the graph.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A network of nodes and directed edges that describes some aspect of the structure of the code (for example, a call graph).",
            ),
          ).min(0).describe(
            "An array of zero or more unique graph objects associated with the result.",
          ).default([]),
          "graphTraversals": z.array(
            z.object({
              "runGraphIndex": z.number().int().gte(-1).describe(
                "The index within the run.graphs to be associated with the result.",
              ).default(-1),
              "resultGraphIndex": z.number().int().gte(-1).describe(
                "The index within the result.graphs to be associated with the result.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "initialState": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "Values of relevant expressions at the start of the graph traversal that may change during graph traversal.",
              ).optional(),
              "immutableState": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "Values of relevant expressions at the start of the graph traversal that remain constant for the graph traversal.",
              ).optional(),
              "edgeTraversals": z.array(
                z.object({
                  "edgeId": z.string().describe(
                    "Identifies the edge being traversed.",
                  ),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "finalState": z.record(
                    z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ),
                  ).describe(
                    "The values of relevant expressions after the edge has been traversed.",
                  ).optional(),
                  "stepOverEdgeCount": z.number().int().gte(0).describe(
                    "The number of edge traversals necessary to return from a nested graph.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Represents the traversal of a single edge during a graph traversal.",
                ),
              ).min(0).describe(
                "The sequences of edges traversed by this graph traversal.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(
              z.any().superRefine((x, ctx) => {
                const schemas = [z.any(), z.any()];
                const errors = schemas.reduce<z.ZodError[]>(
                  (errors, schema) =>
                    ((result) =>
                      result.error ? [...errors, result.error] : errors)(
                        schema.safeParse(x),
                      ),
                  [],
                );
                if (schemas.length - errors.length !== 1) {
                  ctx.addIssue({
                    path: ctx.path,
                    code: "invalid_union",
                    unionErrors: errors,
                    message: "Invalid input: Should pass single schema",
                  });
                }
              }),
            ).describe("Represents a path through a graph."),
          ).min(0).describe(
            "An array of one or more unique 'graphTraversal' objects.",
          ).default([]),
          "relatedLocations": z.array(
            z.object({
              "id": z.number().int().gte(-1).describe(
                "Value that distinguishes this location from all other locations within a single result object.",
              ).default(-1),
              "physicalLocation": z.object({
                "address": z.object({
                  "absoluteAddress": z.number().int().gte(-1).describe(
                    "The address expressed as a byte offset from the start of the addressable region.",
                  ).default(-1),
                  "relativeAddress": z.number().int().describe(
                    "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                  ).optional(),
                  "length": z.number().int().describe(
                    "The number of bytes in this range of addresses.",
                  ).optional(),
                  "kind": z.string().describe(
                    "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                  ).optional(),
                  "name": z.string().describe(
                    "A name that is associated with the address, e.g., '.text'.",
                  ).optional(),
                  "fullyQualifiedName": z.string().describe(
                    "A human-readable fully qualified name that is associated with the address.",
                  ).optional(),
                  "offsetFromParent": z.number().int().describe(
                    "The byte offset of this address from the absolute or relative address of the parent object.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within run.addresses of the cached object for this address.",
                  ).default(-1),
                  "parentIndex": z.number().int().gte(-1).describe(
                    "The index within run.addresses of the parent object.",
                  ).default(-1),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                ).optional(),
                "artifactLocation": z.object({
                  "uri": z.string().describe(
                    "A string containing a valid relative or absolute URI.",
                  ).optional(),
                  "uriBaseId": z.string().describe(
                    'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within the run artifacts array of the artifact object associated with the artifact location.",
                  ).default(-1),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Specifies the location of an artifact.")
                  .optional(),
                "region": z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ).optional(),
                "contextRegion": z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
              ).optional(),
              "logicalLocations": z.array(
                z.object({
                  "name": z.string().describe(
                    "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within the logical locations array.",
                  ).default(-1),
                  "fullyQualifiedName": z.string().describe(
                    "The human-readable fully qualified name of the logical location.",
                  ).optional(),
                  "decoratedName": z.string().describe(
                    "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                  ).optional(),
                  "parentIndex": z.number().int().gte(-1).describe(
                    "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                  ).default(-1),
                  "kind": z.string().describe(
                    "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A logical location of a construct that produced a result.",
                ),
              ).min(0).describe(
                "The logical locations associated with the result.",
              ).default([]),
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "annotations": z.array(
                z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ),
              ).min(0).describe("A set of regions relevant to the location.")
                .default([]),
              "relationships": z.array(
                z.object({
                  "target": z.number().int().gte(0).describe(
                    "A reference to the related location.",
                  ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one location to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this location and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("A location within a programming artifact."),
          ).min(0).describe("A set of locations relevant to this result.")
            .default([]),
          "suppressions": z.array(
            z.object({
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A stable, unique identifier for the suppression in the form of a GUID.",
              ).optional(),
              "kind": z.enum(["inSource", "external"]).describe(
                "A string that indicates where the suppression is persisted.",
              ),
              "state": z.enum(["accepted", "underReview", "rejected"]).describe(
                "A string that indicates the state of the suppression.",
              ).optional(),
              "justification": z.string().describe(
                "A string representing the justification for the suppression.",
              ).optional(),
              "location": z.object({
                "id": z.number().int().gte(-1).describe(
                  "Value that distinguishes this location from all other locations within a single result object.",
                ).default(-1),
                "physicalLocation": z.object({
                  "address": z.object({
                    "absoluteAddress": z.number().int().gte(-1).describe(
                      "The address expressed as a byte offset from the start of the addressable region.",
                    ).default(-1),
                    "relativeAddress": z.number().int().describe(
                      "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                    ).optional(),
                    "length": z.number().int().describe(
                      "The number of bytes in this range of addresses.",
                    ).optional(),
                    "kind": z.string().describe(
                      "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                    ).optional(),
                    "name": z.string().describe(
                      "A name that is associated with the address, e.g., '.text'.",
                    ).optional(),
                    "fullyQualifiedName": z.string().describe(
                      "A human-readable fully qualified name that is associated with the address.",
                    ).optional(),
                    "offsetFromParent": z.number().int().describe(
                      "The byte offset of this address from the absolute or relative address of the parent object.",
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within run.addresses of the cached object for this address.",
                    ).default(-1),
                    "parentIndex": z.number().int().gte(-1).describe(
                      "The index within run.addresses of the parent object.",
                    ).default(-1),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                  ).optional(),
                  "artifactLocation": z.object({
                    "uri": z.string().describe(
                      "A string containing a valid relative or absolute URI.",
                    ).optional(),
                    "uriBaseId": z.string().describe(
                      'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within the run artifacts array of the artifact object associated with the artifact location.",
                    ).default(-1),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe("Specifies the location of an artifact.")
                    .optional(),
                  "region": z.object({
                    "startLine": z.number().int().gte(1).describe(
                      "The line number of the first character in the region.",
                    ).optional(),
                    "startColumn": z.number().int().gte(1).describe(
                      "The column number of the first character in the region.",
                    ).optional(),
                    "endLine": z.number().int().gte(1).describe(
                      "The line number of the last character in the region.",
                    ).optional(),
                    "endColumn": z.number().int().gte(1).describe(
                      "The column number of the character following the end of the region.",
                    ).optional(),
                    "charOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                    ).default(-1),
                    "charLength": z.number().int().gte(0).describe(
                      "The length of the region in characters.",
                    ).optional(),
                    "byteOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                    ).default(-1),
                    "byteLength": z.number().int().gte(0).describe(
                      "The length of the region in bytes.",
                    ).optional(),
                    "snippet": z.object({
                      "text": z.string().describe(
                        "UTF-8-encoded content from a text artifact.",
                      ).optional(),
                      "binary": z.string().describe(
                        "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                      ).optional(),
                      "rendered": z.object({
                        "text": z.string().describe(
                          "A plain text message string or format string.",
                        ),
                        "markdown": z.string().describe(
                          "A Markdown message string or format string.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A message string or message format string rendered in multiple formats.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Represents the contents of an artifact.",
                    ).optional(),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "sourceLanguage": z.string().describe(
                      "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A region within an artifact where a result was detected.",
                  ).optional(),
                  "contextRegion": z.object({
                    "startLine": z.number().int().gte(1).describe(
                      "The line number of the first character in the region.",
                    ).optional(),
                    "startColumn": z.number().int().gte(1).describe(
                      "The column number of the first character in the region.",
                    ).optional(),
                    "endLine": z.number().int().gte(1).describe(
                      "The line number of the last character in the region.",
                    ).optional(),
                    "endColumn": z.number().int().gte(1).describe(
                      "The column number of the character following the end of the region.",
                    ).optional(),
                    "charOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                    ).default(-1),
                    "charLength": z.number().int().gte(0).describe(
                      "The length of the region in characters.",
                    ).optional(),
                    "byteOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                    ).default(-1),
                    "byteLength": z.number().int().gte(0).describe(
                      "The length of the region in bytes.",
                    ).optional(),
                    "snippet": z.object({
                      "text": z.string().describe(
                        "UTF-8-encoded content from a text artifact.",
                      ).optional(),
                      "binary": z.string().describe(
                        "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                      ).optional(),
                      "rendered": z.object({
                        "text": z.string().describe(
                          "A plain text message string or format string.",
                        ),
                        "markdown": z.string().describe(
                          "A Markdown message string or format string.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A message string or message format string rendered in multiple formats.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Represents the contents of an artifact.",
                    ).optional(),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "sourceLanguage": z.string().describe(
                      "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A region within an artifact where a result was detected.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                ).optional(),
                "logicalLocations": z.array(
                  z.object({
                    "name": z.string().describe(
                      "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within the logical locations array.",
                    ).default(-1),
                    "fullyQualifiedName": z.string().describe(
                      "The human-readable fully qualified name of the logical location.",
                    ).optional(),
                    "decoratedName": z.string().describe(
                      "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                    ).optional(),
                    "parentIndex": z.number().int().gte(-1).describe(
                      "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                    ).default(-1),
                    "kind": z.string().describe(
                      "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A logical location of a construct that produced a result.",
                  ),
                ).min(0).describe(
                  "The logical locations associated with the result.",
                ).default([]),
                "message": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "annotations": z.array(
                  z.object({
                    "startLine": z.number().int().gte(1).describe(
                      "The line number of the first character in the region.",
                    ).optional(),
                    "startColumn": z.number().int().gte(1).describe(
                      "The column number of the first character in the region.",
                    ).optional(),
                    "endLine": z.number().int().gte(1).describe(
                      "The line number of the last character in the region.",
                    ).optional(),
                    "endColumn": z.number().int().gte(1).describe(
                      "The column number of the character following the end of the region.",
                    ).optional(),
                    "charOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                    ).default(-1),
                    "charLength": z.number().int().gte(0).describe(
                      "The length of the region in characters.",
                    ).optional(),
                    "byteOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                    ).default(-1),
                    "byteLength": z.number().int().gte(0).describe(
                      "The length of the region in bytes.",
                    ).optional(),
                    "snippet": z.object({
                      "text": z.string().describe(
                        "UTF-8-encoded content from a text artifact.",
                      ).optional(),
                      "binary": z.string().describe(
                        "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                      ).optional(),
                      "rendered": z.object({
                        "text": z.string().describe(
                          "A plain text message string or format string.",
                        ),
                        "markdown": z.string().describe(
                          "A Markdown message string or format string.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A message string or message format string rendered in multiple formats.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Represents the contents of an artifact.",
                    ).optional(),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "sourceLanguage": z.string().describe(
                      "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A region within an artifact where a result was detected.",
                  ),
                ).min(0).describe("A set of regions relevant to the location.")
                  .default([]),
                "relationships": z.array(
                  z.object({
                    "target": z.number().int().gte(0).describe(
                      "A reference to the related location.",
                    ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one location to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this location and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("A location within a programming artifact.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("A suppression that is relevant to a result."),
          ).min(0).describe("A set of suppressions relevant to this result.")
            .optional(),
          "baselineState": z.enum(["new", "unchanged", "updated", "absent"])
            .describe(
              "The state of a result relative to a baseline of a previous run.",
            ).optional(),
          "rank": z.number().gte(-1).lte(100).describe(
            "A number representing the priority or importance of the result.",
          ).default(-1),
          "attachments": z.array(
            z.object({
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "artifactLocation": z.object({
                "uri": z.string().describe(
                  "A string containing a valid relative or absolute URI.",
                ).optional(),
                "uriBaseId": z.string().describe(
                  'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index within the run artifacts array of the artifact object associated with the artifact location.",
                ).default(-1),
                "description": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("Specifies the location of an artifact."),
              "regions": z.array(
                z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ),
              ).min(0).describe(
                "An array of regions of interest within the attachment.",
              ).default([]),
              "rectangles": z.array(
                z.object({
                  "top": z.number().describe(
                    "The Y coordinate of the top edge of the rectangle, measured in the image's natural units.",
                  ).optional(),
                  "left": z.number().describe(
                    "The X coordinate of the left edge of the rectangle, measured in the image's natural units.",
                  ).optional(),
                  "bottom": z.number().describe(
                    "The Y coordinate of the bottom edge of the rectangle, measured in the image's natural units.",
                  ).optional(),
                  "right": z.number().describe(
                    "The X coordinate of the right edge of the rectangle, measured in the image's natural units.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("An area within an image."),
              ).min(0).describe(
                "An array of rectangles specifying areas of interest within the image.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("An artifact relevant to a result."),
          ).min(0).describe("A set of artifacts relevant to the result.")
            .default([]),
          "hostedViewerUri": z.string().url().describe(
            "An absolute URI at which the result can be viewed.",
          ).optional(),
          "workItemUris": z.array(z.string().url()).min(0).describe(
            "The URIs of the work items associated with this result.",
          ).optional(),
          "provenance": z.object({
            "firstDetectionTimeUtc": z.string().datetime({ offset: true })
              .describe(
                'The Coordinated Universal Time (UTC) date and time at which the result was first detected. See "Date/time properties" in the SARIF spec for the required format.',
              ).optional(),
            "lastDetectionTimeUtc": z.string().datetime({ offset: true })
              .describe(
                'The Coordinated Universal Time (UTC) date and time at which the result was most recently detected. See "Date/time properties" in the SARIF spec for the required format.',
              ).optional(),
            "firstDetectionRunGuid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A GUID-valued string equal to the automationDetails.guid property of the run in which the result was first detected.",
            ).optional(),
            "lastDetectionRunGuid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A GUID-valued string equal to the automationDetails.guid property of the run in which the result was most recently detected.",
            ).optional(),
            "invocationIndex": z.number().int().gte(-1).describe(
              "The index within the run.invocations array of the invocation object which describes the tool invocation that detected the result.",
            ).default(-1),
            "conversionSources": z.array(
              z.object({
                "address": z.object({
                  "absoluteAddress": z.number().int().gte(-1).describe(
                    "The address expressed as a byte offset from the start of the addressable region.",
                  ).default(-1),
                  "relativeAddress": z.number().int().describe(
                    "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                  ).optional(),
                  "length": z.number().int().describe(
                    "The number of bytes in this range of addresses.",
                  ).optional(),
                  "kind": z.string().describe(
                    "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                  ).optional(),
                  "name": z.string().describe(
                    "A name that is associated with the address, e.g., '.text'.",
                  ).optional(),
                  "fullyQualifiedName": z.string().describe(
                    "A human-readable fully qualified name that is associated with the address.",
                  ).optional(),
                  "offsetFromParent": z.number().int().describe(
                    "The byte offset of this address from the absolute or relative address of the parent object.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within run.addresses of the cached object for this address.",
                  ).default(-1),
                  "parentIndex": z.number().int().gte(-1).describe(
                    "The index within run.addresses of the parent object.",
                  ).default(-1),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                ).optional(),
                "artifactLocation": z.object({
                  "uri": z.string().describe(
                    "A string containing a valid relative or absolute URI.",
                  ).optional(),
                  "uriBaseId": z.string().describe(
                    'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within the run artifacts array of the artifact object associated with the artifact location.",
                  ).default(-1),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Specifies the location of an artifact.")
                  .optional(),
                "region": z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ).optional(),
                "contextRegion": z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
              ),
            ).min(0).describe(
              "An array of physicalLocation objects which specify the portions of an analysis tool's output that a converter transformed into the result.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Contains information about how and when a result was detected.",
          ).optional(),
          "fixes": z.array(
            z.object({
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "artifactChanges": z.array(
                z.object({
                  "artifactLocation": z.object({
                    "uri": z.string().describe(
                      "A string containing a valid relative or absolute URI.",
                    ).optional(),
                    "uriBaseId": z.string().describe(
                      'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within the run artifacts array of the artifact object associated with the artifact location.",
                    ).default(-1),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Specifies the location of an artifact.",
                  ),
                  "replacements": z.array(
                    z.object({
                      "deletedRegion": z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ),
                      "insertedContent": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "The replacement of a single region of an artifact.",
                    ),
                  ).min(1).describe(
                    "An array of replacement objects, each of which represents the replacement of a single region in a single artifact specified by 'artifactLocation'.",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("A change to a single artifact."),
              ).min(1).describe(
                "One or more artifact changes that comprise a fix for a result.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A proposed fix for the problem represented by a result object. A fix specifies a set of artifacts to modify. For each artifact, it specifies a set of bytes to remove, and provides a set of new bytes to replace them.",
            ),
          ).min(0).describe(
            "An array of 'fix' objects, each of which represents a proposed fix to the problem indicated by the result.",
          ).default([]),
          "taxa": z.array(
            z.object({
              "id": z.string().describe("The id of the descriptor.").optional(),
              "index": z.number().int().gte(-1).describe(
                "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("A guid that uniquely identifies the descriptor.")
                .optional(),
              "toolComponent": z.object({
                "name": z.string().describe(
                  "The 'name' property of the referenced toolComponent.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "An index into the referenced toolComponent in tool.extensions.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "The 'guid' property of the referenced toolComponent.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Identifies a particular toolComponent object, either the driver or an extension.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
              "Information about how to locate a relevant reporting descriptor.",
            ),
          ).min(0).describe(
            "An array of references to taxonomy reporting descriptors that are applicable to the result.",
          ).default([]),
          "webRequest": z.object({
            "index": z.number().int().gte(-1).describe(
              "The index within the run.webRequests array of the request object associated with this result.",
            ).default(-1),
            "protocol": z.string().describe(
              "The request protocol. Example: 'http'.",
            ).optional(),
            "version": z.string().describe(
              "The request version. Example: '1.1'.",
            ).optional(),
            "target": z.string().describe("The target of the request.")
              .optional(),
            "method": z.string().describe(
              "The HTTP method. Well-known values are 'GET', 'PUT', 'POST', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'.",
            ).optional(),
            "headers": z.record(z.string()).describe("The request headers.")
              .optional(),
            "parameters": z.record(z.string()).describe(
              "The request parameters.",
            ).optional(),
            "body": z.object({
              "text": z.string().describe(
                "UTF-8-encoded content from a text artifact.",
              ).optional(),
              "binary": z.string().describe(
                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
              ).optional(),
              "rendered": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Represents the contents of an artifact.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Describes an HTTP request.").optional(),
          "webResponse": z.object({
            "index": z.number().int().gte(-1).describe(
              "The index within the run.webResponses array of the response object associated with this result.",
            ).default(-1),
            "protocol": z.string().describe(
              "The response protocol. Example: 'http'.",
            ).optional(),
            "version": z.string().describe(
              "The response version. Example: '1.1'.",
            ).optional(),
            "statusCode": z.number().int().describe(
              "The response status code. Example: 451.",
            ).optional(),
            "reasonPhrase": z.string().describe(
              "The response reason. Example: 'Not found'.",
            ).optional(),
            "headers": z.record(z.string()).describe("The response headers.")
              .optional(),
            "body": z.object({
              "text": z.string().describe(
                "UTF-8-encoded content from a text artifact.",
              ).optional(),
              "binary": z.string().describe(
                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
              ).optional(),
              "rendered": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Represents the contents of an artifact.")
              .optional(),
            "noResponseReceived": z.boolean().describe(
              "Specifies whether a response was received from the server.",
            ).default(false),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Describes the response to an HTTP request.")
            .optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe("A result produced by an analysis tool."),
      ).min(0).describe(
        "The set of results contained in an SARIF log. The results array can be omitted when a run is solely exporting rules metadata. It must be present (but may be empty) if a log file represents an actual scan.",
      ).optional(),
      "automationDetails": z.object({
        "description": z.object({
          "text": z.string().describe("A plain text message string.")
            .optional(),
          "markdown": z.string().describe("A Markdown message string.")
            .optional(),
          "id": z.string().describe("The identifier for this message.")
            .optional(),
          "arguments": z.array(z.string()).min(0).describe(
            "An array of strings to substitute into the message string.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().and(z.union([z.any(), z.any()])).describe(
          "Encapsulates a message intended to be read by the end user.",
        ).optional(),
        "id": z.string().describe(
          "A hierarchical string that uniquely identifies this object's containing run object.",
        ).optional(),
        "guid": z.string().regex(
          new RegExp(
            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
          ),
        ).describe(
          "A stable, unique identifier for this object's containing run object in the form of a GUID.",
        ).optional(),
        "correlationGuid": z.string().regex(
          new RegExp(
            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
          ),
        ).describe(
          "A stable, unique identifier for the equivalence class of runs to which this object's containing run object belongs in the form of a GUID.",
        ).optional(),
        "properties": z.object({
          "tags": z.array(z.string()).min(0).describe(
            "A set of distinct strings that provide additional information.",
          ).default([]),
        }).catchall(z.any()).describe(
          "Key/value pairs that provide additional information about the object.",
        ).optional(),
      }).strict().describe(
        "Information that describes a run's identity and role within an engineering system process.",
      ).optional(),
      "runAggregates": z.array(
        z.object({
          "description": z.object({
            "text": z.string().describe("A plain text message string.")
              .optional(),
            "markdown": z.string().describe("A Markdown message string.")
              .optional(),
            "id": z.string().describe("The identifier for this message.")
              .optional(),
            "arguments": z.array(z.string()).min(0).describe(
              "An array of strings to substitute into the message string.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Encapsulates a message intended to be read by the end user.",
          ).optional(),
          "id": z.string().describe(
            "A hierarchical string that uniquely identifies this object's containing run object.",
          ).optional(),
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A stable, unique identifier for this object's containing run object in the form of a GUID.",
          ).optional(),
          "correlationGuid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A stable, unique identifier for the equivalence class of runs to which this object's containing run object belongs in the form of a GUID.",
          ).optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "Information that describes a run's identity and role within an engineering system process.",
        ),
      ).min(0).describe(
        "Automation details that describe the aggregate of runs to which this run belongs.",
      ).default([]),
      "baselineGuid": z.string().regex(
        new RegExp(
          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
        ),
      ).describe(
        "The 'guid' property of a previous SARIF 'run' that comprises the baseline that was used to compute result 'baselineState' properties for the run.",
      ).optional(),
      "redactionTokens": z.array(z.string()).min(0).describe(
        "An array of strings used to replace sensitive information in a redaction-aware property.",
      ).default([]),
      "defaultEncoding": z.string().describe(
        "Specifies the default encoding for any artifact object that refers to a text file.",
      ).optional(),
      "defaultSourceLanguage": z.string().describe(
        "Specifies the default source language for any artifact object that refers to a text file that contains source code.",
      ).optional(),
      "newlineSequences": z.array(z.string()).min(1).describe(
        "An ordered list of character sequences that were treated as line breaks when computing region information for the run.",
      ).default(["\r\n", "\n"]),
      "columnKind": z.enum(["utf16CodeUnits", "unicodeCodePoints"]).describe(
        "Specifies the unit in which the tool measures columns.",
      ).optional(),
      "externalPropertyFileReferences": z.object({
        "conversion": z.object({
          "location": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A stable, unique identifier for the external property file in the form of a GUID.",
          ).optional(),
          "itemCount": z.number().int().gte(-1).describe(
            "A non-negative integer specifying the number of items contained in the external property file.",
          ).default(-1),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().and(z.union([z.any(), z.any()])).describe(
          "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
        ).optional(),
        "graphs": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing a run.graphs object to be merged with the root log file.",
        ).default([]),
        "externalizedProperties": z.object({
          "location": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A stable, unique identifier for the external property file in the form of a GUID.",
          ).optional(),
          "itemCount": z.number().int().gte(-1).describe(
            "A non-negative integer specifying the number of items contained in the external property file.",
          ).default(-1),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().and(z.union([z.any(), z.any()])).describe(
          "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
        ).optional(),
        "artifacts": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing run.artifacts arrays to be merged with the root log file.",
        ).default([]),
        "invocations": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing run.invocations arrays to be merged with the root log file.",
        ).default([]),
        "logicalLocations": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing run.logicalLocations arrays to be merged with the root log file.",
        ).default([]),
        "threadFlowLocations": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing run.threadFlowLocations arrays to be merged with the root log file.",
        ).default([]),
        "results": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing run.results arrays to be merged with the root log file.",
        ).default([]),
        "taxonomies": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing run.taxonomies arrays to be merged with the root log file.",
        ).default([]),
        "addresses": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing run.addresses arrays to be merged with the root log file.",
        ).default([]),
        "driver": z.object({
          "location": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A stable, unique identifier for the external property file in the form of a GUID.",
          ).optional(),
          "itemCount": z.number().int().gte(-1).describe(
            "A non-negative integer specifying the number of items contained in the external property file.",
          ).default(-1),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().and(z.union([z.any(), z.any()])).describe(
          "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
        ).optional(),
        "extensions": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing run.extensions arrays to be merged with the root log file.",
        ).default([]),
        "policies": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing run.policies arrays to be merged with the root log file.",
        ).default([]),
        "translations": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing run.translations arrays to be merged with the root log file.",
        ).default([]),
        "webRequests": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing run.requests arrays to be merged with the root log file.",
        ).default([]),
        "webResponses": z.array(
          z.object({
            "location": z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact.")
              .optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A stable, unique identifier for the external property file in the form of a GUID.",
            ).optional(),
            "itemCount": z.number().int().gte(-1).describe(
              "A non-negative integer specifying the number of items contained in the external property file.",
            ).default(-1),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Contains information that enables a SARIF consumer to locate the external property file that contains the value of an externalized property associated with the run.",
          ),
        ).min(0).describe(
          "An array of external property files containing run.responses arrays to be merged with the root log file.",
        ).default([]),
        "properties": z.object({
          "tags": z.array(z.string()).min(0).describe(
            "A set of distinct strings that provide additional information.",
          ).default([]),
        }).catchall(z.any()).describe(
          "Key/value pairs that provide additional information about the object.",
        ).optional(),
      }).strict().describe(
        "References to external property files that should be inlined with the content of a root log file.",
      ).optional(),
      "threadFlowLocations": z.array(
        z.object({
          "index": z.number().int().gte(-1).describe(
            "The index within the run threadFlowLocations array.",
          ).default(-1),
          "location": z.object({
            "id": z.number().int().gte(-1).describe(
              "Value that distinguishes this location from all other locations within a single result object.",
            ).default(-1),
            "physicalLocation": z.object({
              "address": z.object({
                "absoluteAddress": z.number().int().gte(-1).describe(
                  "The address expressed as a byte offset from the start of the addressable region.",
                ).default(-1),
                "relativeAddress": z.number().int().describe(
                  "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                ).optional(),
                "length": z.number().int().describe(
                  "The number of bytes in this range of addresses.",
                ).optional(),
                "kind": z.string().describe(
                  "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                ).optional(),
                "name": z.string().describe(
                  "A name that is associated with the address, e.g., '.text'.",
                ).optional(),
                "fullyQualifiedName": z.string().describe(
                  "A human-readable fully qualified name that is associated with the address.",
                ).optional(),
                "offsetFromParent": z.number().int().describe(
                  "The byte offset of this address from the absolute or relative address of the parent object.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index within run.addresses of the cached object for this address.",
                ).default(-1),
                "parentIndex": z.number().int().gte(-1).describe(
                  "The index within run.addresses of the parent object.",
                ).default(-1),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
              ).optional(),
              "artifactLocation": z.object({
                "uri": z.string().describe(
                  "A string containing a valid relative or absolute URI.",
                ).optional(),
                "uriBaseId": z.string().describe(
                  'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index within the run artifacts array of the artifact object associated with the artifact location.",
                ).default(-1),
                "description": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("Specifies the location of an artifact.")
                .optional(),
              "region": z.object({
                "startLine": z.number().int().gte(1).describe(
                  "The line number of the first character in the region.",
                ).optional(),
                "startColumn": z.number().int().gte(1).describe(
                  "The column number of the first character in the region.",
                ).optional(),
                "endLine": z.number().int().gte(1).describe(
                  "The line number of the last character in the region.",
                ).optional(),
                "endColumn": z.number().int().gte(1).describe(
                  "The column number of the character following the end of the region.",
                ).optional(),
                "charOffset": z.number().int().gte(-1).describe(
                  "The zero-based offset from the beginning of the artifact of the first character in the region.",
                ).default(-1),
                "charLength": z.number().int().gte(0).describe(
                  "The length of the region in characters.",
                ).optional(),
                "byteOffset": z.number().int().gte(-1).describe(
                  "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                ).default(-1),
                "byteLength": z.number().int().gte(0).describe(
                  "The length of the region in bytes.",
                ).optional(),
                "snippet": z.object({
                  "text": z.string().describe(
                    "UTF-8-encoded content from a text artifact.",
                  ).optional(),
                  "binary": z.string().describe(
                    "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                  ).optional(),
                  "rendered": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Represents the contents of an artifact.")
                  .optional(),
                "message": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "sourceLanguage": z.string().describe(
                  "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A region within an artifact where a result was detected.",
              ).optional(),
              "contextRegion": z.object({
                "startLine": z.number().int().gte(1).describe(
                  "The line number of the first character in the region.",
                ).optional(),
                "startColumn": z.number().int().gte(1).describe(
                  "The column number of the first character in the region.",
                ).optional(),
                "endLine": z.number().int().gte(1).describe(
                  "The line number of the last character in the region.",
                ).optional(),
                "endColumn": z.number().int().gte(1).describe(
                  "The column number of the character following the end of the region.",
                ).optional(),
                "charOffset": z.number().int().gte(-1).describe(
                  "The zero-based offset from the beginning of the artifact of the first character in the region.",
                ).default(-1),
                "charLength": z.number().int().gte(0).describe(
                  "The length of the region in characters.",
                ).optional(),
                "byteOffset": z.number().int().gte(-1).describe(
                  "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                ).default(-1),
                "byteLength": z.number().int().gte(0).describe(
                  "The length of the region in bytes.",
                ).optional(),
                "snippet": z.object({
                  "text": z.string().describe(
                    "UTF-8-encoded content from a text artifact.",
                  ).optional(),
                  "binary": z.string().describe(
                    "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                  ).optional(),
                  "rendered": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Represents the contents of an artifact.")
                  .optional(),
                "message": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "sourceLanguage": z.string().describe(
                  "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A region within an artifact where a result was detected.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
            ).optional(),
            "logicalLocations": z.array(
              z.object({
                "name": z.string().describe(
                  "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index within the logical locations array.",
                ).default(-1),
                "fullyQualifiedName": z.string().describe(
                  "The human-readable fully qualified name of the logical location.",
                ).optional(),
                "decoratedName": z.string().describe(
                  "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                ).optional(),
                "parentIndex": z.number().int().gte(-1).describe(
                  "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                ).default(-1),
                "kind": z.string().describe(
                  "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A logical location of a construct that produced a result.",
              ),
            ).min(0).describe(
              "The logical locations associated with the result.",
            ).default([]),
            "message": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "annotations": z.array(
              z.object({
                "startLine": z.number().int().gte(1).describe(
                  "The line number of the first character in the region.",
                ).optional(),
                "startColumn": z.number().int().gte(1).describe(
                  "The column number of the first character in the region.",
                ).optional(),
                "endLine": z.number().int().gte(1).describe(
                  "The line number of the last character in the region.",
                ).optional(),
                "endColumn": z.number().int().gte(1).describe(
                  "The column number of the character following the end of the region.",
                ).optional(),
                "charOffset": z.number().int().gte(-1).describe(
                  "The zero-based offset from the beginning of the artifact of the first character in the region.",
                ).default(-1),
                "charLength": z.number().int().gte(0).describe(
                  "The length of the region in characters.",
                ).optional(),
                "byteOffset": z.number().int().gte(-1).describe(
                  "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                ).default(-1),
                "byteLength": z.number().int().gte(0).describe(
                  "The length of the region in bytes.",
                ).optional(),
                "snippet": z.object({
                  "text": z.string().describe(
                    "UTF-8-encoded content from a text artifact.",
                  ).optional(),
                  "binary": z.string().describe(
                    "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                  ).optional(),
                  "rendered": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Represents the contents of an artifact.")
                  .optional(),
                "message": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "sourceLanguage": z.string().describe(
                  "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A region within an artifact where a result was detected.",
              ),
            ).min(0).describe("A set of regions relevant to the location.")
              .default([]),
            "relationships": z.array(
              z.object({
                "target": z.number().int().gte(0).describe(
                  "A reference to the related location.",
                ),
                "kinds": z.array(z.string()).describe(
                  "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                ).default(["relevant"]),
                "description": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about the relation of one location to another.",
              ),
            ).min(0).describe(
              "An array of objects that describe relationships between this location and others.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("A location within a programming artifact.")
            .optional(),
          "stack": z.object({
            "message": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "frames": z.array(
              z.object({
                "location": z.object({
                  "id": z.number().int().gte(-1).describe(
                    "Value that distinguishes this location from all other locations within a single result object.",
                  ).default(-1),
                  "physicalLocation": z.object({
                    "address": z.object({
                      "absoluteAddress": z.number().int().gte(-1).describe(
                        "The address expressed as a byte offset from the start of the addressable region.",
                      ).default(-1),
                      "relativeAddress": z.number().int().describe(
                        "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                      ).optional(),
                      "length": z.number().int().describe(
                        "The number of bytes in this range of addresses.",
                      ).optional(),
                      "kind": z.string().describe(
                        "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                      ).optional(),
                      "name": z.string().describe(
                        "A name that is associated with the address, e.g., '.text'.",
                      ).optional(),
                      "fullyQualifiedName": z.string().describe(
                        "A human-readable fully qualified name that is associated with the address.",
                      ).optional(),
                      "offsetFromParent": z.number().int().describe(
                        "The byte offset of this address from the absolute or relative address of the parent object.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the cached object for this address.",
                      ).default(-1),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the parent object.",
                      ).default(-1),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                    ).optional(),
                    "artifactLocation": z.object({
                      "uri": z.string().describe(
                        "A string containing a valid relative or absolute URI.",
                      ).optional(),
                      "uriBaseId": z.string().describe(
                        'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the run artifacts array of the artifact object associated with the artifact location.",
                      ).default(-1),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Specifies the location of an artifact.",
                    ).optional(),
                    "region": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "contextRegion": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                  ).optional(),
                  "logicalLocations": z.array(
                    z.object({
                      "name": z.string().describe(
                        "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the logical locations array.",
                      ).default(-1),
                      "fullyQualifiedName": z.string().describe(
                        "The human-readable fully qualified name of the logical location.",
                      ).optional(),
                      "decoratedName": z.string().describe(
                        "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                      ).optional(),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                      ).default(-1),
                      "kind": z.string().describe(
                        "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A logical location of a construct that produced a result.",
                    ),
                  ).min(0).describe(
                    "The logical locations associated with the result.",
                  ).default([]),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "annotations": z.array(
                    z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ),
                  ).min(0).describe(
                    "A set of regions relevant to the location.",
                  ).default([]),
                  "relationships": z.array(
                    z.object({
                      "target": z.number().int().gte(0).describe(
                        "A reference to the related location.",
                      ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one location to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this location and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A location within a programming artifact.",
                ).optional(),
                "module": z.string().describe(
                  "The name of the module that contains the code of this stack frame.",
                ).optional(),
                "threadId": z.number().int().describe(
                  "The thread identifier of the stack frame.",
                ).optional(),
                "parameters": z.array(z.string().default([])).min(0).describe(
                  "The parameters of the call that is executing.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("A function call within a stack trace."),
            ).min(0).describe(
              "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
            ),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("A call stack that is relevant to a result.")
            .optional(),
          "kinds": z.array(z.string()).min(0).describe(
            "A set of distinct strings that categorize the thread flow location. Well-known kinds include 'acquire', 'release', 'enter', 'exit', 'call', 'return', 'branch', 'implicit', 'false', 'true', 'caution', 'danger', 'unknown', 'unreachable', 'taint', 'function', 'handler', 'lock', 'memory', 'resource', 'scope' and 'value'.",
          ).default([]),
          "taxa": z.array(
            z.object({
              "id": z.string().describe("The id of the descriptor.").optional(),
              "index": z.number().int().gte(-1).describe(
                "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("A guid that uniquely identifies the descriptor.")
                .optional(),
              "toolComponent": z.object({
                "name": z.string().describe(
                  "The 'name' property of the referenced toolComponent.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "An index into the referenced toolComponent in tool.extensions.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "The 'guid' property of the referenced toolComponent.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Identifies a particular toolComponent object, either the driver or an extension.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
              "Information about how to locate a relevant reporting descriptor.",
            ),
          ).min(0).describe(
            "An array of references to rule or taxonomy reporting descriptors that are applicable to the thread flow location.",
          ).default([]),
          "module": z.string().describe(
            "The name of the module that contains the code that is executing.",
          ).optional(),
          "state": z.record(
            z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ),
          ).describe(
            "A dictionary, each of whose keys specifies a variable or expression, the associated value of which represents the variable or expression value. For an annotation of kind 'continuation', for example, this dictionary might hold the current assumed values of a set of global variables.",
          ).optional(),
          "nestingLevel": z.number().int().gte(0).describe(
            "An integer representing a containment hierarchy within the thread flow.",
          ).optional(),
          "executionOrder": z.number().int().gte(-1).describe(
            "An integer representing the temporal order in which execution reached this location.",
          ).default(-1),
          "executionTimeUtc": z.string().datetime({ offset: true }).describe(
            "The Coordinated Universal Time (UTC) date and time at which this location was executed.",
          ).optional(),
          "importance": z.enum(["important", "essential", "unimportant"])
            .describe(
              'Specifies the importance of this location in understanding the code flow in which it occurs. The order from most to least important is "essential", "important", "unimportant". Default: "important".',
            ).default("important"),
          "webRequest": z.object({
            "index": z.number().int().gte(-1).describe(
              "The index within the run.webRequests array of the request object associated with this result.",
            ).default(-1),
            "protocol": z.string().describe(
              "The request protocol. Example: 'http'.",
            ).optional(),
            "version": z.string().describe(
              "The request version. Example: '1.1'.",
            ).optional(),
            "target": z.string().describe("The target of the request.")
              .optional(),
            "method": z.string().describe(
              "The HTTP method. Well-known values are 'GET', 'PUT', 'POST', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'.",
            ).optional(),
            "headers": z.record(z.string()).describe("The request headers.")
              .optional(),
            "parameters": z.record(z.string()).describe(
              "The request parameters.",
            ).optional(),
            "body": z.object({
              "text": z.string().describe(
                "UTF-8-encoded content from a text artifact.",
              ).optional(),
              "binary": z.string().describe(
                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
              ).optional(),
              "rendered": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Represents the contents of an artifact.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Describes an HTTP request.").optional(),
          "webResponse": z.object({
            "index": z.number().int().gte(-1).describe(
              "The index within the run.webResponses array of the response object associated with this result.",
            ).default(-1),
            "protocol": z.string().describe(
              "The response protocol. Example: 'http'.",
            ).optional(),
            "version": z.string().describe(
              "The response version. Example: '1.1'.",
            ).optional(),
            "statusCode": z.number().int().describe(
              "The response status code. Example: 451.",
            ).optional(),
            "reasonPhrase": z.string().describe(
              "The response reason. Example: 'Not found'.",
            ).optional(),
            "headers": z.record(z.string()).describe("The response headers.")
              .optional(),
            "body": z.object({
              "text": z.string().describe(
                "UTF-8-encoded content from a text artifact.",
              ).optional(),
              "binary": z.string().describe(
                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
              ).optional(),
              "rendered": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Represents the contents of an artifact.")
              .optional(),
            "noResponseReceived": z.boolean().describe(
              "Specifies whether a response was received from the server.",
            ).default(false),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Describes the response to an HTTP request.")
            .optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A location visited by an analysis tool while simulating or monitoring the execution of a program.",
        ),
      ).min(0).describe(
        "An array of threadFlowLocation objects cached at run level.",
      ).default([]),
      "taxonomies": z.array(
        z.object({
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A unique identifier for the tool component in the form of a GUID.",
          ).optional(),
          "name": z.string().describe("The name of the tool component."),
          "organization": z.string().describe(
            "The organization or company that produced the tool component.",
          ).optional(),
          "product": z.string().describe(
            "A product suite to which the tool component belongs.",
          ).optional(),
          "productSuite": z.string().describe(
            "A localizable string containing the name of the suite of products to which the tool component belongs.",
          ).optional(),
          "shortDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullName": z.string().describe(
            "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
          ).optional(),
          "version": z.string().describe(
            "The tool component version, in whatever format the component natively provides.",
          ).optional(),
          "semanticVersion": z.string().describe(
            "The tool component version in the format specified by Semantic Versioning 2.0.",
          ).optional(),
          "dottedQuadFileVersion": z.string().regex(
            new RegExp("[0-9]+(\\.[0-9]+){3}"),
          ).describe(
            "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
          ).optional(),
          "releaseDateUtc": z.string().describe(
            "A string specifying the UTC date (and optionally, the time) of the component's release.",
          ).optional(),
          "downloadUri": z.string().url().describe(
            "The absolute URI from which the tool component can be downloaded.",
          ).optional(),
          "informationUri": z.string().url().describe(
            "The absolute URI at which information about this version of the tool component can be found.",
          ).optional(),
          "globalMessageStrings": z.record(
            z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ),
          ).describe(
            "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
          ).optional(),
          "notifications": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
          ).default([]),
          "rules": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
          ).default([]),
          "taxa": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
          ).default([]),
          "locations": z.array(
            z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact."),
          ).min(0).describe(
            "An array of the artifactLocation objects associated with the tool component.",
          ).default([]),
          "language": z.string().regex(
            new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
          ).describe(
            "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
          ).default("en-US"),
          "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
            .describe("The kinds of data contained in this object.").default([
              "localizedData",
              "nonLocalizedData",
            ]),
          "isComprehensive": z.boolean().describe(
            "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
          ).default(false),
          "localizedDataSemanticVersion": z.string().describe(
            "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
          ).optional(),
          "minimumRequiredLocalizedDataSemanticVersion": z.string().describe(
            "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
          ).optional(),
          "associatedComponent": z.object({
            "name": z.string().describe(
              "The 'name' property of the referenced toolComponent.",
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "An index into the referenced toolComponent in tool.extensions.",
            ).default(-1),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe("The 'guid' property of the referenced toolComponent.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Identifies a particular toolComponent object, either the driver or an extension.",
          ).optional(),
          "translationMetadata": z.object({
            "name": z.string().describe(
              "The name associated with the translation metadata.",
            ),
            "fullName": z.string().describe(
              "The full name associated with the translation metadata.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "downloadUri": z.string().url().describe(
              "The absolute URI from which the translation metadata can be downloaded.",
            ).optional(),
            "informationUri": z.string().url().describe(
              "The absolute URI from which information related to the translation metadata can be downloaded.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Provides additional metadata related to translation.",
          ).optional(),
          "supportedTaxonomies": z.array(
            z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ),
          ).min(0).describe(
            "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A component, such as a plug-in or the driver, of the analysis tool that was run.",
        ),
      ).min(0).describe(
        "An array of toolComponent objects relevant to a taxonomy in which results are categorized.",
      ).default([]),
      "addresses": z.array(
        z.object({
          "absoluteAddress": z.number().int().gte(-1).describe(
            "The address expressed as a byte offset from the start of the addressable region.",
          ).default(-1),
          "relativeAddress": z.number().int().describe(
            "The address expressed as a byte offset from the absolute address of the top-most parent object.",
          ).optional(),
          "length": z.number().int().describe(
            "The number of bytes in this range of addresses.",
          ).optional(),
          "kind": z.string().describe(
            "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
          ).optional(),
          "name": z.string().describe(
            "A name that is associated with the address, e.g., '.text'.",
          ).optional(),
          "fullyQualifiedName": z.string().describe(
            "A human-readable fully qualified name that is associated with the address.",
          ).optional(),
          "offsetFromParent": z.number().int().describe(
            "The byte offset of this address from the absolute or relative address of the parent object.",
          ).optional(),
          "index": z.number().int().gte(-1).describe(
            "The index within run.addresses of the cached object for this address.",
          ).default(-1),
          "parentIndex": z.number().int().gte(-1).describe(
            "The index within run.addresses of the parent object.",
          ).default(-1),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
        ),
      ).min(0).describe("Addresses associated with this run instance, if any.")
        .default([]),
      "translations": z.array(
        z.object({
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A unique identifier for the tool component in the form of a GUID.",
          ).optional(),
          "name": z.string().describe("The name of the tool component."),
          "organization": z.string().describe(
            "The organization or company that produced the tool component.",
          ).optional(),
          "product": z.string().describe(
            "A product suite to which the tool component belongs.",
          ).optional(),
          "productSuite": z.string().describe(
            "A localizable string containing the name of the suite of products to which the tool component belongs.",
          ).optional(),
          "shortDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullName": z.string().describe(
            "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
          ).optional(),
          "version": z.string().describe(
            "The tool component version, in whatever format the component natively provides.",
          ).optional(),
          "semanticVersion": z.string().describe(
            "The tool component version in the format specified by Semantic Versioning 2.0.",
          ).optional(),
          "dottedQuadFileVersion": z.string().regex(
            new RegExp("[0-9]+(\\.[0-9]+){3}"),
          ).describe(
            "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
          ).optional(),
          "releaseDateUtc": z.string().describe(
            "A string specifying the UTC date (and optionally, the time) of the component's release.",
          ).optional(),
          "downloadUri": z.string().url().describe(
            "The absolute URI from which the tool component can be downloaded.",
          ).optional(),
          "informationUri": z.string().url().describe(
            "The absolute URI at which information about this version of the tool component can be found.",
          ).optional(),
          "globalMessageStrings": z.record(
            z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ),
          ).describe(
            "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
          ).optional(),
          "notifications": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
          ).default([]),
          "rules": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
          ).default([]),
          "taxa": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
          ).default([]),
          "locations": z.array(
            z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact."),
          ).min(0).describe(
            "An array of the artifactLocation objects associated with the tool component.",
          ).default([]),
          "language": z.string().regex(
            new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
          ).describe(
            "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
          ).default("en-US"),
          "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
            .describe("The kinds of data contained in this object.").default([
              "localizedData",
              "nonLocalizedData",
            ]),
          "isComprehensive": z.boolean().describe(
            "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
          ).default(false),
          "localizedDataSemanticVersion": z.string().describe(
            "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
          ).optional(),
          "minimumRequiredLocalizedDataSemanticVersion": z.string().describe(
            "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
          ).optional(),
          "associatedComponent": z.object({
            "name": z.string().describe(
              "The 'name' property of the referenced toolComponent.",
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "An index into the referenced toolComponent in tool.extensions.",
            ).default(-1),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe("The 'guid' property of the referenced toolComponent.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Identifies a particular toolComponent object, either the driver or an extension.",
          ).optional(),
          "translationMetadata": z.object({
            "name": z.string().describe(
              "The name associated with the translation metadata.",
            ),
            "fullName": z.string().describe(
              "The full name associated with the translation metadata.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "downloadUri": z.string().url().describe(
              "The absolute URI from which the translation metadata can be downloaded.",
            ).optional(),
            "informationUri": z.string().url().describe(
              "The absolute URI from which information related to the translation metadata can be downloaded.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Provides additional metadata related to translation.",
          ).optional(),
          "supportedTaxonomies": z.array(
            z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ),
          ).min(0).describe(
            "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A component, such as a plug-in or the driver, of the analysis tool that was run.",
        ),
      ).min(0).describe(
        "The set of available translations of the localized data provided by the tool.",
      ).default([]),
      "policies": z.array(
        z.object({
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A unique identifier for the tool component in the form of a GUID.",
          ).optional(),
          "name": z.string().describe("The name of the tool component."),
          "organization": z.string().describe(
            "The organization or company that produced the tool component.",
          ).optional(),
          "product": z.string().describe(
            "A product suite to which the tool component belongs.",
          ).optional(),
          "productSuite": z.string().describe(
            "A localizable string containing the name of the suite of products to which the tool component belongs.",
          ).optional(),
          "shortDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullName": z.string().describe(
            "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
          ).optional(),
          "version": z.string().describe(
            "The tool component version, in whatever format the component natively provides.",
          ).optional(),
          "semanticVersion": z.string().describe(
            "The tool component version in the format specified by Semantic Versioning 2.0.",
          ).optional(),
          "dottedQuadFileVersion": z.string().regex(
            new RegExp("[0-9]+(\\.[0-9]+){3}"),
          ).describe(
            "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
          ).optional(),
          "releaseDateUtc": z.string().describe(
            "A string specifying the UTC date (and optionally, the time) of the component's release.",
          ).optional(),
          "downloadUri": z.string().url().describe(
            "The absolute URI from which the tool component can be downloaded.",
          ).optional(),
          "informationUri": z.string().url().describe(
            "The absolute URI at which information about this version of the tool component can be found.",
          ).optional(),
          "globalMessageStrings": z.record(
            z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ),
          ).describe(
            "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
          ).optional(),
          "notifications": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
          ).default([]),
          "rules": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
          ).default([]),
          "taxa": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
          ).default([]),
          "locations": z.array(
            z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact."),
          ).min(0).describe(
            "An array of the artifactLocation objects associated with the tool component.",
          ).default([]),
          "language": z.string().regex(
            new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
          ).describe(
            "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
          ).default("en-US"),
          "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
            .describe("The kinds of data contained in this object.").default([
              "localizedData",
              "nonLocalizedData",
            ]),
          "isComprehensive": z.boolean().describe(
            "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
          ).default(false),
          "localizedDataSemanticVersion": z.string().describe(
            "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
          ).optional(),
          "minimumRequiredLocalizedDataSemanticVersion": z.string().describe(
            "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
          ).optional(),
          "associatedComponent": z.object({
            "name": z.string().describe(
              "The 'name' property of the referenced toolComponent.",
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "An index into the referenced toolComponent in tool.extensions.",
            ).default(-1),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe("The 'guid' property of the referenced toolComponent.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Identifies a particular toolComponent object, either the driver or an extension.",
          ).optional(),
          "translationMetadata": z.object({
            "name": z.string().describe(
              "The name associated with the translation metadata.",
            ),
            "fullName": z.string().describe(
              "The full name associated with the translation metadata.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "downloadUri": z.string().url().describe(
              "The absolute URI from which the translation metadata can be downloaded.",
            ).optional(),
            "informationUri": z.string().url().describe(
              "The absolute URI from which information related to the translation metadata can be downloaded.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Provides additional metadata related to translation.",
          ).optional(),
          "supportedTaxonomies": z.array(
            z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ),
          ).min(0).describe(
            "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A component, such as a plug-in or the driver, of the analysis tool that was run.",
        ),
      ).min(0).describe(
        "Contains configurations that may potentially override both reportingDescriptor.defaultConfiguration (the tool's default severities) and invocation.configurationOverrides (severities established at run-time from the command line).",
      ).default([]),
      "webRequests": z.array(
        z.object({
          "index": z.number().int().gte(-1).describe(
            "The index within the run.webRequests array of the request object associated with this result.",
          ).default(-1),
          "protocol": z.string().describe(
            "The request protocol. Example: 'http'.",
          ).optional(),
          "version": z.string().describe("The request version. Example: '1.1'.")
            .optional(),
          "target": z.string().describe("The target of the request.")
            .optional(),
          "method": z.string().describe(
            "The HTTP method. Well-known values are 'GET', 'PUT', 'POST', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'.",
          ).optional(),
          "headers": z.record(z.string()).describe("The request headers.")
            .optional(),
          "parameters": z.record(z.string()).describe("The request parameters.")
            .optional(),
          "body": z.object({
            "text": z.string().describe(
              "UTF-8-encoded content from a text artifact.",
            ).optional(),
            "binary": z.string().describe(
              "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
            ).optional(),
            "rendered": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Represents the contents of an artifact.")
            .optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe("Describes an HTTP request."),
      ).min(0).describe("An array of request objects cached at run level.")
        .default([]),
      "webResponses": z.array(
        z.object({
          "index": z.number().int().gte(-1).describe(
            "The index within the run.webResponses array of the response object associated with this result.",
          ).default(-1),
          "protocol": z.string().describe(
            "The response protocol. Example: 'http'.",
          ).optional(),
          "version": z.string().describe(
            "The response version. Example: '1.1'.",
          ).optional(),
          "statusCode": z.number().int().describe(
            "The response status code. Example: 451.",
          ).optional(),
          "reasonPhrase": z.string().describe(
            "The response reason. Example: 'Not found'.",
          ).optional(),
          "headers": z.record(z.string()).describe("The response headers.")
            .optional(),
          "body": z.object({
            "text": z.string().describe(
              "UTF-8-encoded content from a text artifact.",
            ).optional(),
            "binary": z.string().describe(
              "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
            ).optional(),
            "rendered": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Represents the contents of an artifact.")
            .optional(),
          "noResponseReceived": z.boolean().describe(
            "Specifies whether a response was received from the server.",
          ).default(false),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe("Describes the response to an HTTP request."),
      ).min(0).describe("An array of response objects cached at run level.")
        .default([]),
      "specialLocations": z.object({
        "displayBase": z.object({
          "uri": z.string().describe(
            "A string containing a valid relative or absolute URI.",
          ).optional(),
          "uriBaseId": z.string().describe(
            'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
          ).optional(),
          "index": z.number().int().gte(-1).describe(
            "The index within the run artifacts array of the artifact object associated with the artifact location.",
          ).default(-1),
          "description": z.object({
            "text": z.string().describe("A plain text message string.")
              .optional(),
            "markdown": z.string().describe("A Markdown message string.")
              .optional(),
            "id": z.string().describe("The identifier for this message.")
              .optional(),
            "arguments": z.array(z.string()).min(0).describe(
              "An array of strings to substitute into the message string.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Encapsulates a message intended to be read by the end user.",
          ).optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe("Specifies the location of an artifact.")
          .optional(),
        "properties": z.object({
          "tags": z.array(z.string()).min(0).describe(
            "A set of distinct strings that provide additional information.",
          ).default([]),
        }).catchall(z.any()).describe(
          "Key/value pairs that provide additional information about the object.",
        ).optional(),
      }).strict().describe(
        "Defines locations of special significance to SARIF consumers.",
      ).optional(),
      "properties": z.object({
        "tags": z.array(z.string()).min(0).describe(
          "A set of distinct strings that provide additional information.",
        ).default([]),
      }).catchall(z.any()).describe(
        "Key/value pairs that provide additional information about the object.",
      ).optional(),
    }).strict().describe(
      "Describes a single run of an analysis tool, and contains the reported output of that run.",
    ),
  ).min(0).describe("The set of runs contained in this log file."),
  "inlineExternalProperties": z.array(
    z.object({
      "schema": z.string().url().describe(
        "The URI of the JSON schema corresponding to the version of the external property file format.",
      ).optional(),
      "version": z.literal("2.1.0").describe(
        "The SARIF format version of this external properties object.",
      ).optional(),
      "guid": z.string().regex(
        new RegExp(
          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
        ),
      ).describe(
        "A stable, unique identifier for this external properties object, in the form of a GUID.",
      ).optional(),
      "runGuid": z.string().regex(
        new RegExp(
          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
        ),
      ).describe(
        "A stable, unique identifier for the run associated with this external properties object, in the form of a GUID.",
      ).optional(),
      "conversion": z.object({
        "tool": z.object({
          "driver": z.object({
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A unique identifier for the tool component in the form of a GUID.",
            ).optional(),
            "name": z.string().describe("The name of the tool component."),
            "organization": z.string().describe(
              "The organization or company that produced the tool component.",
            ).optional(),
            "product": z.string().describe(
              "A product suite to which the tool component belongs.",
            ).optional(),
            "productSuite": z.string().describe(
              "A localizable string containing the name of the suite of products to which the tool component belongs.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullName": z.string().describe(
              "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
            ).optional(),
            "version": z.string().describe(
              "The tool component version, in whatever format the component natively provides.",
            ).optional(),
            "semanticVersion": z.string().describe(
              "The tool component version in the format specified by Semantic Versioning 2.0.",
            ).optional(),
            "dottedQuadFileVersion": z.string().regex(
              new RegExp("[0-9]+(\\.[0-9]+){3}"),
            ).describe(
              "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
            ).optional(),
            "releaseDateUtc": z.string().describe(
              "A string specifying the UTC date (and optionally, the time) of the component's release.",
            ).optional(),
            "downloadUri": z.string().url().describe(
              "The absolute URI from which the tool component can be downloaded.",
            ).optional(),
            "informationUri": z.string().url().describe(
              "The absolute URI at which information about this version of the tool component can be found.",
            ).optional(),
            "globalMessageStrings": z.record(
              z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ),
            ).describe(
              "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
            ).optional(),
            "notifications": z.array(
              z.object({
                "id": z.string().describe(
                  "A stable, opaque identifier for the report.",
                ),
                "deprecatedIds": z.array(z.string()).min(0).describe(
                  "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "A unique identifier for the reporting descriptor in the form of a GUID.",
                ).optional(),
                "deprecatedGuids": z.array(
                  z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ),
                ).min(0).describe(
                  "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "name": z.string().describe(
                  "A report identifier that is understandable to an end user.",
                ).optional(),
                "deprecatedNames": z.array(z.string()).min(0).describe(
                  "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "shortDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "fullDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "messageStrings": z.record(
                  z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ),
                ).describe(
                  "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                ).optional(),
                "defaultConfiguration": z.object({
                  "enabled": z.boolean().describe(
                    "Specifies whether the report may be produced during the scan.",
                  ).default(true),
                  "level": z.enum(["none", "note", "warning", "error"])
                    .describe("Specifies the failure level for the report.")
                    .default("warning"),
                  "rank": z.number().gte(-1).lte(100).describe(
                    "Specifies the relative priority of the report. Used for analysis output only.",
                  ).default(-1),
                  "parameters": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about a rule or notification that can be configured at runtime.",
                ).optional(),
                "helpUri": z.string().url().describe(
                  "A URI where the primary documentation for the report can be found.",
                ).optional(),
                "help": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "relationships": z.array(
                  z.object({
                    "target": z.object({
                      "id": z.string().describe("The id of the descriptor.")
                        .optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "A guid that uniquely identifies the descriptor.",
                      ).optional(),
                      "toolComponent": z.object({
                        "name": z.string().describe(
                          "The 'name' property of the referenced toolComponent.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "An index into the referenced toolComponent in tool.extensions.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "The 'guid' property of the referenced toolComponent.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Identifies a particular toolComponent object, either the driver or an extension.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any(), z.any()]))
                      .describe(
                        "Information about how to locate a relevant reporting descriptor.",
                      ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one reporting descriptor to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this reporting descriptor and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
              ),
            ).min(0).describe(
              "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
            ).default([]),
            "rules": z.array(
              z.object({
                "id": z.string().describe(
                  "A stable, opaque identifier for the report.",
                ),
                "deprecatedIds": z.array(z.string()).min(0).describe(
                  "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "A unique identifier for the reporting descriptor in the form of a GUID.",
                ).optional(),
                "deprecatedGuids": z.array(
                  z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ),
                ).min(0).describe(
                  "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "name": z.string().describe(
                  "A report identifier that is understandable to an end user.",
                ).optional(),
                "deprecatedNames": z.array(z.string()).min(0).describe(
                  "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "shortDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "fullDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "messageStrings": z.record(
                  z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ),
                ).describe(
                  "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                ).optional(),
                "defaultConfiguration": z.object({
                  "enabled": z.boolean().describe(
                    "Specifies whether the report may be produced during the scan.",
                  ).default(true),
                  "level": z.enum(["none", "note", "warning", "error"])
                    .describe("Specifies the failure level for the report.")
                    .default("warning"),
                  "rank": z.number().gte(-1).lte(100).describe(
                    "Specifies the relative priority of the report. Used for analysis output only.",
                  ).default(-1),
                  "parameters": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about a rule or notification that can be configured at runtime.",
                ).optional(),
                "helpUri": z.string().url().describe(
                  "A URI where the primary documentation for the report can be found.",
                ).optional(),
                "help": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "relationships": z.array(
                  z.object({
                    "target": z.object({
                      "id": z.string().describe("The id of the descriptor.")
                        .optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "A guid that uniquely identifies the descriptor.",
                      ).optional(),
                      "toolComponent": z.object({
                        "name": z.string().describe(
                          "The 'name' property of the referenced toolComponent.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "An index into the referenced toolComponent in tool.extensions.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "The 'guid' property of the referenced toolComponent.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Identifies a particular toolComponent object, either the driver or an extension.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any(), z.any()]))
                      .describe(
                        "Information about how to locate a relevant reporting descriptor.",
                      ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one reporting descriptor to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this reporting descriptor and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
              ),
            ).min(0).describe(
              "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
            ).default([]),
            "taxa": z.array(
              z.object({
                "id": z.string().describe(
                  "A stable, opaque identifier for the report.",
                ),
                "deprecatedIds": z.array(z.string()).min(0).describe(
                  "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "A unique identifier for the reporting descriptor in the form of a GUID.",
                ).optional(),
                "deprecatedGuids": z.array(
                  z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ),
                ).min(0).describe(
                  "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "name": z.string().describe(
                  "A report identifier that is understandable to an end user.",
                ).optional(),
                "deprecatedNames": z.array(z.string()).min(0).describe(
                  "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                ).optional(),
                "shortDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "fullDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "messageStrings": z.record(
                  z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ),
                ).describe(
                  "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                ).optional(),
                "defaultConfiguration": z.object({
                  "enabled": z.boolean().describe(
                    "Specifies whether the report may be produced during the scan.",
                  ).default(true),
                  "level": z.enum(["none", "note", "warning", "error"])
                    .describe("Specifies the failure level for the report.")
                    .default("warning"),
                  "rank": z.number().gte(-1).lte(100).describe(
                    "Specifies the relative priority of the report. Used for analysis output only.",
                  ).default(-1),
                  "parameters": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about a rule or notification that can be configured at runtime.",
                ).optional(),
                "helpUri": z.string().url().describe(
                  "A URI where the primary documentation for the report can be found.",
                ).optional(),
                "help": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "relationships": z.array(
                  z.object({
                    "target": z.object({
                      "id": z.string().describe("The id of the descriptor.")
                        .optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "A guid that uniquely identifies the descriptor.",
                      ).optional(),
                      "toolComponent": z.object({
                        "name": z.string().describe(
                          "The 'name' property of the referenced toolComponent.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "An index into the referenced toolComponent in tool.extensions.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "The 'guid' property of the referenced toolComponent.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Identifies a particular toolComponent object, either the driver or an extension.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any(), z.any()]))
                      .describe(
                        "Information about how to locate a relevant reporting descriptor.",
                      ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one reporting descriptor to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this reporting descriptor and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
              ),
            ).min(0).describe(
              "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
            ).default([]),
            "locations": z.array(
              z.object({
                "uri": z.string().describe(
                  "A string containing a valid relative or absolute URI.",
                ).optional(),
                "uriBaseId": z.string().describe(
                  'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index within the run artifacts array of the artifact object associated with the artifact location.",
                ).default(-1),
                "description": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("Specifies the location of an artifact."),
            ).min(0).describe(
              "An array of the artifactLocation objects associated with the tool component.",
            ).default([]),
            "language": z.string().regex(
              new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
            ).describe(
              "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
            ).default("en-US"),
            "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
              .describe("The kinds of data contained in this object.").default([
                "localizedData",
                "nonLocalizedData",
              ]),
            "isComprehensive": z.boolean().describe(
              "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
            ).default(false),
            "localizedDataSemanticVersion": z.string().describe(
              "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
            ).optional(),
            "minimumRequiredLocalizedDataSemanticVersion": z.string().describe(
              "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
            ).optional(),
            "associatedComponent": z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ).optional(),
            "translationMetadata": z.object({
              "name": z.string().describe(
                "The name associated with the translation metadata.",
              ),
              "fullName": z.string().describe(
                "The full name associated with the translation metadata.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "downloadUri": z.string().url().describe(
                "The absolute URI from which the translation metadata can be downloaded.",
              ).optional(),
              "informationUri": z.string().url().describe(
                "The absolute URI from which information related to the translation metadata can be downloaded.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Provides additional metadata related to translation.",
            ).optional(),
            "supportedTaxonomies": z.array(
              z.object({
                "name": z.string().describe(
                  "The 'name' property of the referenced toolComponent.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "An index into the referenced toolComponent in tool.extensions.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "The 'guid' property of the referenced toolComponent.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Identifies a particular toolComponent object, either the driver or an extension.",
              ),
            ).min(0).describe(
              "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A component, such as a plug-in or the driver, of the analysis tool that was run.",
          ),
          "extensions": z.array(
            z.object({
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the tool component in the form of a GUID.",
              ).optional(),
              "name": z.string().describe("The name of the tool component."),
              "organization": z.string().describe(
                "The organization or company that produced the tool component.",
              ).optional(),
              "product": z.string().describe(
                "A product suite to which the tool component belongs.",
              ).optional(),
              "productSuite": z.string().describe(
                "A localizable string containing the name of the suite of products to which the tool component belongs.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullName": z.string().describe(
                "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
              ).optional(),
              "version": z.string().describe(
                "The tool component version, in whatever format the component natively provides.",
              ).optional(),
              "semanticVersion": z.string().describe(
                "The tool component version in the format specified by Semantic Versioning 2.0.",
              ).optional(),
              "dottedQuadFileVersion": z.string().regex(
                new RegExp("[0-9]+(\\.[0-9]+){3}"),
              ).describe(
                "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
              ).optional(),
              "releaseDateUtc": z.string().describe(
                "A string specifying the UTC date (and optionally, the time) of the component's release.",
              ).optional(),
              "downloadUri": z.string().url().describe(
                "The absolute URI from which the tool component can be downloaded.",
              ).optional(),
              "informationUri": z.string().url().describe(
                "The absolute URI at which information about this version of the tool component can be found.",
              ).optional(),
              "globalMessageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "notifications": z.array(
                z.object({
                  "id": z.string().describe(
                    "A stable, opaque identifier for the report.",
                  ),
                  "deprecatedIds": z.array(z.string()).min(0).describe(
                    "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "A unique identifier for the reporting descriptor in the form of a GUID.",
                  ).optional(),
                  "deprecatedGuids": z.array(
                    z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ),
                  ).min(0).describe(
                    "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "name": z.string().describe(
                    "A report identifier that is understandable to an end user.",
                  ).optional(),
                  "deprecatedNames": z.array(z.string()).min(0).describe(
                    "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "shortDescription": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "fullDescription": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "messageStrings": z.record(
                    z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ),
                  ).describe(
                    "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                  ).optional(),
                  "defaultConfiguration": z.object({
                    "enabled": z.boolean().describe(
                      "Specifies whether the report may be produced during the scan.",
                    ).default(true),
                    "level": z.enum(["none", "note", "warning", "error"])
                      .describe("Specifies the failure level for the report.")
                      .default("warning"),
                    "rank": z.number().gte(-1).lte(100).describe(
                      "Specifies the relative priority of the report. Used for analysis output only.",
                    ).default(-1),
                    "parameters": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about a rule or notification that can be configured at runtime.",
                  ).optional(),
                  "helpUri": z.string().url().describe(
                    "A URI where the primary documentation for the report can be found.",
                  ).optional(),
                  "help": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "relationships": z.array(
                    z.object({
                      "target": z.object({
                        "id": z.string().describe("The id of the descriptor.")
                          .optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "A guid that uniquely identifies the descriptor.",
                        ).optional(),
                        "toolComponent": z.object({
                          "name": z.string().describe(
                            "The 'name' property of the referenced toolComponent.",
                          ).optional(),
                          "index": z.number().int().gte(-1).describe(
                            "An index into the referenced toolComponent in tool.extensions.",
                          ).default(-1),
                          "guid": z.string().regex(
                            new RegExp(
                              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                            ),
                          ).describe(
                            "The 'guid' property of the referenced toolComponent.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Identifies a particular toolComponent object, either the driver or an extension.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any(), z.any()]))
                        .describe(
                          "Information about how to locate a relevant reporting descriptor.",
                        ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one reporting descriptor to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this reporting descriptor and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
                ),
              ).min(0).describe(
                "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
              ).default([]),
              "rules": z.array(
                z.object({
                  "id": z.string().describe(
                    "A stable, opaque identifier for the report.",
                  ),
                  "deprecatedIds": z.array(z.string()).min(0).describe(
                    "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "A unique identifier for the reporting descriptor in the form of a GUID.",
                  ).optional(),
                  "deprecatedGuids": z.array(
                    z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ),
                  ).min(0).describe(
                    "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "name": z.string().describe(
                    "A report identifier that is understandable to an end user.",
                  ).optional(),
                  "deprecatedNames": z.array(z.string()).min(0).describe(
                    "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "shortDescription": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "fullDescription": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "messageStrings": z.record(
                    z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ),
                  ).describe(
                    "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                  ).optional(),
                  "defaultConfiguration": z.object({
                    "enabled": z.boolean().describe(
                      "Specifies whether the report may be produced during the scan.",
                    ).default(true),
                    "level": z.enum(["none", "note", "warning", "error"])
                      .describe("Specifies the failure level for the report.")
                      .default("warning"),
                    "rank": z.number().gte(-1).lte(100).describe(
                      "Specifies the relative priority of the report. Used for analysis output only.",
                    ).default(-1),
                    "parameters": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about a rule or notification that can be configured at runtime.",
                  ).optional(),
                  "helpUri": z.string().url().describe(
                    "A URI where the primary documentation for the report can be found.",
                  ).optional(),
                  "help": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "relationships": z.array(
                    z.object({
                      "target": z.object({
                        "id": z.string().describe("The id of the descriptor.")
                          .optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "A guid that uniquely identifies the descriptor.",
                        ).optional(),
                        "toolComponent": z.object({
                          "name": z.string().describe(
                            "The 'name' property of the referenced toolComponent.",
                          ).optional(),
                          "index": z.number().int().gte(-1).describe(
                            "An index into the referenced toolComponent in tool.extensions.",
                          ).default(-1),
                          "guid": z.string().regex(
                            new RegExp(
                              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                            ),
                          ).describe(
                            "The 'guid' property of the referenced toolComponent.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Identifies a particular toolComponent object, either the driver or an extension.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any(), z.any()]))
                        .describe(
                          "Information about how to locate a relevant reporting descriptor.",
                        ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one reporting descriptor to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this reporting descriptor and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
                ),
              ).min(0).describe(
                "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
              ).default([]),
              "taxa": z.array(
                z.object({
                  "id": z.string().describe(
                    "A stable, opaque identifier for the report.",
                  ),
                  "deprecatedIds": z.array(z.string()).min(0).describe(
                    "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "A unique identifier for the reporting descriptor in the form of a GUID.",
                  ).optional(),
                  "deprecatedGuids": z.array(
                    z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ),
                  ).min(0).describe(
                    "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "name": z.string().describe(
                    "A report identifier that is understandable to an end user.",
                  ).optional(),
                  "deprecatedNames": z.array(z.string()).min(0).describe(
                    "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
                  ).optional(),
                  "shortDescription": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "fullDescription": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "messageStrings": z.record(
                    z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ),
                  ).describe(
                    "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
                  ).optional(),
                  "defaultConfiguration": z.object({
                    "enabled": z.boolean().describe(
                      "Specifies whether the report may be produced during the scan.",
                    ).default(true),
                    "level": z.enum(["none", "note", "warning", "error"])
                      .describe("Specifies the failure level for the report.")
                      .default("warning"),
                    "rank": z.number().gte(-1).lte(100).describe(
                      "Specifies the relative priority of the report. Used for analysis output only.",
                    ).default(-1),
                    "parameters": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about a rule or notification that can be configured at runtime.",
                  ).optional(),
                  "helpUri": z.string().url().describe(
                    "A URI where the primary documentation for the report can be found.",
                  ).optional(),
                  "help": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "relationships": z.array(
                    z.object({
                      "target": z.object({
                        "id": z.string().describe("The id of the descriptor.")
                          .optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                        ).default(-1),
                        "guid": z.string().regex(
                          new RegExp(
                            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                          ),
                        ).describe(
                          "A guid that uniquely identifies the descriptor.",
                        ).optional(),
                        "toolComponent": z.object({
                          "name": z.string().describe(
                            "The 'name' property of the referenced toolComponent.",
                          ).optional(),
                          "index": z.number().int().gte(-1).describe(
                            "An index into the referenced toolComponent in tool.extensions.",
                          ).default(-1),
                          "guid": z.string().regex(
                            new RegExp(
                              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                            ),
                          ).describe(
                            "The 'guid' property of the referenced toolComponent.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Identifies a particular toolComponent object, either the driver or an extension.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any(), z.any()]))
                        .describe(
                          "Information about how to locate a relevant reporting descriptor.",
                        ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one reporting descriptor to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this reporting descriptor and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
                ),
              ).min(0).describe(
                "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
              ).default([]),
              "locations": z.array(
                z.object({
                  "uri": z.string().describe(
                    "A string containing a valid relative or absolute URI.",
                  ).optional(),
                  "uriBaseId": z.string().describe(
                    'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within the run artifacts array of the artifact object associated with the artifact location.",
                  ).default(-1),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Specifies the location of an artifact."),
              ).min(0).describe(
                "An array of the artifactLocation objects associated with the tool component.",
              ).default([]),
              "language": z.string().regex(
                new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
              ).describe(
                "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
              ).default("en-US"),
              "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
                .describe("The kinds of data contained in this object.")
                .default(["localizedData", "nonLocalizedData"]),
              "isComprehensive": z.boolean().describe(
                "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
              ).default(false),
              "localizedDataSemanticVersion": z.string().describe(
                "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
              ).optional(),
              "minimumRequiredLocalizedDataSemanticVersion": z.string()
                .describe(
                  "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
                ).optional(),
              "associatedComponent": z.object({
                "name": z.string().describe(
                  "The 'name' property of the referenced toolComponent.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "An index into the referenced toolComponent in tool.extensions.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "The 'guid' property of the referenced toolComponent.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Identifies a particular toolComponent object, either the driver or an extension.",
              ).optional(),
              "translationMetadata": z.object({
                "name": z.string().describe(
                  "The name associated with the translation metadata.",
                ),
                "fullName": z.string().describe(
                  "The full name associated with the translation metadata.",
                ).optional(),
                "shortDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "fullDescription": z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ).optional(),
                "downloadUri": z.string().url().describe(
                  "The absolute URI from which the translation metadata can be downloaded.",
                ).optional(),
                "informationUri": z.string().url().describe(
                  "The absolute URI from which information related to the translation metadata can be downloaded.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Provides additional metadata related to translation.",
              ).optional(),
              "supportedTaxonomies": z.array(
                z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ),
              ).min(0).describe(
                "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A component, such as a plug-in or the driver, of the analysis tool that was run.",
            ),
          ).min(0).describe(
            "Tool extensions that contributed to or reconfigured the analysis tool that was run.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe("The analysis tool that was run."),
        "invocation": z.object({
          "commandLine": z.string().describe(
            "The command line used to invoke the tool.",
          ).optional(),
          "arguments": z.array(z.string()).min(0).describe(
            "An array of strings, containing in order the command line arguments passed to the tool from the operating system.",
          ).optional(),
          "responseFiles": z.array(
            z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact."),
          ).min(0).describe(
            "The locations of any response files specified on the tool's command line.",
          ).optional(),
          "startTimeUtc": z.string().datetime({ offset: true }).describe(
            'The Coordinated Universal Time (UTC) date and time at which the run started. See "Date/time properties" in the SARIF spec for the required format.',
          ).optional(),
          "endTimeUtc": z.string().datetime({ offset: true }).describe(
            'The Coordinated Universal Time (UTC) date and time at which the run ended. See "Date/time properties" in the SARIF spec for the required format.',
          ).optional(),
          "exitCode": z.number().int().describe("The process exit code.")
            .optional(),
          "ruleConfigurationOverrides": z.array(
            z.object({
              "configuration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Information about how a specific rule or notification was reconfigured at runtime.",
            ),
          ).min(0).describe(
            "An array of configurationOverride objects that describe rules related runtime overrides.",
          ).default([]),
          "notificationConfigurationOverrides": z.array(
            z.object({
              "configuration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Information about how a specific rule or notification was reconfigured at runtime.",
            ),
          ).min(0).describe(
            "An array of configurationOverride objects that describe notifications related runtime overrides.",
          ).default([]),
          "toolExecutionNotifications": z.array(
            z.object({
              "locations": z.array(
                z.object({
                  "id": z.number().int().gte(-1).describe(
                    "Value that distinguishes this location from all other locations within a single result object.",
                  ).default(-1),
                  "physicalLocation": z.object({
                    "address": z.object({
                      "absoluteAddress": z.number().int().gte(-1).describe(
                        "The address expressed as a byte offset from the start of the addressable region.",
                      ).default(-1),
                      "relativeAddress": z.number().int().describe(
                        "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                      ).optional(),
                      "length": z.number().int().describe(
                        "The number of bytes in this range of addresses.",
                      ).optional(),
                      "kind": z.string().describe(
                        "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                      ).optional(),
                      "name": z.string().describe(
                        "A name that is associated with the address, e.g., '.text'.",
                      ).optional(),
                      "fullyQualifiedName": z.string().describe(
                        "A human-readable fully qualified name that is associated with the address.",
                      ).optional(),
                      "offsetFromParent": z.number().int().describe(
                        "The byte offset of this address from the absolute or relative address of the parent object.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the cached object for this address.",
                      ).default(-1),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the parent object.",
                      ).default(-1),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                    ).optional(),
                    "artifactLocation": z.object({
                      "uri": z.string().describe(
                        "A string containing a valid relative or absolute URI.",
                      ).optional(),
                      "uriBaseId": z.string().describe(
                        'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the run artifacts array of the artifact object associated with the artifact location.",
                      ).default(-1),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Specifies the location of an artifact.",
                    ).optional(),
                    "region": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "contextRegion": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                  ).optional(),
                  "logicalLocations": z.array(
                    z.object({
                      "name": z.string().describe(
                        "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the logical locations array.",
                      ).default(-1),
                      "fullyQualifiedName": z.string().describe(
                        "The human-readable fully qualified name of the logical location.",
                      ).optional(),
                      "decoratedName": z.string().describe(
                        "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                      ).optional(),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                      ).default(-1),
                      "kind": z.string().describe(
                        "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A logical location of a construct that produced a result.",
                    ),
                  ).min(0).describe(
                    "The logical locations associated with the result.",
                  ).default([]),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "annotations": z.array(
                    z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ),
                  ).min(0).describe(
                    "A set of regions relevant to the location.",
                  ).default([]),
                  "relationships": z.array(
                    z.object({
                      "target": z.number().int().gte(0).describe(
                        "A reference to the related location.",
                      ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one location to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this location and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A location within a programming artifact.",
                ),
              ).min(0).describe("The locations relevant to this notification.")
                .default([]),
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ),
              "level": z.enum(["none", "note", "warning", "error"]).describe(
                "A value specifying the severity level of the notification.",
              ).default("warning"),
              "threadId": z.number().int().describe(
                "The thread identifier of the code that generated the notification.",
              ).optional(),
              "timeUtc": z.string().datetime({ offset: true }).describe(
                "The Coordinated Universal Time (UTC) date and time at which the analysis tool generated the notification.",
              ).optional(),
              "exception": z.object({
                "kind": z.string().describe(
                  "A string that identifies the kind of exception, for example, the fully qualified type name of an object that was thrown, or the symbolic name of a signal.",
                ).optional(),
                "message": z.string().describe(
                  "A message that describes the exception.",
                ).optional(),
                "stack": z.object({
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "frames": z.array(
                    z.object({
                      "location": z.object({
                        "id": z.number().int().gte(-1).describe(
                          "Value that distinguishes this location from all other locations within a single result object.",
                        ).default(-1),
                        "physicalLocation": z.object({
                          "address": z.object({
                            "absoluteAddress": z.number().int().gte(-1)
                              .describe(
                                "The address expressed as a byte offset from the start of the addressable region.",
                              ).default(-1),
                            "relativeAddress": z.number().int().describe(
                              "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                            ).optional(),
                            "length": z.number().int().describe(
                              "The number of bytes in this range of addresses.",
                            ).optional(),
                            "kind": z.string().describe(
                              "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                            ).optional(),
                            "name": z.string().describe(
                              "A name that is associated with the address, e.g., '.text'.",
                            ).optional(),
                            "fullyQualifiedName": z.string().describe(
                              "A human-readable fully qualified name that is associated with the address.",
                            ).optional(),
                            "offsetFromParent": z.number().int().describe(
                              "The byte offset of this address from the absolute or relative address of the parent object.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the cached object for this address.",
                            ).default(-1),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the parent object.",
                            ).default(-1),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                          ).optional(),
                          "artifactLocation": z.object({
                            "uri": z.string().describe(
                              "A string containing a valid relative or absolute URI.",
                            ).optional(),
                            "uriBaseId": z.string().describe(
                              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the run artifacts array of the artifact object associated with the artifact location.",
                            ).default(-1),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Specifies the location of an artifact.",
                          ).optional(),
                          "region": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "contextRegion": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                        ).optional(),
                        "logicalLocations": z.array(
                          z.object({
                            "name": z.string().describe(
                              "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the logical locations array.",
                            ).default(-1),
                            "fullyQualifiedName": z.string().describe(
                              "The human-readable fully qualified name of the logical location.",
                            ).optional(),
                            "decoratedName": z.string().describe(
                              "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                            ).optional(),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                            ).default(-1),
                            "kind": z.string().describe(
                              "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A logical location of a construct that produced a result.",
                          ),
                        ).min(0).describe(
                          "The logical locations associated with the result.",
                        ).default([]),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "annotations": z.array(
                          z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ),
                        ).min(0).describe(
                          "A set of regions relevant to the location.",
                        ).default([]),
                        "relationships": z.array(
                          z.object({
                            "target": z.number().int().gte(0).describe(
                              "A reference to the related location.",
                            ),
                            "kinds": z.array(z.string()).describe(
                              "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                            ).default(["relevant"]),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Information about the relation of one location to another.",
                          ),
                        ).min(0).describe(
                          "An array of objects that describe relationships between this location and others.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A location within a programming artifact.",
                      ).optional(),
                      "module": z.string().describe(
                        "The name of the module that contains the code of this stack frame.",
                      ).optional(),
                      "threadId": z.number().int().describe(
                        "The thread identifier of the stack frame.",
                      ).optional(),
                      "parameters": z.array(z.string().default([])).min(0)
                        .describe(
                          "The parameters of the call that is executing.",
                        ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A function call within a stack trace.",
                    ),
                  ).min(0).describe(
                    "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A call stack that is relevant to a result.",
                ).optional(),
                "innerExceptions": z.array(z.any()).min(0).describe(
                  "An array of exception objects each of which is considered a cause of this exception.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Describes a runtime exception encountered during the execution of an analysis tool.",
              ).optional(),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "associatedRule": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Describes a condition relevant to the tool itself, as opposed to being relevant to a target being analyzed by the tool.",
            ),
          ).min(0).describe(
            "A list of runtime conditions detected by the tool during the analysis.",
          ).default([]),
          "toolConfigurationNotifications": z.array(
            z.object({
              "locations": z.array(
                z.object({
                  "id": z.number().int().gte(-1).describe(
                    "Value that distinguishes this location from all other locations within a single result object.",
                  ).default(-1),
                  "physicalLocation": z.object({
                    "address": z.object({
                      "absoluteAddress": z.number().int().gte(-1).describe(
                        "The address expressed as a byte offset from the start of the addressable region.",
                      ).default(-1),
                      "relativeAddress": z.number().int().describe(
                        "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                      ).optional(),
                      "length": z.number().int().describe(
                        "The number of bytes in this range of addresses.",
                      ).optional(),
                      "kind": z.string().describe(
                        "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                      ).optional(),
                      "name": z.string().describe(
                        "A name that is associated with the address, e.g., '.text'.",
                      ).optional(),
                      "fullyQualifiedName": z.string().describe(
                        "A human-readable fully qualified name that is associated with the address.",
                      ).optional(),
                      "offsetFromParent": z.number().int().describe(
                        "The byte offset of this address from the absolute or relative address of the parent object.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the cached object for this address.",
                      ).default(-1),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the parent object.",
                      ).default(-1),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                    ).optional(),
                    "artifactLocation": z.object({
                      "uri": z.string().describe(
                        "A string containing a valid relative or absolute URI.",
                      ).optional(),
                      "uriBaseId": z.string().describe(
                        'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the run artifacts array of the artifact object associated with the artifact location.",
                      ).default(-1),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Specifies the location of an artifact.",
                    ).optional(),
                    "region": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "contextRegion": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                  ).optional(),
                  "logicalLocations": z.array(
                    z.object({
                      "name": z.string().describe(
                        "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the logical locations array.",
                      ).default(-1),
                      "fullyQualifiedName": z.string().describe(
                        "The human-readable fully qualified name of the logical location.",
                      ).optional(),
                      "decoratedName": z.string().describe(
                        "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                      ).optional(),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                      ).default(-1),
                      "kind": z.string().describe(
                        "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A logical location of a construct that produced a result.",
                    ),
                  ).min(0).describe(
                    "The logical locations associated with the result.",
                  ).default([]),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "annotations": z.array(
                    z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ),
                  ).min(0).describe(
                    "A set of regions relevant to the location.",
                  ).default([]),
                  "relationships": z.array(
                    z.object({
                      "target": z.number().int().gte(0).describe(
                        "A reference to the related location.",
                      ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one location to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this location and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A location within a programming artifact.",
                ),
              ).min(0).describe("The locations relevant to this notification.")
                .default([]),
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ),
              "level": z.enum(["none", "note", "warning", "error"]).describe(
                "A value specifying the severity level of the notification.",
              ).default("warning"),
              "threadId": z.number().int().describe(
                "The thread identifier of the code that generated the notification.",
              ).optional(),
              "timeUtc": z.string().datetime({ offset: true }).describe(
                "The Coordinated Universal Time (UTC) date and time at which the analysis tool generated the notification.",
              ).optional(),
              "exception": z.object({
                "kind": z.string().describe(
                  "A string that identifies the kind of exception, for example, the fully qualified type name of an object that was thrown, or the symbolic name of a signal.",
                ).optional(),
                "message": z.string().describe(
                  "A message that describes the exception.",
                ).optional(),
                "stack": z.object({
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "frames": z.array(
                    z.object({
                      "location": z.object({
                        "id": z.number().int().gte(-1).describe(
                          "Value that distinguishes this location from all other locations within a single result object.",
                        ).default(-1),
                        "physicalLocation": z.object({
                          "address": z.object({
                            "absoluteAddress": z.number().int().gte(-1)
                              .describe(
                                "The address expressed as a byte offset from the start of the addressable region.",
                              ).default(-1),
                            "relativeAddress": z.number().int().describe(
                              "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                            ).optional(),
                            "length": z.number().int().describe(
                              "The number of bytes in this range of addresses.",
                            ).optional(),
                            "kind": z.string().describe(
                              "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                            ).optional(),
                            "name": z.string().describe(
                              "A name that is associated with the address, e.g., '.text'.",
                            ).optional(),
                            "fullyQualifiedName": z.string().describe(
                              "A human-readable fully qualified name that is associated with the address.",
                            ).optional(),
                            "offsetFromParent": z.number().int().describe(
                              "The byte offset of this address from the absolute or relative address of the parent object.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the cached object for this address.",
                            ).default(-1),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the parent object.",
                            ).default(-1),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                          ).optional(),
                          "artifactLocation": z.object({
                            "uri": z.string().describe(
                              "A string containing a valid relative or absolute URI.",
                            ).optional(),
                            "uriBaseId": z.string().describe(
                              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the run artifacts array of the artifact object associated with the artifact location.",
                            ).default(-1),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Specifies the location of an artifact.",
                          ).optional(),
                          "region": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "contextRegion": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                        ).optional(),
                        "logicalLocations": z.array(
                          z.object({
                            "name": z.string().describe(
                              "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the logical locations array.",
                            ).default(-1),
                            "fullyQualifiedName": z.string().describe(
                              "The human-readable fully qualified name of the logical location.",
                            ).optional(),
                            "decoratedName": z.string().describe(
                              "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                            ).optional(),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                            ).default(-1),
                            "kind": z.string().describe(
                              "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A logical location of a construct that produced a result.",
                          ),
                        ).min(0).describe(
                          "The logical locations associated with the result.",
                        ).default([]),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "annotations": z.array(
                          z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ),
                        ).min(0).describe(
                          "A set of regions relevant to the location.",
                        ).default([]),
                        "relationships": z.array(
                          z.object({
                            "target": z.number().int().gte(0).describe(
                              "A reference to the related location.",
                            ),
                            "kinds": z.array(z.string()).describe(
                              "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                            ).default(["relevant"]),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Information about the relation of one location to another.",
                          ),
                        ).min(0).describe(
                          "An array of objects that describe relationships between this location and others.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A location within a programming artifact.",
                      ).optional(),
                      "module": z.string().describe(
                        "The name of the module that contains the code of this stack frame.",
                      ).optional(),
                      "threadId": z.number().int().describe(
                        "The thread identifier of the stack frame.",
                      ).optional(),
                      "parameters": z.array(z.string().default([])).min(0)
                        .describe(
                          "The parameters of the call that is executing.",
                        ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A function call within a stack trace.",
                    ),
                  ).min(0).describe(
                    "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A call stack that is relevant to a result.",
                ).optional(),
                "innerExceptions": z.array(z.any()).min(0).describe(
                  "An array of exception objects each of which is considered a cause of this exception.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Describes a runtime exception encountered during the execution of an analysis tool.",
              ).optional(),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "associatedRule": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Describes a condition relevant to the tool itself, as opposed to being relevant to a target being analyzed by the tool.",
            ),
          ).min(0).describe(
            "A list of conditions detected by the tool that are relevant to the tool's configuration.",
          ).default([]),
          "exitCodeDescription": z.string().describe(
            "The reason for the process exit.",
          ).optional(),
          "exitSignalName": z.string().describe(
            "The name of the signal that caused the process to exit.",
          ).optional(),
          "exitSignalNumber": z.number().int().describe(
            "The numeric value of the signal that caused the process to exit.",
          ).optional(),
          "processStartFailureMessage": z.string().describe(
            "The reason given by the operating system that the process failed to start.",
          ).optional(),
          "executionSuccessful": z.boolean().describe(
            "Specifies whether the tool's execution completed successfully.",
          ),
          "machine": z.string().describe(
            "The machine that hosted the analysis tool run.",
          ).optional(),
          "account": z.string().describe(
            "The account that ran the analysis tool.",
          ).optional(),
          "processId": z.number().int().describe(
            "The process id for the analysis tool run.",
          ).optional(),
          "executableLocation": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "workingDirectory": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "environmentVariables": z.record(z.string()).describe(
            "The environment variables associated with the analysis tool process, expressed as key/value pairs.",
          ).optional(),
          "stdin": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "stdout": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "stderr": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "stdoutStderr": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "The runtime environment of the analysis tool run.",
        ).optional(),
        "analysisToolLogFiles": z.array(
          z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact."),
        ).min(0).describe(
          "The locations of the analysis tool's per-run log files.",
        ).default([]),
        "properties": z.object({
          "tags": z.array(z.string()).min(0).describe(
            "A set of distinct strings that provide additional information.",
          ).default([]),
        }).catchall(z.any()).describe(
          "Key/value pairs that provide additional information about the object.",
        ).optional(),
      }).strict().describe(
        "Describes how a converter transformed the output of a static analysis tool from the analysis tool's native output format into the SARIF format.",
      ).optional(),
      "graphs": z.array(
        z.object({
          "description": z.object({
            "text": z.string().describe("A plain text message string.")
              .optional(),
            "markdown": z.string().describe("A Markdown message string.")
              .optional(),
            "id": z.string().describe("The identifier for this message.")
              .optional(),
            "arguments": z.array(z.string()).min(0).describe(
              "An array of strings to substitute into the message string.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Encapsulates a message intended to be read by the end user.",
          ).optional(),
          "nodes": z.array(
            z.object({
              "id": z.string().describe(
                "A string that uniquely identifies the node within its graph.",
              ),
              "label": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "location": z.object({
                "id": z.number().int().gte(-1).describe(
                  "Value that distinguishes this location from all other locations within a single result object.",
                ).default(-1),
                "physicalLocation": z.object({
                  "address": z.object({
                    "absoluteAddress": z.number().int().gte(-1).describe(
                      "The address expressed as a byte offset from the start of the addressable region.",
                    ).default(-1),
                    "relativeAddress": z.number().int().describe(
                      "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                    ).optional(),
                    "length": z.number().int().describe(
                      "The number of bytes in this range of addresses.",
                    ).optional(),
                    "kind": z.string().describe(
                      "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                    ).optional(),
                    "name": z.string().describe(
                      "A name that is associated with the address, e.g., '.text'.",
                    ).optional(),
                    "fullyQualifiedName": z.string().describe(
                      "A human-readable fully qualified name that is associated with the address.",
                    ).optional(),
                    "offsetFromParent": z.number().int().describe(
                      "The byte offset of this address from the absolute or relative address of the parent object.",
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within run.addresses of the cached object for this address.",
                    ).default(-1),
                    "parentIndex": z.number().int().gte(-1).describe(
                      "The index within run.addresses of the parent object.",
                    ).default(-1),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                  ).optional(),
                  "artifactLocation": z.object({
                    "uri": z.string().describe(
                      "A string containing a valid relative or absolute URI.",
                    ).optional(),
                    "uriBaseId": z.string().describe(
                      'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within the run artifacts array of the artifact object associated with the artifact location.",
                    ).default(-1),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe("Specifies the location of an artifact.")
                    .optional(),
                  "region": z.object({
                    "startLine": z.number().int().gte(1).describe(
                      "The line number of the first character in the region.",
                    ).optional(),
                    "startColumn": z.number().int().gte(1).describe(
                      "The column number of the first character in the region.",
                    ).optional(),
                    "endLine": z.number().int().gte(1).describe(
                      "The line number of the last character in the region.",
                    ).optional(),
                    "endColumn": z.number().int().gte(1).describe(
                      "The column number of the character following the end of the region.",
                    ).optional(),
                    "charOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                    ).default(-1),
                    "charLength": z.number().int().gte(0).describe(
                      "The length of the region in characters.",
                    ).optional(),
                    "byteOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                    ).default(-1),
                    "byteLength": z.number().int().gte(0).describe(
                      "The length of the region in bytes.",
                    ).optional(),
                    "snippet": z.object({
                      "text": z.string().describe(
                        "UTF-8-encoded content from a text artifact.",
                      ).optional(),
                      "binary": z.string().describe(
                        "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                      ).optional(),
                      "rendered": z.object({
                        "text": z.string().describe(
                          "A plain text message string or format string.",
                        ),
                        "markdown": z.string().describe(
                          "A Markdown message string or format string.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A message string or message format string rendered in multiple formats.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Represents the contents of an artifact.",
                    ).optional(),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "sourceLanguage": z.string().describe(
                      "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A region within an artifact where a result was detected.",
                  ).optional(),
                  "contextRegion": z.object({
                    "startLine": z.number().int().gte(1).describe(
                      "The line number of the first character in the region.",
                    ).optional(),
                    "startColumn": z.number().int().gte(1).describe(
                      "The column number of the first character in the region.",
                    ).optional(),
                    "endLine": z.number().int().gte(1).describe(
                      "The line number of the last character in the region.",
                    ).optional(),
                    "endColumn": z.number().int().gte(1).describe(
                      "The column number of the character following the end of the region.",
                    ).optional(),
                    "charOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                    ).default(-1),
                    "charLength": z.number().int().gte(0).describe(
                      "The length of the region in characters.",
                    ).optional(),
                    "byteOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                    ).default(-1),
                    "byteLength": z.number().int().gte(0).describe(
                      "The length of the region in bytes.",
                    ).optional(),
                    "snippet": z.object({
                      "text": z.string().describe(
                        "UTF-8-encoded content from a text artifact.",
                      ).optional(),
                      "binary": z.string().describe(
                        "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                      ).optional(),
                      "rendered": z.object({
                        "text": z.string().describe(
                          "A plain text message string or format string.",
                        ),
                        "markdown": z.string().describe(
                          "A Markdown message string or format string.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A message string or message format string rendered in multiple formats.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Represents the contents of an artifact.",
                    ).optional(),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "sourceLanguage": z.string().describe(
                      "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A region within an artifact where a result was detected.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                ).optional(),
                "logicalLocations": z.array(
                  z.object({
                    "name": z.string().describe(
                      "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within the logical locations array.",
                    ).default(-1),
                    "fullyQualifiedName": z.string().describe(
                      "The human-readable fully qualified name of the logical location.",
                    ).optional(),
                    "decoratedName": z.string().describe(
                      "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                    ).optional(),
                    "parentIndex": z.number().int().gte(-1).describe(
                      "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                    ).default(-1),
                    "kind": z.string().describe(
                      "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A logical location of a construct that produced a result.",
                  ),
                ).min(0).describe(
                  "The logical locations associated with the result.",
                ).default([]),
                "message": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "annotations": z.array(
                  z.object({
                    "startLine": z.number().int().gte(1).describe(
                      "The line number of the first character in the region.",
                    ).optional(),
                    "startColumn": z.number().int().gte(1).describe(
                      "The column number of the first character in the region.",
                    ).optional(),
                    "endLine": z.number().int().gte(1).describe(
                      "The line number of the last character in the region.",
                    ).optional(),
                    "endColumn": z.number().int().gte(1).describe(
                      "The column number of the character following the end of the region.",
                    ).optional(),
                    "charOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                    ).default(-1),
                    "charLength": z.number().int().gte(0).describe(
                      "The length of the region in characters.",
                    ).optional(),
                    "byteOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                    ).default(-1),
                    "byteLength": z.number().int().gte(0).describe(
                      "The length of the region in bytes.",
                    ).optional(),
                    "snippet": z.object({
                      "text": z.string().describe(
                        "UTF-8-encoded content from a text artifact.",
                      ).optional(),
                      "binary": z.string().describe(
                        "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                      ).optional(),
                      "rendered": z.object({
                        "text": z.string().describe(
                          "A plain text message string or format string.",
                        ),
                        "markdown": z.string().describe(
                          "A Markdown message string or format string.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A message string or message format string rendered in multiple formats.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Represents the contents of an artifact.",
                    ).optional(),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "sourceLanguage": z.string().describe(
                      "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A region within an artifact where a result was detected.",
                  ),
                ).min(0).describe("A set of regions relevant to the location.")
                  .default([]),
                "relationships": z.array(
                  z.object({
                    "target": z.number().int().gte(0).describe(
                      "A reference to the related location.",
                    ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one location to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this location and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("A location within a programming artifact.")
                .optional(),
              "children": z.array(z.any()).min(0).describe(
                "Array of child nodes.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Represents a node in a graph."),
          ).min(0).describe(
            "An array of node objects representing the nodes of the graph.",
          ).default([]),
          "edges": z.array(
            z.object({
              "id": z.string().describe(
                "A string that uniquely identifies the edge within its graph.",
              ),
              "label": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "sourceNodeId": z.string().describe(
                "Identifies the source node (the node at which the edge starts).",
              ),
              "targetNodeId": z.string().describe(
                "Identifies the target node (the node at which the edge ends).",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Represents a directed edge in a graph."),
          ).min(0).describe(
            "An array of edge objects representing the edges of the graph.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A network of nodes and directed edges that describes some aspect of the structure of the code (for example, a call graph).",
        ),
      ).min(0).describe(
        "An array of graph objects that will be merged with a separate run.",
      ).default([]),
      "externalizedProperties": z.object({
        "tags": z.array(z.string()).min(0).describe(
          "A set of distinct strings that provide additional information.",
        ).default([]),
      }).catchall(z.any()).describe(
        "Key/value pairs that provide additional information about the object.",
      ).optional(),
      "artifacts": z.array(
        z.object({
          "description": z.object({
            "text": z.string().describe("A plain text message string.")
              .optional(),
            "markdown": z.string().describe("A Markdown message string.")
              .optional(),
            "id": z.string().describe("The identifier for this message.")
              .optional(),
            "arguments": z.array(z.string()).min(0).describe(
              "An array of strings to substitute into the message string.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Encapsulates a message intended to be read by the end user.",
          ).optional(),
          "location": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "parentIndex": z.number().int().gte(-1).describe(
            "Identifies the index of the immediate parent of the artifact, if this artifact is nested.",
          ).default(-1),
          "offset": z.number().int().gte(0).describe(
            "The offset in bytes of the artifact within its containing artifact.",
          ).optional(),
          "length": z.number().int().gte(-1).describe(
            "The length of the artifact in bytes.",
          ).default(-1),
          "roles": z.array(
            z.enum([
              "analysisTarget",
              "attachment",
              "responseFile",
              "resultFile",
              "standardStream",
              "tracedFile",
              "unmodified",
              "modified",
              "added",
              "deleted",
              "renamed",
              "uncontrolled",
              "driver",
              "extension",
              "translation",
              "taxonomy",
              "policy",
              "referencedOnCommandLine",
              "memoryContents",
              "directory",
              "userSpecifiedConfiguration",
              "toolSpecifiedConfiguration",
              "debugOutputFile",
            ]),
          ).min(0).describe(
            "The role or roles played by the artifact in the analysis.",
          ).default([]),
          "mimeType": z.string().regex(new RegExp("[^/]+/.+")).describe(
            "The MIME type (RFC 2045) of the artifact.",
          ).optional(),
          "contents": z.object({
            "text": z.string().describe(
              "UTF-8-encoded content from a text artifact.",
            ).optional(),
            "binary": z.string().describe(
              "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
            ).optional(),
            "rendered": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Represents the contents of an artifact.")
            .optional(),
          "encoding": z.string().describe(
            "Specifies the encoding for an artifact object that refers to a text file.",
          ).optional(),
          "sourceLanguage": z.string().describe(
            "Specifies the source language for any artifact object that refers to a text file that contains source code.",
          ).optional(),
          "hashes": z.record(z.string()).describe(
            "A dictionary, each of whose keys is the name of a hash function and each of whose values is the hashed value of the artifact produced by the specified hash function.",
          ).optional(),
          "lastModifiedTimeUtc": z.string().datetime({ offset: true }).describe(
            'The Coordinated Universal Time (UTC) date and time at which the artifact was most recently modified. See "Date/time properties" in the SARIF spec for the required format.',
          ).optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A single artifact. In some cases, this artifact might be nested within another artifact.",
        ),
      ).min(0).describe(
        "An array of artifact objects that will be merged with a separate run.",
      ).optional(),
      "invocations": z.array(
        z.object({
          "commandLine": z.string().describe(
            "The command line used to invoke the tool.",
          ).optional(),
          "arguments": z.array(z.string()).min(0).describe(
            "An array of strings, containing in order the command line arguments passed to the tool from the operating system.",
          ).optional(),
          "responseFiles": z.array(
            z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact."),
          ).min(0).describe(
            "The locations of any response files specified on the tool's command line.",
          ).optional(),
          "startTimeUtc": z.string().datetime({ offset: true }).describe(
            'The Coordinated Universal Time (UTC) date and time at which the run started. See "Date/time properties" in the SARIF spec for the required format.',
          ).optional(),
          "endTimeUtc": z.string().datetime({ offset: true }).describe(
            'The Coordinated Universal Time (UTC) date and time at which the run ended. See "Date/time properties" in the SARIF spec for the required format.',
          ).optional(),
          "exitCode": z.number().int().describe("The process exit code.")
            .optional(),
          "ruleConfigurationOverrides": z.array(
            z.object({
              "configuration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Information about how a specific rule or notification was reconfigured at runtime.",
            ),
          ).min(0).describe(
            "An array of configurationOverride objects that describe rules related runtime overrides.",
          ).default([]),
          "notificationConfigurationOverrides": z.array(
            z.object({
              "configuration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Information about how a specific rule or notification was reconfigured at runtime.",
            ),
          ).min(0).describe(
            "An array of configurationOverride objects that describe notifications related runtime overrides.",
          ).default([]),
          "toolExecutionNotifications": z.array(
            z.object({
              "locations": z.array(
                z.object({
                  "id": z.number().int().gte(-1).describe(
                    "Value that distinguishes this location from all other locations within a single result object.",
                  ).default(-1),
                  "physicalLocation": z.object({
                    "address": z.object({
                      "absoluteAddress": z.number().int().gte(-1).describe(
                        "The address expressed as a byte offset from the start of the addressable region.",
                      ).default(-1),
                      "relativeAddress": z.number().int().describe(
                        "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                      ).optional(),
                      "length": z.number().int().describe(
                        "The number of bytes in this range of addresses.",
                      ).optional(),
                      "kind": z.string().describe(
                        "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                      ).optional(),
                      "name": z.string().describe(
                        "A name that is associated with the address, e.g., '.text'.",
                      ).optional(),
                      "fullyQualifiedName": z.string().describe(
                        "A human-readable fully qualified name that is associated with the address.",
                      ).optional(),
                      "offsetFromParent": z.number().int().describe(
                        "The byte offset of this address from the absolute or relative address of the parent object.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the cached object for this address.",
                      ).default(-1),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the parent object.",
                      ).default(-1),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                    ).optional(),
                    "artifactLocation": z.object({
                      "uri": z.string().describe(
                        "A string containing a valid relative or absolute URI.",
                      ).optional(),
                      "uriBaseId": z.string().describe(
                        'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the run artifacts array of the artifact object associated with the artifact location.",
                      ).default(-1),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Specifies the location of an artifact.",
                    ).optional(),
                    "region": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "contextRegion": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                  ).optional(),
                  "logicalLocations": z.array(
                    z.object({
                      "name": z.string().describe(
                        "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the logical locations array.",
                      ).default(-1),
                      "fullyQualifiedName": z.string().describe(
                        "The human-readable fully qualified name of the logical location.",
                      ).optional(),
                      "decoratedName": z.string().describe(
                        "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                      ).optional(),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                      ).default(-1),
                      "kind": z.string().describe(
                        "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A logical location of a construct that produced a result.",
                    ),
                  ).min(0).describe(
                    "The logical locations associated with the result.",
                  ).default([]),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "annotations": z.array(
                    z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ),
                  ).min(0).describe(
                    "A set of regions relevant to the location.",
                  ).default([]),
                  "relationships": z.array(
                    z.object({
                      "target": z.number().int().gte(0).describe(
                        "A reference to the related location.",
                      ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one location to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this location and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A location within a programming artifact.",
                ),
              ).min(0).describe("The locations relevant to this notification.")
                .default([]),
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ),
              "level": z.enum(["none", "note", "warning", "error"]).describe(
                "A value specifying the severity level of the notification.",
              ).default("warning"),
              "threadId": z.number().int().describe(
                "The thread identifier of the code that generated the notification.",
              ).optional(),
              "timeUtc": z.string().datetime({ offset: true }).describe(
                "The Coordinated Universal Time (UTC) date and time at which the analysis tool generated the notification.",
              ).optional(),
              "exception": z.object({
                "kind": z.string().describe(
                  "A string that identifies the kind of exception, for example, the fully qualified type name of an object that was thrown, or the symbolic name of a signal.",
                ).optional(),
                "message": z.string().describe(
                  "A message that describes the exception.",
                ).optional(),
                "stack": z.object({
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "frames": z.array(
                    z.object({
                      "location": z.object({
                        "id": z.number().int().gte(-1).describe(
                          "Value that distinguishes this location from all other locations within a single result object.",
                        ).default(-1),
                        "physicalLocation": z.object({
                          "address": z.object({
                            "absoluteAddress": z.number().int().gte(-1)
                              .describe(
                                "The address expressed as a byte offset from the start of the addressable region.",
                              ).default(-1),
                            "relativeAddress": z.number().int().describe(
                              "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                            ).optional(),
                            "length": z.number().int().describe(
                              "The number of bytes in this range of addresses.",
                            ).optional(),
                            "kind": z.string().describe(
                              "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                            ).optional(),
                            "name": z.string().describe(
                              "A name that is associated with the address, e.g., '.text'.",
                            ).optional(),
                            "fullyQualifiedName": z.string().describe(
                              "A human-readable fully qualified name that is associated with the address.",
                            ).optional(),
                            "offsetFromParent": z.number().int().describe(
                              "The byte offset of this address from the absolute or relative address of the parent object.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the cached object for this address.",
                            ).default(-1),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the parent object.",
                            ).default(-1),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                          ).optional(),
                          "artifactLocation": z.object({
                            "uri": z.string().describe(
                              "A string containing a valid relative or absolute URI.",
                            ).optional(),
                            "uriBaseId": z.string().describe(
                              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the run artifacts array of the artifact object associated with the artifact location.",
                            ).default(-1),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Specifies the location of an artifact.",
                          ).optional(),
                          "region": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "contextRegion": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                        ).optional(),
                        "logicalLocations": z.array(
                          z.object({
                            "name": z.string().describe(
                              "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the logical locations array.",
                            ).default(-1),
                            "fullyQualifiedName": z.string().describe(
                              "The human-readable fully qualified name of the logical location.",
                            ).optional(),
                            "decoratedName": z.string().describe(
                              "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                            ).optional(),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                            ).default(-1),
                            "kind": z.string().describe(
                              "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A logical location of a construct that produced a result.",
                          ),
                        ).min(0).describe(
                          "The logical locations associated with the result.",
                        ).default([]),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "annotations": z.array(
                          z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ),
                        ).min(0).describe(
                          "A set of regions relevant to the location.",
                        ).default([]),
                        "relationships": z.array(
                          z.object({
                            "target": z.number().int().gte(0).describe(
                              "A reference to the related location.",
                            ),
                            "kinds": z.array(z.string()).describe(
                              "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                            ).default(["relevant"]),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Information about the relation of one location to another.",
                          ),
                        ).min(0).describe(
                          "An array of objects that describe relationships between this location and others.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A location within a programming artifact.",
                      ).optional(),
                      "module": z.string().describe(
                        "The name of the module that contains the code of this stack frame.",
                      ).optional(),
                      "threadId": z.number().int().describe(
                        "The thread identifier of the stack frame.",
                      ).optional(),
                      "parameters": z.array(z.string().default([])).min(0)
                        .describe(
                          "The parameters of the call that is executing.",
                        ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A function call within a stack trace.",
                    ),
                  ).min(0).describe(
                    "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A call stack that is relevant to a result.",
                ).optional(),
                "innerExceptions": z.array(z.any()).min(0).describe(
                  "An array of exception objects each of which is considered a cause of this exception.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Describes a runtime exception encountered during the execution of an analysis tool.",
              ).optional(),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "associatedRule": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Describes a condition relevant to the tool itself, as opposed to being relevant to a target being analyzed by the tool.",
            ),
          ).min(0).describe(
            "A list of runtime conditions detected by the tool during the analysis.",
          ).default([]),
          "toolConfigurationNotifications": z.array(
            z.object({
              "locations": z.array(
                z.object({
                  "id": z.number().int().gte(-1).describe(
                    "Value that distinguishes this location from all other locations within a single result object.",
                  ).default(-1),
                  "physicalLocation": z.object({
                    "address": z.object({
                      "absoluteAddress": z.number().int().gte(-1).describe(
                        "The address expressed as a byte offset from the start of the addressable region.",
                      ).default(-1),
                      "relativeAddress": z.number().int().describe(
                        "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                      ).optional(),
                      "length": z.number().int().describe(
                        "The number of bytes in this range of addresses.",
                      ).optional(),
                      "kind": z.string().describe(
                        "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                      ).optional(),
                      "name": z.string().describe(
                        "A name that is associated with the address, e.g., '.text'.",
                      ).optional(),
                      "fullyQualifiedName": z.string().describe(
                        "A human-readable fully qualified name that is associated with the address.",
                      ).optional(),
                      "offsetFromParent": z.number().int().describe(
                        "The byte offset of this address from the absolute or relative address of the parent object.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the cached object for this address.",
                      ).default(-1),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the parent object.",
                      ).default(-1),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                    ).optional(),
                    "artifactLocation": z.object({
                      "uri": z.string().describe(
                        "A string containing a valid relative or absolute URI.",
                      ).optional(),
                      "uriBaseId": z.string().describe(
                        'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the run artifacts array of the artifact object associated with the artifact location.",
                      ).default(-1),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Specifies the location of an artifact.",
                    ).optional(),
                    "region": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "contextRegion": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                  ).optional(),
                  "logicalLocations": z.array(
                    z.object({
                      "name": z.string().describe(
                        "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the logical locations array.",
                      ).default(-1),
                      "fullyQualifiedName": z.string().describe(
                        "The human-readable fully qualified name of the logical location.",
                      ).optional(),
                      "decoratedName": z.string().describe(
                        "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                      ).optional(),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                      ).default(-1),
                      "kind": z.string().describe(
                        "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A logical location of a construct that produced a result.",
                    ),
                  ).min(0).describe(
                    "The logical locations associated with the result.",
                  ).default([]),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "annotations": z.array(
                    z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ),
                  ).min(0).describe(
                    "A set of regions relevant to the location.",
                  ).default([]),
                  "relationships": z.array(
                    z.object({
                      "target": z.number().int().gte(0).describe(
                        "A reference to the related location.",
                      ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one location to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this location and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A location within a programming artifact.",
                ),
              ).min(0).describe("The locations relevant to this notification.")
                .default([]),
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ),
              "level": z.enum(["none", "note", "warning", "error"]).describe(
                "A value specifying the severity level of the notification.",
              ).default("warning"),
              "threadId": z.number().int().describe(
                "The thread identifier of the code that generated the notification.",
              ).optional(),
              "timeUtc": z.string().datetime({ offset: true }).describe(
                "The Coordinated Universal Time (UTC) date and time at which the analysis tool generated the notification.",
              ).optional(),
              "exception": z.object({
                "kind": z.string().describe(
                  "A string that identifies the kind of exception, for example, the fully qualified type name of an object that was thrown, or the symbolic name of a signal.",
                ).optional(),
                "message": z.string().describe(
                  "A message that describes the exception.",
                ).optional(),
                "stack": z.object({
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "frames": z.array(
                    z.object({
                      "location": z.object({
                        "id": z.number().int().gte(-1).describe(
                          "Value that distinguishes this location from all other locations within a single result object.",
                        ).default(-1),
                        "physicalLocation": z.object({
                          "address": z.object({
                            "absoluteAddress": z.number().int().gte(-1)
                              .describe(
                                "The address expressed as a byte offset from the start of the addressable region.",
                              ).default(-1),
                            "relativeAddress": z.number().int().describe(
                              "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                            ).optional(),
                            "length": z.number().int().describe(
                              "The number of bytes in this range of addresses.",
                            ).optional(),
                            "kind": z.string().describe(
                              "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                            ).optional(),
                            "name": z.string().describe(
                              "A name that is associated with the address, e.g., '.text'.",
                            ).optional(),
                            "fullyQualifiedName": z.string().describe(
                              "A human-readable fully qualified name that is associated with the address.",
                            ).optional(),
                            "offsetFromParent": z.number().int().describe(
                              "The byte offset of this address from the absolute or relative address of the parent object.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the cached object for this address.",
                            ).default(-1),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the parent object.",
                            ).default(-1),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                          ).optional(),
                          "artifactLocation": z.object({
                            "uri": z.string().describe(
                              "A string containing a valid relative or absolute URI.",
                            ).optional(),
                            "uriBaseId": z.string().describe(
                              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the run artifacts array of the artifact object associated with the artifact location.",
                            ).default(-1),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Specifies the location of an artifact.",
                          ).optional(),
                          "region": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "contextRegion": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                        ).optional(),
                        "logicalLocations": z.array(
                          z.object({
                            "name": z.string().describe(
                              "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the logical locations array.",
                            ).default(-1),
                            "fullyQualifiedName": z.string().describe(
                              "The human-readable fully qualified name of the logical location.",
                            ).optional(),
                            "decoratedName": z.string().describe(
                              "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                            ).optional(),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                            ).default(-1),
                            "kind": z.string().describe(
                              "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A logical location of a construct that produced a result.",
                          ),
                        ).min(0).describe(
                          "The logical locations associated with the result.",
                        ).default([]),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "annotations": z.array(
                          z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ),
                        ).min(0).describe(
                          "A set of regions relevant to the location.",
                        ).default([]),
                        "relationships": z.array(
                          z.object({
                            "target": z.number().int().gte(0).describe(
                              "A reference to the related location.",
                            ),
                            "kinds": z.array(z.string()).describe(
                              "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                            ).default(["relevant"]),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Information about the relation of one location to another.",
                          ),
                        ).min(0).describe(
                          "An array of objects that describe relationships between this location and others.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A location within a programming artifact.",
                      ).optional(),
                      "module": z.string().describe(
                        "The name of the module that contains the code of this stack frame.",
                      ).optional(),
                      "threadId": z.number().int().describe(
                        "The thread identifier of the stack frame.",
                      ).optional(),
                      "parameters": z.array(z.string().default([])).min(0)
                        .describe(
                          "The parameters of the call that is executing.",
                        ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A function call within a stack trace.",
                    ),
                  ).min(0).describe(
                    "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A call stack that is relevant to a result.",
                ).optional(),
                "innerExceptions": z.array(z.any()).min(0).describe(
                  "An array of exception objects each of which is considered a cause of this exception.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Describes a runtime exception encountered during the execution of an analysis tool.",
              ).optional(),
              "descriptor": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "associatedRule": z.object({
                "id": z.string().describe("The id of the descriptor.")
                  .optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe("A guid that uniquely identifies the descriptor.")
                  .optional(),
                "toolComponent": z.object({
                  "name": z.string().describe(
                    "The 'name' property of the referenced toolComponent.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "An index into the referenced toolComponent in tool.extensions.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe(
                    "The 'guid' property of the referenced toolComponent.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Identifies a particular toolComponent object, either the driver or an extension.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                "Information about how to locate a relevant reporting descriptor.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Describes a condition relevant to the tool itself, as opposed to being relevant to a target being analyzed by the tool.",
            ),
          ).min(0).describe(
            "A list of conditions detected by the tool that are relevant to the tool's configuration.",
          ).default([]),
          "exitCodeDescription": z.string().describe(
            "The reason for the process exit.",
          ).optional(),
          "exitSignalName": z.string().describe(
            "The name of the signal that caused the process to exit.",
          ).optional(),
          "exitSignalNumber": z.number().int().describe(
            "The numeric value of the signal that caused the process to exit.",
          ).optional(),
          "processStartFailureMessage": z.string().describe(
            "The reason given by the operating system that the process failed to start.",
          ).optional(),
          "executionSuccessful": z.boolean().describe(
            "Specifies whether the tool's execution completed successfully.",
          ),
          "machine": z.string().describe(
            "The machine that hosted the analysis tool run.",
          ).optional(),
          "account": z.string().describe(
            "The account that ran the analysis tool.",
          ).optional(),
          "processId": z.number().int().describe(
            "The process id for the analysis tool run.",
          ).optional(),
          "executableLocation": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "workingDirectory": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "environmentVariables": z.record(z.string()).describe(
            "The environment variables associated with the analysis tool process, expressed as key/value pairs.",
          ).optional(),
          "stdin": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "stdout": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "stderr": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "stdoutStderr": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "The runtime environment of the analysis tool run.",
        ),
      ).min(0).describe(
        "Describes the invocation of the analysis tool that will be merged with a separate run.",
      ).default([]),
      "logicalLocations": z.array(
        z.object({
          "name": z.string().describe(
            "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
          ).optional(),
          "index": z.number().int().gte(-1).describe(
            "The index within the logical locations array.",
          ).default(-1),
          "fullyQualifiedName": z.string().describe(
            "The human-readable fully qualified name of the logical location.",
          ).optional(),
          "decoratedName": z.string().describe(
            "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
          ).optional(),
          "parentIndex": z.number().int().gte(-1).describe(
            "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
          ).default(-1),
          "kind": z.string().describe(
            "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
          ).optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A logical location of a construct that produced a result.",
        ),
      ).min(0).describe(
        "An array of logical locations such as namespaces, types or functions that will be merged with a separate run.",
      ).default([]),
      "threadFlowLocations": z.array(
        z.object({
          "index": z.number().int().gte(-1).describe(
            "The index within the run threadFlowLocations array.",
          ).default(-1),
          "location": z.object({
            "id": z.number().int().gte(-1).describe(
              "Value that distinguishes this location from all other locations within a single result object.",
            ).default(-1),
            "physicalLocation": z.object({
              "address": z.object({
                "absoluteAddress": z.number().int().gte(-1).describe(
                  "The address expressed as a byte offset from the start of the addressable region.",
                ).default(-1),
                "relativeAddress": z.number().int().describe(
                  "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                ).optional(),
                "length": z.number().int().describe(
                  "The number of bytes in this range of addresses.",
                ).optional(),
                "kind": z.string().describe(
                  "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                ).optional(),
                "name": z.string().describe(
                  "A name that is associated with the address, e.g., '.text'.",
                ).optional(),
                "fullyQualifiedName": z.string().describe(
                  "A human-readable fully qualified name that is associated with the address.",
                ).optional(),
                "offsetFromParent": z.number().int().describe(
                  "The byte offset of this address from the absolute or relative address of the parent object.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index within run.addresses of the cached object for this address.",
                ).default(-1),
                "parentIndex": z.number().int().gte(-1).describe(
                  "The index within run.addresses of the parent object.",
                ).default(-1),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
              ).optional(),
              "artifactLocation": z.object({
                "uri": z.string().describe(
                  "A string containing a valid relative or absolute URI.",
                ).optional(),
                "uriBaseId": z.string().describe(
                  'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index within the run artifacts array of the artifact object associated with the artifact location.",
                ).default(-1),
                "description": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("Specifies the location of an artifact.")
                .optional(),
              "region": z.object({
                "startLine": z.number().int().gte(1).describe(
                  "The line number of the first character in the region.",
                ).optional(),
                "startColumn": z.number().int().gte(1).describe(
                  "The column number of the first character in the region.",
                ).optional(),
                "endLine": z.number().int().gte(1).describe(
                  "The line number of the last character in the region.",
                ).optional(),
                "endColumn": z.number().int().gte(1).describe(
                  "The column number of the character following the end of the region.",
                ).optional(),
                "charOffset": z.number().int().gte(-1).describe(
                  "The zero-based offset from the beginning of the artifact of the first character in the region.",
                ).default(-1),
                "charLength": z.number().int().gte(0).describe(
                  "The length of the region in characters.",
                ).optional(),
                "byteOffset": z.number().int().gte(-1).describe(
                  "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                ).default(-1),
                "byteLength": z.number().int().gte(0).describe(
                  "The length of the region in bytes.",
                ).optional(),
                "snippet": z.object({
                  "text": z.string().describe(
                    "UTF-8-encoded content from a text artifact.",
                  ).optional(),
                  "binary": z.string().describe(
                    "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                  ).optional(),
                  "rendered": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Represents the contents of an artifact.")
                  .optional(),
                "message": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "sourceLanguage": z.string().describe(
                  "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A region within an artifact where a result was detected.",
              ).optional(),
              "contextRegion": z.object({
                "startLine": z.number().int().gte(1).describe(
                  "The line number of the first character in the region.",
                ).optional(),
                "startColumn": z.number().int().gte(1).describe(
                  "The column number of the first character in the region.",
                ).optional(),
                "endLine": z.number().int().gte(1).describe(
                  "The line number of the last character in the region.",
                ).optional(),
                "endColumn": z.number().int().gte(1).describe(
                  "The column number of the character following the end of the region.",
                ).optional(),
                "charOffset": z.number().int().gte(-1).describe(
                  "The zero-based offset from the beginning of the artifact of the first character in the region.",
                ).default(-1),
                "charLength": z.number().int().gte(0).describe(
                  "The length of the region in characters.",
                ).optional(),
                "byteOffset": z.number().int().gte(-1).describe(
                  "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                ).default(-1),
                "byteLength": z.number().int().gte(0).describe(
                  "The length of the region in bytes.",
                ).optional(),
                "snippet": z.object({
                  "text": z.string().describe(
                    "UTF-8-encoded content from a text artifact.",
                  ).optional(),
                  "binary": z.string().describe(
                    "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                  ).optional(),
                  "rendered": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Represents the contents of an artifact.")
                  .optional(),
                "message": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "sourceLanguage": z.string().describe(
                  "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A region within an artifact where a result was detected.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
            ).optional(),
            "logicalLocations": z.array(
              z.object({
                "name": z.string().describe(
                  "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index within the logical locations array.",
                ).default(-1),
                "fullyQualifiedName": z.string().describe(
                  "The human-readable fully qualified name of the logical location.",
                ).optional(),
                "decoratedName": z.string().describe(
                  "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                ).optional(),
                "parentIndex": z.number().int().gte(-1).describe(
                  "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                ).default(-1),
                "kind": z.string().describe(
                  "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A logical location of a construct that produced a result.",
              ),
            ).min(0).describe(
              "The logical locations associated with the result.",
            ).default([]),
            "message": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "annotations": z.array(
              z.object({
                "startLine": z.number().int().gte(1).describe(
                  "The line number of the first character in the region.",
                ).optional(),
                "startColumn": z.number().int().gte(1).describe(
                  "The column number of the first character in the region.",
                ).optional(),
                "endLine": z.number().int().gte(1).describe(
                  "The line number of the last character in the region.",
                ).optional(),
                "endColumn": z.number().int().gte(1).describe(
                  "The column number of the character following the end of the region.",
                ).optional(),
                "charOffset": z.number().int().gte(-1).describe(
                  "The zero-based offset from the beginning of the artifact of the first character in the region.",
                ).default(-1),
                "charLength": z.number().int().gte(0).describe(
                  "The length of the region in characters.",
                ).optional(),
                "byteOffset": z.number().int().gte(-1).describe(
                  "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                ).default(-1),
                "byteLength": z.number().int().gte(0).describe(
                  "The length of the region in bytes.",
                ).optional(),
                "snippet": z.object({
                  "text": z.string().describe(
                    "UTF-8-encoded content from a text artifact.",
                  ).optional(),
                  "binary": z.string().describe(
                    "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                  ).optional(),
                  "rendered": z.object({
                    "text": z.string().describe(
                      "A plain text message string or format string.",
                    ),
                    "markdown": z.string().describe(
                      "A Markdown message string or format string.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A message string or message format string rendered in multiple formats.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Represents the contents of an artifact.")
                  .optional(),
                "message": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "sourceLanguage": z.string().describe(
                  "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A region within an artifact where a result was detected.",
              ),
            ).min(0).describe("A set of regions relevant to the location.")
              .default([]),
            "relationships": z.array(
              z.object({
                "target": z.number().int().gte(0).describe(
                  "A reference to the related location.",
                ),
                "kinds": z.array(z.string()).describe(
                  "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                ).default(["relevant"]),
                "description": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about the relation of one location to another.",
              ),
            ).min(0).describe(
              "An array of objects that describe relationships between this location and others.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("A location within a programming artifact.")
            .optional(),
          "stack": z.object({
            "message": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "frames": z.array(
              z.object({
                "location": z.object({
                  "id": z.number().int().gte(-1).describe(
                    "Value that distinguishes this location from all other locations within a single result object.",
                  ).default(-1),
                  "physicalLocation": z.object({
                    "address": z.object({
                      "absoluteAddress": z.number().int().gte(-1).describe(
                        "The address expressed as a byte offset from the start of the addressable region.",
                      ).default(-1),
                      "relativeAddress": z.number().int().describe(
                        "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                      ).optional(),
                      "length": z.number().int().describe(
                        "The number of bytes in this range of addresses.",
                      ).optional(),
                      "kind": z.string().describe(
                        "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                      ).optional(),
                      "name": z.string().describe(
                        "A name that is associated with the address, e.g., '.text'.",
                      ).optional(),
                      "fullyQualifiedName": z.string().describe(
                        "A human-readable fully qualified name that is associated with the address.",
                      ).optional(),
                      "offsetFromParent": z.number().int().describe(
                        "The byte offset of this address from the absolute or relative address of the parent object.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the cached object for this address.",
                      ).default(-1),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "The index within run.addresses of the parent object.",
                      ).default(-1),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                    ).optional(),
                    "artifactLocation": z.object({
                      "uri": z.string().describe(
                        "A string containing a valid relative or absolute URI.",
                      ).optional(),
                      "uriBaseId": z.string().describe(
                        'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the run artifacts array of the artifact object associated with the artifact location.",
                      ).default(-1),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Specifies the location of an artifact.",
                    ).optional(),
                    "region": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "contextRegion": z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                  ).optional(),
                  "logicalLocations": z.array(
                    z.object({
                      "name": z.string().describe(
                        "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "The index within the logical locations array.",
                      ).default(-1),
                      "fullyQualifiedName": z.string().describe(
                        "The human-readable fully qualified name of the logical location.",
                      ).optional(),
                      "decoratedName": z.string().describe(
                        "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                      ).optional(),
                      "parentIndex": z.number().int().gte(-1).describe(
                        "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                      ).default(-1),
                      "kind": z.string().describe(
                        "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A logical location of a construct that produced a result.",
                    ),
                  ).min(0).describe(
                    "The logical locations associated with the result.",
                  ).default([]),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "annotations": z.array(
                    z.object({
                      "startLine": z.number().int().gte(1).describe(
                        "The line number of the first character in the region.",
                      ).optional(),
                      "startColumn": z.number().int().gte(1).describe(
                        "The column number of the first character in the region.",
                      ).optional(),
                      "endLine": z.number().int().gte(1).describe(
                        "The line number of the last character in the region.",
                      ).optional(),
                      "endColumn": z.number().int().gte(1).describe(
                        "The column number of the character following the end of the region.",
                      ).optional(),
                      "charOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first character in the region.",
                      ).default(-1),
                      "charLength": z.number().int().gte(0).describe(
                        "The length of the region in characters.",
                      ).optional(),
                      "byteOffset": z.number().int().gte(-1).describe(
                        "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                      ).default(-1),
                      "byteLength": z.number().int().gte(0).describe(
                        "The length of the region in bytes.",
                      ).optional(),
                      "snippet": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "message": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "sourceLanguage": z.string().describe(
                        "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A region within an artifact where a result was detected.",
                    ),
                  ).min(0).describe(
                    "A set of regions relevant to the location.",
                  ).default([]),
                  "relationships": z.array(
                    z.object({
                      "target": z.number().int().gte(0).describe(
                        "A reference to the related location.",
                      ),
                      "kinds": z.array(z.string()).describe(
                        "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                      ).default(["relevant"]),
                      "description": z.object({
                        "text": z.string().describe(
                          "A plain text message string.",
                        ).optional(),
                        "markdown": z.string().describe(
                          "A Markdown message string.",
                        ).optional(),
                        "id": z.string().describe(
                          "The identifier for this message.",
                        ).optional(),
                        "arguments": z.array(z.string()).min(0).describe(
                          "An array of strings to substitute into the message string.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().and(z.union([z.any(), z.any()])).describe(
                        "Encapsulates a message intended to be read by the end user.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Information about the relation of one location to another.",
                    ),
                  ).min(0).describe(
                    "An array of objects that describe relationships between this location and others.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A location within a programming artifact.",
                ).optional(),
                "module": z.string().describe(
                  "The name of the module that contains the code of this stack frame.",
                ).optional(),
                "threadId": z.number().int().describe(
                  "The thread identifier of the stack frame.",
                ).optional(),
                "parameters": z.array(z.string().default([])).min(0).describe(
                  "The parameters of the call that is executing.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("A function call within a stack trace."),
            ).min(0).describe(
              "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
            ),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("A call stack that is relevant to a result.")
            .optional(),
          "kinds": z.array(z.string()).min(0).describe(
            "A set of distinct strings that categorize the thread flow location. Well-known kinds include 'acquire', 'release', 'enter', 'exit', 'call', 'return', 'branch', 'implicit', 'false', 'true', 'caution', 'danger', 'unknown', 'unreachable', 'taint', 'function', 'handler', 'lock', 'memory', 'resource', 'scope' and 'value'.",
          ).default([]),
          "taxa": z.array(
            z.object({
              "id": z.string().describe("The id of the descriptor.").optional(),
              "index": z.number().int().gte(-1).describe(
                "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("A guid that uniquely identifies the descriptor.")
                .optional(),
              "toolComponent": z.object({
                "name": z.string().describe(
                  "The 'name' property of the referenced toolComponent.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "An index into the referenced toolComponent in tool.extensions.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "The 'guid' property of the referenced toolComponent.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Identifies a particular toolComponent object, either the driver or an extension.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
              "Information about how to locate a relevant reporting descriptor.",
            ),
          ).min(0).describe(
            "An array of references to rule or taxonomy reporting descriptors that are applicable to the thread flow location.",
          ).default([]),
          "module": z.string().describe(
            "The name of the module that contains the code that is executing.",
          ).optional(),
          "state": z.record(
            z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ),
          ).describe(
            "A dictionary, each of whose keys specifies a variable or expression, the associated value of which represents the variable or expression value. For an annotation of kind 'continuation', for example, this dictionary might hold the current assumed values of a set of global variables.",
          ).optional(),
          "nestingLevel": z.number().int().gte(0).describe(
            "An integer representing a containment hierarchy within the thread flow.",
          ).optional(),
          "executionOrder": z.number().int().gte(-1).describe(
            "An integer representing the temporal order in which execution reached this location.",
          ).default(-1),
          "executionTimeUtc": z.string().datetime({ offset: true }).describe(
            "The Coordinated Universal Time (UTC) date and time at which this location was executed.",
          ).optional(),
          "importance": z.enum(["important", "essential", "unimportant"])
            .describe(
              'Specifies the importance of this location in understanding the code flow in which it occurs. The order from most to least important is "essential", "important", "unimportant". Default: "important".',
            ).default("important"),
          "webRequest": z.object({
            "index": z.number().int().gte(-1).describe(
              "The index within the run.webRequests array of the request object associated with this result.",
            ).default(-1),
            "protocol": z.string().describe(
              "The request protocol. Example: 'http'.",
            ).optional(),
            "version": z.string().describe(
              "The request version. Example: '1.1'.",
            ).optional(),
            "target": z.string().describe("The target of the request.")
              .optional(),
            "method": z.string().describe(
              "The HTTP method. Well-known values are 'GET', 'PUT', 'POST', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'.",
            ).optional(),
            "headers": z.record(z.string()).describe("The request headers.")
              .optional(),
            "parameters": z.record(z.string()).describe(
              "The request parameters.",
            ).optional(),
            "body": z.object({
              "text": z.string().describe(
                "UTF-8-encoded content from a text artifact.",
              ).optional(),
              "binary": z.string().describe(
                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
              ).optional(),
              "rendered": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Represents the contents of an artifact.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Describes an HTTP request.").optional(),
          "webResponse": z.object({
            "index": z.number().int().gte(-1).describe(
              "The index within the run.webResponses array of the response object associated with this result.",
            ).default(-1),
            "protocol": z.string().describe(
              "The response protocol. Example: 'http'.",
            ).optional(),
            "version": z.string().describe(
              "The response version. Example: '1.1'.",
            ).optional(),
            "statusCode": z.number().int().describe(
              "The response status code. Example: 451.",
            ).optional(),
            "reasonPhrase": z.string().describe(
              "The response reason. Example: 'Not found'.",
            ).optional(),
            "headers": z.record(z.string()).describe("The response headers.")
              .optional(),
            "body": z.object({
              "text": z.string().describe(
                "UTF-8-encoded content from a text artifact.",
              ).optional(),
              "binary": z.string().describe(
                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
              ).optional(),
              "rendered": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Represents the contents of an artifact.")
              .optional(),
            "noResponseReceived": z.boolean().describe(
              "Specifies whether a response was received from the server.",
            ).default(false),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Describes the response to an HTTP request.")
            .optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A location visited by an analysis tool while simulating or monitoring the execution of a program.",
        ),
      ).min(0).describe(
        "An array of threadFlowLocation objects that will be merged with a separate run.",
      ).default([]),
      "results": z.array(
        z.object({
          "ruleId": z.string().describe(
            "The stable, unique identifier of the rule, if any, to which this notification is relevant. This member can be used to retrieve rule metadata from the rules dictionary, if it exists.",
          ).optional(),
          "ruleIndex": z.number().int().gte(-1).describe(
            "The index within the tool component rules array of the rule object associated with this result.",
          ).default(-1),
          "rule": z.object({
            "id": z.string().describe("The id of the descriptor.").optional(),
            "index": z.number().int().gte(-1).describe(
              "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
            ).default(-1),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe("A guid that uniquely identifies the descriptor.")
              .optional(),
            "toolComponent": z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
            "Information about how to locate a relevant reporting descriptor.",
          ).optional(),
          "kind": z.enum([
            "notApplicable",
            "pass",
            "fail",
            "review",
            "open",
            "informational",
          ]).describe("A value that categorizes results by evaluation state.")
            .default("fail"),
          "level": z.enum(["none", "note", "warning", "error"]).describe(
            "A value specifying the severity level of the result.",
          ).default("warning"),
          "message": z.object({
            "text": z.string().describe("A plain text message string.")
              .optional(),
            "markdown": z.string().describe("A Markdown message string.")
              .optional(),
            "id": z.string().describe("The identifier for this message.")
              .optional(),
            "arguments": z.array(z.string()).min(0).describe(
              "An array of strings to substitute into the message string.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().and(z.union([z.any(), z.any()])).describe(
            "Encapsulates a message intended to be read by the end user.",
          ),
          "analysisTarget": z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact.")
            .optional(),
          "locations": z.array(
            z.object({
              "id": z.number().int().gte(-1).describe(
                "Value that distinguishes this location from all other locations within a single result object.",
              ).default(-1),
              "physicalLocation": z.object({
                "address": z.object({
                  "absoluteAddress": z.number().int().gte(-1).describe(
                    "The address expressed as a byte offset from the start of the addressable region.",
                  ).default(-1),
                  "relativeAddress": z.number().int().describe(
                    "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                  ).optional(),
                  "length": z.number().int().describe(
                    "The number of bytes in this range of addresses.",
                  ).optional(),
                  "kind": z.string().describe(
                    "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                  ).optional(),
                  "name": z.string().describe(
                    "A name that is associated with the address, e.g., '.text'.",
                  ).optional(),
                  "fullyQualifiedName": z.string().describe(
                    "A human-readable fully qualified name that is associated with the address.",
                  ).optional(),
                  "offsetFromParent": z.number().int().describe(
                    "The byte offset of this address from the absolute or relative address of the parent object.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within run.addresses of the cached object for this address.",
                  ).default(-1),
                  "parentIndex": z.number().int().gte(-1).describe(
                    "The index within run.addresses of the parent object.",
                  ).default(-1),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                ).optional(),
                "artifactLocation": z.object({
                  "uri": z.string().describe(
                    "A string containing a valid relative or absolute URI.",
                  ).optional(),
                  "uriBaseId": z.string().describe(
                    'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within the run artifacts array of the artifact object associated with the artifact location.",
                  ).default(-1),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Specifies the location of an artifact.")
                  .optional(),
                "region": z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ).optional(),
                "contextRegion": z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
              ).optional(),
              "logicalLocations": z.array(
                z.object({
                  "name": z.string().describe(
                    "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within the logical locations array.",
                  ).default(-1),
                  "fullyQualifiedName": z.string().describe(
                    "The human-readable fully qualified name of the logical location.",
                  ).optional(),
                  "decoratedName": z.string().describe(
                    "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                  ).optional(),
                  "parentIndex": z.number().int().gte(-1).describe(
                    "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                  ).default(-1),
                  "kind": z.string().describe(
                    "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A logical location of a construct that produced a result.",
                ),
              ).min(0).describe(
                "The logical locations associated with the result.",
              ).default([]),
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "annotations": z.array(
                z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ),
              ).min(0).describe("A set of regions relevant to the location.")
                .default([]),
              "relationships": z.array(
                z.object({
                  "target": z.number().int().gte(0).describe(
                    "A reference to the related location.",
                  ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one location to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this location and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("A location within a programming artifact."),
          ).min(0).describe(
            "The set of locations where the result was detected. Specify only one location unless the problem indicated by the result can only be corrected by making a change at every specified location.",
          ).default([]),
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A stable, unique identifier for the result in the form of a GUID.",
          ).optional(),
          "correlationGuid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A stable, unique identifier for the equivalence class of logically identical results to which this result belongs, in the form of a GUID.",
          ).optional(),
          "occurrenceCount": z.number().int().gte(1).describe(
            "A positive integer specifying the number of times this logically unique result was observed in this run.",
          ).optional(),
          "partialFingerprints": z.record(z.string()).describe(
            "A set of strings that contribute to the stable, unique identity of the result.",
          ).optional(),
          "fingerprints": z.record(z.string()).describe(
            "A set of strings each of which individually defines a stable, unique identity for the result.",
          ).optional(),
          "stacks": z.array(
            z.object({
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "frames": z.array(
                z.object({
                  "location": z.object({
                    "id": z.number().int().gte(-1).describe(
                      "Value that distinguishes this location from all other locations within a single result object.",
                    ).default(-1),
                    "physicalLocation": z.object({
                      "address": z.object({
                        "absoluteAddress": z.number().int().gte(-1).describe(
                          "The address expressed as a byte offset from the start of the addressable region.",
                        ).default(-1),
                        "relativeAddress": z.number().int().describe(
                          "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                        ).optional(),
                        "length": z.number().int().describe(
                          "The number of bytes in this range of addresses.",
                        ).optional(),
                        "kind": z.string().describe(
                          "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                        ).optional(),
                        "name": z.string().describe(
                          "A name that is associated with the address, e.g., '.text'.",
                        ).optional(),
                        "fullyQualifiedName": z.string().describe(
                          "A human-readable fully qualified name that is associated with the address.",
                        ).optional(),
                        "offsetFromParent": z.number().int().describe(
                          "The byte offset of this address from the absolute or relative address of the parent object.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index within run.addresses of the cached object for this address.",
                        ).default(-1),
                        "parentIndex": z.number().int().gte(-1).describe(
                          "The index within run.addresses of the parent object.",
                        ).default(-1),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                      ).optional(),
                      "artifactLocation": z.object({
                        "uri": z.string().describe(
                          "A string containing a valid relative or absolute URI.",
                        ).optional(),
                        "uriBaseId": z.string().describe(
                          'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index within the run artifacts array of the artifact object associated with the artifact location.",
                        ).default(-1),
                        "description": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Specifies the location of an artifact.",
                      ).optional(),
                      "region": z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ).optional(),
                      "contextRegion": z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                    ).optional(),
                    "logicalLocations": z.array(
                      z.object({
                        "name": z.string().describe(
                          "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index within the logical locations array.",
                        ).default(-1),
                        "fullyQualifiedName": z.string().describe(
                          "The human-readable fully qualified name of the logical location.",
                        ).optional(),
                        "decoratedName": z.string().describe(
                          "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                        ).optional(),
                        "parentIndex": z.number().int().gte(-1).describe(
                          "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                        ).default(-1),
                        "kind": z.string().describe(
                          "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A logical location of a construct that produced a result.",
                      ),
                    ).min(0).describe(
                      "The logical locations associated with the result.",
                    ).default([]),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "annotations": z.array(
                      z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ),
                    ).min(0).describe(
                      "A set of regions relevant to the location.",
                    ).default([]),
                    "relationships": z.array(
                      z.object({
                        "target": z.number().int().gte(0).describe(
                          "A reference to the related location.",
                        ),
                        "kinds": z.array(z.string()).describe(
                          "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                        ).default(["relevant"]),
                        "description": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Information about the relation of one location to another.",
                      ),
                    ).min(0).describe(
                      "An array of objects that describe relationships between this location and others.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A location within a programming artifact.",
                  ).optional(),
                  "module": z.string().describe(
                    "The name of the module that contains the code of this stack frame.",
                  ).optional(),
                  "threadId": z.number().int().describe(
                    "The thread identifier of the stack frame.",
                  ).optional(),
                  "parameters": z.array(z.string().default([])).min(0).describe(
                    "The parameters of the call that is executing.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("A function call within a stack trace."),
              ).min(0).describe(
                "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("A call stack that is relevant to a result."),
          ).min(0).describe(
            "An array of 'stack' objects relevant to the result.",
          ).default([]),
          "codeFlows": z.array(
            z.object({
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "threadFlows": z.array(
                z.object({
                  "id": z.string().describe(
                    "An string that uniquely identifies the threadFlow within the codeFlow in which it occurs.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "initialState": z.record(
                    z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ),
                  ).describe(
                    "Values of relevant expressions at the start of the thread flow that may change during thread flow execution.",
                  ).optional(),
                  "immutableState": z.record(
                    z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ),
                  ).describe(
                    "Values of relevant expressions at the start of the thread flow that remain constant.",
                  ).optional(),
                  "locations": z.array(
                    z.object({
                      "index": z.number().int().gte(-1).describe(
                        "The index within the run threadFlowLocations array.",
                      ).default(-1),
                      "location": z.object({
                        "id": z.number().int().gte(-1).describe(
                          "Value that distinguishes this location from all other locations within a single result object.",
                        ).default(-1),
                        "physicalLocation": z.object({
                          "address": z.object({
                            "absoluteAddress": z.number().int().gte(-1)
                              .describe(
                                "The address expressed as a byte offset from the start of the addressable region.",
                              ).default(-1),
                            "relativeAddress": z.number().int().describe(
                              "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                            ).optional(),
                            "length": z.number().int().describe(
                              "The number of bytes in this range of addresses.",
                            ).optional(),
                            "kind": z.string().describe(
                              "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                            ).optional(),
                            "name": z.string().describe(
                              "A name that is associated with the address, e.g., '.text'.",
                            ).optional(),
                            "fullyQualifiedName": z.string().describe(
                              "A human-readable fully qualified name that is associated with the address.",
                            ).optional(),
                            "offsetFromParent": z.number().int().describe(
                              "The byte offset of this address from the absolute or relative address of the parent object.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the cached object for this address.",
                            ).default(-1),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "The index within run.addresses of the parent object.",
                            ).default(-1),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                          ).optional(),
                          "artifactLocation": z.object({
                            "uri": z.string().describe(
                              "A string containing a valid relative or absolute URI.",
                            ).optional(),
                            "uriBaseId": z.string().describe(
                              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the run artifacts array of the artifact object associated with the artifact location.",
                            ).default(-1),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Specifies the location of an artifact.",
                          ).optional(),
                          "region": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "contextRegion": z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                        ).optional(),
                        "logicalLocations": z.array(
                          z.object({
                            "name": z.string().describe(
                              "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "The index within the logical locations array.",
                            ).default(-1),
                            "fullyQualifiedName": z.string().describe(
                              "The human-readable fully qualified name of the logical location.",
                            ).optional(),
                            "decoratedName": z.string().describe(
                              "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                            ).optional(),
                            "parentIndex": z.number().int().gte(-1).describe(
                              "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                            ).default(-1),
                            "kind": z.string().describe(
                              "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A logical location of a construct that produced a result.",
                          ),
                        ).min(0).describe(
                          "The logical locations associated with the result.",
                        ).default([]),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "annotations": z.array(
                          z.object({
                            "startLine": z.number().int().gte(1).describe(
                              "The line number of the first character in the region.",
                            ).optional(),
                            "startColumn": z.number().int().gte(1).describe(
                              "The column number of the first character in the region.",
                            ).optional(),
                            "endLine": z.number().int().gte(1).describe(
                              "The line number of the last character in the region.",
                            ).optional(),
                            "endColumn": z.number().int().gte(1).describe(
                              "The column number of the character following the end of the region.",
                            ).optional(),
                            "charOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first character in the region.",
                            ).default(-1),
                            "charLength": z.number().int().gte(0).describe(
                              "The length of the region in characters.",
                            ).optional(),
                            "byteOffset": z.number().int().gte(-1).describe(
                              "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                            ).default(-1),
                            "byteLength": z.number().int().gte(0).describe(
                              "The length of the region in bytes.",
                            ).optional(),
                            "snippet": z.object({
                              "text": z.string().describe(
                                "UTF-8-encoded content from a text artifact.",
                              ).optional(),
                              "binary": z.string().describe(
                                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                              ).optional(),
                              "rendered": z.object({
                                "text": z.string().describe(
                                  "A plain text message string or format string.",
                                ),
                                "markdown": z.string().describe(
                                  "A Markdown message string or format string.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().describe(
                                "A message string or message format string rendered in multiple formats.",
                              ).optional(),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "Represents the contents of an artifact.",
                            ).optional(),
                            "message": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "sourceLanguage": z.string().describe(
                              "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A region within an artifact where a result was detected.",
                          ),
                        ).min(0).describe(
                          "A set of regions relevant to the location.",
                        ).default([]),
                        "relationships": z.array(
                          z.object({
                            "target": z.number().int().gte(0).describe(
                              "A reference to the related location.",
                            ),
                            "kinds": z.array(z.string()).describe(
                              "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                            ).default(["relevant"]),
                            "description": z.object({
                              "text": z.string().describe(
                                "A plain text message string.",
                              ).optional(),
                              "markdown": z.string().describe(
                                "A Markdown message string.",
                              ).optional(),
                              "id": z.string().describe(
                                "The identifier for this message.",
                              ).optional(),
                              "arguments": z.array(z.string()).min(0).describe(
                                "An array of strings to substitute into the message string.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().and(z.union([z.any(), z.any()]))
                              .describe(
                                "Encapsulates a message intended to be read by the end user.",
                              ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Information about the relation of one location to another.",
                          ),
                        ).min(0).describe(
                          "An array of objects that describe relationships between this location and others.",
                        ).default([]),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A location within a programming artifact.",
                      ).optional(),
                      "stack": z.object({
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "frames": z.array(
                          z.object({
                            "location": z.object({
                              "id": z.number().int().gte(-1).describe(
                                "Value that distinguishes this location from all other locations within a single result object.",
                              ).default(-1),
                              "physicalLocation": z.object({
                                "address": z.object({
                                  "absoluteAddress": z.number().int().gte(-1)
                                    .describe(
                                      "The address expressed as a byte offset from the start of the addressable region.",
                                    ).default(-1),
                                  "relativeAddress": z.number().int().describe(
                                    "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                                  ).optional(),
                                  "length": z.number().int().describe(
                                    "The number of bytes in this range of addresses.",
                                  ).optional(),
                                  "kind": z.string().describe(
                                    "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                                  ).optional(),
                                  "name": z.string().describe(
                                    "A name that is associated with the address, e.g., '.text'.",
                                  ).optional(),
                                  "fullyQualifiedName": z.string().describe(
                                    "A human-readable fully qualified name that is associated with the address.",
                                  ).optional(),
                                  "offsetFromParent": z.number().int().describe(
                                    "The byte offset of this address from the absolute or relative address of the parent object.",
                                  ).optional(),
                                  "index": z.number().int().gte(-1).describe(
                                    "The index within run.addresses of the cached object for this address.",
                                  ).default(-1),
                                  "parentIndex": z.number().int().gte(-1)
                                    .describe(
                                      "The index within run.addresses of the parent object.",
                                    ).default(-1),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                                ).optional(),
                                "artifactLocation": z.object({
                                  "uri": z.string().describe(
                                    "A string containing a valid relative or absolute URI.",
                                  ).optional(),
                                  "uriBaseId": z.string().describe(
                                    'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                                  ).optional(),
                                  "index": z.number().int().gte(-1).describe(
                                    "The index within the run artifacts array of the artifact object associated with the artifact location.",
                                  ).default(-1),
                                  "description": z.object({
                                    "text": z.string().describe(
                                      "A plain text message string.",
                                    ).optional(),
                                    "markdown": z.string().describe(
                                      "A Markdown message string.",
                                    ).optional(),
                                    "id": z.string().describe(
                                      "The identifier for this message.",
                                    ).optional(),
                                    "arguments": z.array(z.string()).min(0)
                                      .describe(
                                        "An array of strings to substitute into the message string.",
                                      ).default([]),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().and(z.union([z.any(), z.any()]))
                                    .describe(
                                      "Encapsulates a message intended to be read by the end user.",
                                    ).optional(),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "Specifies the location of an artifact.",
                                ).optional(),
                                "region": z.object({
                                  "startLine": z.number().int().gte(1).describe(
                                    "The line number of the first character in the region.",
                                  ).optional(),
                                  "startColumn": z.number().int().gte(1)
                                    .describe(
                                      "The column number of the first character in the region.",
                                    ).optional(),
                                  "endLine": z.number().int().gte(1).describe(
                                    "The line number of the last character in the region.",
                                  ).optional(),
                                  "endColumn": z.number().int().gte(1).describe(
                                    "The column number of the character following the end of the region.",
                                  ).optional(),
                                  "charOffset": z.number().int().gte(-1)
                                    .describe(
                                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                                    ).default(-1),
                                  "charLength": z.number().int().gte(0)
                                    .describe(
                                      "The length of the region in characters.",
                                    ).optional(),
                                  "byteOffset": z.number().int().gte(-1)
                                    .describe(
                                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                                    ).default(-1),
                                  "byteLength": z.number().int().gte(0)
                                    .describe(
                                      "The length of the region in bytes.",
                                    ).optional(),
                                  "snippet": z.object({
                                    "text": z.string().describe(
                                      "UTF-8-encoded content from a text artifact.",
                                    ).optional(),
                                    "binary": z.string().describe(
                                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                                    ).optional(),
                                    "rendered": z.object({
                                      "text": z.string().describe(
                                        "A plain text message string or format string.",
                                      ),
                                      "markdown": z.string().describe(
                                        "A Markdown message string or format string.",
                                      ).optional(),
                                      "properties": z.object({
                                        "tags": z.array(z.string()).min(0)
                                          .describe(
                                            "A set of distinct strings that provide additional information.",
                                          ).default([]),
                                      }).catchall(z.any()).describe(
                                        "Key/value pairs that provide additional information about the object.",
                                      ).optional(),
                                    }).strict().describe(
                                      "A message string or message format string rendered in multiple formats.",
                                    ).optional(),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().describe(
                                    "Represents the contents of an artifact.",
                                  ).optional(),
                                  "message": z.object({
                                    "text": z.string().describe(
                                      "A plain text message string.",
                                    ).optional(),
                                    "markdown": z.string().describe(
                                      "A Markdown message string.",
                                    ).optional(),
                                    "id": z.string().describe(
                                      "The identifier for this message.",
                                    ).optional(),
                                    "arguments": z.array(z.string()).min(0)
                                      .describe(
                                        "An array of strings to substitute into the message string.",
                                      ).default([]),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().and(z.union([z.any(), z.any()]))
                                    .describe(
                                      "Encapsulates a message intended to be read by the end user.",
                                    ).optional(),
                                  "sourceLanguage": z.string().describe(
                                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                                  ).optional(),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "A region within an artifact where a result was detected.",
                                ).optional(),
                                "contextRegion": z.object({
                                  "startLine": z.number().int().gte(1).describe(
                                    "The line number of the first character in the region.",
                                  ).optional(),
                                  "startColumn": z.number().int().gte(1)
                                    .describe(
                                      "The column number of the first character in the region.",
                                    ).optional(),
                                  "endLine": z.number().int().gte(1).describe(
                                    "The line number of the last character in the region.",
                                  ).optional(),
                                  "endColumn": z.number().int().gte(1).describe(
                                    "The column number of the character following the end of the region.",
                                  ).optional(),
                                  "charOffset": z.number().int().gte(-1)
                                    .describe(
                                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                                    ).default(-1),
                                  "charLength": z.number().int().gte(0)
                                    .describe(
                                      "The length of the region in characters.",
                                    ).optional(),
                                  "byteOffset": z.number().int().gte(-1)
                                    .describe(
                                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                                    ).default(-1),
                                  "byteLength": z.number().int().gte(0)
                                    .describe(
                                      "The length of the region in bytes.",
                                    ).optional(),
                                  "snippet": z.object({
                                    "text": z.string().describe(
                                      "UTF-8-encoded content from a text artifact.",
                                    ).optional(),
                                    "binary": z.string().describe(
                                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                                    ).optional(),
                                    "rendered": z.object({
                                      "text": z.string().describe(
                                        "A plain text message string or format string.",
                                      ),
                                      "markdown": z.string().describe(
                                        "A Markdown message string or format string.",
                                      ).optional(),
                                      "properties": z.object({
                                        "tags": z.array(z.string()).min(0)
                                          .describe(
                                            "A set of distinct strings that provide additional information.",
                                          ).default([]),
                                      }).catchall(z.any()).describe(
                                        "Key/value pairs that provide additional information about the object.",
                                      ).optional(),
                                    }).strict().describe(
                                      "A message string or message format string rendered in multiple formats.",
                                    ).optional(),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().describe(
                                    "Represents the contents of an artifact.",
                                  ).optional(),
                                  "message": z.object({
                                    "text": z.string().describe(
                                      "A plain text message string.",
                                    ).optional(),
                                    "markdown": z.string().describe(
                                      "A Markdown message string.",
                                    ).optional(),
                                    "id": z.string().describe(
                                      "The identifier for this message.",
                                    ).optional(),
                                    "arguments": z.array(z.string()).min(0)
                                      .describe(
                                        "An array of strings to substitute into the message string.",
                                      ).default([]),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().and(z.union([z.any(), z.any()]))
                                    .describe(
                                      "Encapsulates a message intended to be read by the end user.",
                                    ).optional(),
                                  "sourceLanguage": z.string().describe(
                                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                                  ).optional(),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "A region within an artifact where a result was detected.",
                                ).optional(),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().and(z.union([z.any(), z.any()]))
                                .describe(
                                  "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                                ).optional(),
                              "logicalLocations": z.array(
                                z.object({
                                  "name": z.string().describe(
                                    "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                                  ).optional(),
                                  "index": z.number().int().gte(-1).describe(
                                    "The index within the logical locations array.",
                                  ).default(-1),
                                  "fullyQualifiedName": z.string().describe(
                                    "The human-readable fully qualified name of the logical location.",
                                  ).optional(),
                                  "decoratedName": z.string().describe(
                                    "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                                  ).optional(),
                                  "parentIndex": z.number().int().gte(-1)
                                    .describe(
                                      "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                                    ).default(-1),
                                  "kind": z.string().describe(
                                    "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                                  ).optional(),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "A logical location of a construct that produced a result.",
                                ),
                              ).min(0).describe(
                                "The logical locations associated with the result.",
                              ).default([]),
                              "message": z.object({
                                "text": z.string().describe(
                                  "A plain text message string.",
                                ).optional(),
                                "markdown": z.string().describe(
                                  "A Markdown message string.",
                                ).optional(),
                                "id": z.string().describe(
                                  "The identifier for this message.",
                                ).optional(),
                                "arguments": z.array(z.string()).min(0)
                                  .describe(
                                    "An array of strings to substitute into the message string.",
                                  ).default([]),
                                "properties": z.object({
                                  "tags": z.array(z.string()).min(0).describe(
                                    "A set of distinct strings that provide additional information.",
                                  ).default([]),
                                }).catchall(z.any()).describe(
                                  "Key/value pairs that provide additional information about the object.",
                                ).optional(),
                              }).strict().and(z.union([z.any(), z.any()]))
                                .describe(
                                  "Encapsulates a message intended to be read by the end user.",
                                ).optional(),
                              "annotations": z.array(
                                z.object({
                                  "startLine": z.number().int().gte(1).describe(
                                    "The line number of the first character in the region.",
                                  ).optional(),
                                  "startColumn": z.number().int().gte(1)
                                    .describe(
                                      "The column number of the first character in the region.",
                                    ).optional(),
                                  "endLine": z.number().int().gte(1).describe(
                                    "The line number of the last character in the region.",
                                  ).optional(),
                                  "endColumn": z.number().int().gte(1).describe(
                                    "The column number of the character following the end of the region.",
                                  ).optional(),
                                  "charOffset": z.number().int().gte(-1)
                                    .describe(
                                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                                    ).default(-1),
                                  "charLength": z.number().int().gte(0)
                                    .describe(
                                      "The length of the region in characters.",
                                    ).optional(),
                                  "byteOffset": z.number().int().gte(-1)
                                    .describe(
                                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                                    ).default(-1),
                                  "byteLength": z.number().int().gte(0)
                                    .describe(
                                      "The length of the region in bytes.",
                                    ).optional(),
                                  "snippet": z.object({
                                    "text": z.string().describe(
                                      "UTF-8-encoded content from a text artifact.",
                                    ).optional(),
                                    "binary": z.string().describe(
                                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                                    ).optional(),
                                    "rendered": z.object({
                                      "text": z.string().describe(
                                        "A plain text message string or format string.",
                                      ),
                                      "markdown": z.string().describe(
                                        "A Markdown message string or format string.",
                                      ).optional(),
                                      "properties": z.object({
                                        "tags": z.array(z.string()).min(0)
                                          .describe(
                                            "A set of distinct strings that provide additional information.",
                                          ).default([]),
                                      }).catchall(z.any()).describe(
                                        "Key/value pairs that provide additional information about the object.",
                                      ).optional(),
                                    }).strict().describe(
                                      "A message string or message format string rendered in multiple formats.",
                                    ).optional(),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().describe(
                                    "Represents the contents of an artifact.",
                                  ).optional(),
                                  "message": z.object({
                                    "text": z.string().describe(
                                      "A plain text message string.",
                                    ).optional(),
                                    "markdown": z.string().describe(
                                      "A Markdown message string.",
                                    ).optional(),
                                    "id": z.string().describe(
                                      "The identifier for this message.",
                                    ).optional(),
                                    "arguments": z.array(z.string()).min(0)
                                      .describe(
                                        "An array of strings to substitute into the message string.",
                                      ).default([]),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().and(z.union([z.any(), z.any()]))
                                    .describe(
                                      "Encapsulates a message intended to be read by the end user.",
                                    ).optional(),
                                  "sourceLanguage": z.string().describe(
                                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                                  ).optional(),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "A region within an artifact where a result was detected.",
                                ),
                              ).min(0).describe(
                                "A set of regions relevant to the location.",
                              ).default([]),
                              "relationships": z.array(
                                z.object({
                                  "target": z.number().int().gte(0).describe(
                                    "A reference to the related location.",
                                  ),
                                  "kinds": z.array(z.string()).describe(
                                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                                  ).default(["relevant"]),
                                  "description": z.object({
                                    "text": z.string().describe(
                                      "A plain text message string.",
                                    ).optional(),
                                    "markdown": z.string().describe(
                                      "A Markdown message string.",
                                    ).optional(),
                                    "id": z.string().describe(
                                      "The identifier for this message.",
                                    ).optional(),
                                    "arguments": z.array(z.string()).min(0)
                                      .describe(
                                        "An array of strings to substitute into the message string.",
                                      ).default([]),
                                    "properties": z.object({
                                      "tags": z.array(z.string()).min(0)
                                        .describe(
                                          "A set of distinct strings that provide additional information.",
                                        ).default([]),
                                    }).catchall(z.any()).describe(
                                      "Key/value pairs that provide additional information about the object.",
                                    ).optional(),
                                  }).strict().and(z.union([z.any(), z.any()]))
                                    .describe(
                                      "Encapsulates a message intended to be read by the end user.",
                                    ).optional(),
                                  "properties": z.object({
                                    "tags": z.array(z.string()).min(0).describe(
                                      "A set of distinct strings that provide additional information.",
                                    ).default([]),
                                  }).catchall(z.any()).describe(
                                    "Key/value pairs that provide additional information about the object.",
                                  ).optional(),
                                }).strict().describe(
                                  "Information about the relation of one location to another.",
                                ),
                              ).min(0).describe(
                                "An array of objects that describe relationships between this location and others.",
                              ).default([]),
                              "properties": z.object({
                                "tags": z.array(z.string()).min(0).describe(
                                  "A set of distinct strings that provide additional information.",
                                ).default([]),
                              }).catchall(z.any()).describe(
                                "Key/value pairs that provide additional information about the object.",
                              ).optional(),
                            }).strict().describe(
                              "A location within a programming artifact.",
                            ).optional(),
                            "module": z.string().describe(
                              "The name of the module that contains the code of this stack frame.",
                            ).optional(),
                            "threadId": z.number().int().describe(
                              "The thread identifier of the stack frame.",
                            ).optional(),
                            "parameters": z.array(z.string().default([])).min(0)
                              .describe(
                                "The parameters of the call that is executing.",
                              ).default([]),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A function call within a stack trace.",
                          ),
                        ).min(0).describe(
                          "An array of stack frames that represents a sequence of calls, rendered in reverse chronological order, that comprise the call stack.",
                        ),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A call stack that is relevant to a result.",
                      ).optional(),
                      "kinds": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that categorize the thread flow location. Well-known kinds include 'acquire', 'release', 'enter', 'exit', 'call', 'return', 'branch', 'implicit', 'false', 'true', 'caution', 'danger', 'unknown', 'unreachable', 'taint', 'function', 'handler', 'lock', 'memory', 'resource', 'scope' and 'value'.",
                      ).default([]),
                      "taxa": z.array(
                        z.object({
                          "id": z.string().describe("The id of the descriptor.")
                            .optional(),
                          "index": z.number().int().gte(-1).describe(
                            "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                          ).default(-1),
                          "guid": z.string().regex(
                            new RegExp(
                              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                            ),
                          ).describe(
                            "A guid that uniquely identifies the descriptor.",
                          ).optional(),
                          "toolComponent": z.object({
                            "name": z.string().describe(
                              "The 'name' property of the referenced toolComponent.",
                            ).optional(),
                            "index": z.number().int().gte(-1).describe(
                              "An index into the referenced toolComponent in tool.extensions.",
                            ).default(-1),
                            "guid": z.string().regex(
                              new RegExp(
                                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                              ),
                            ).describe(
                              "The 'guid' property of the referenced toolComponent.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "Identifies a particular toolComponent object, either the driver or an extension.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any(), z.any()]))
                          .describe(
                            "Information about how to locate a relevant reporting descriptor.",
                          ),
                      ).min(0).describe(
                        "An array of references to rule or taxonomy reporting descriptors that are applicable to the thread flow location.",
                      ).default([]),
                      "module": z.string().describe(
                        "The name of the module that contains the code that is executing.",
                      ).optional(),
                      "state": z.record(
                        z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ),
                      ).describe(
                        "A dictionary, each of whose keys specifies a variable or expression, the associated value of which represents the variable or expression value. For an annotation of kind 'continuation', for example, this dictionary might hold the current assumed values of a set of global variables.",
                      ).optional(),
                      "nestingLevel": z.number().int().gte(0).describe(
                        "An integer representing a containment hierarchy within the thread flow.",
                      ).optional(),
                      "executionOrder": z.number().int().gte(-1).describe(
                        "An integer representing the temporal order in which execution reached this location.",
                      ).default(-1),
                      "executionTimeUtc": z.string().datetime({ offset: true })
                        .describe(
                          "The Coordinated Universal Time (UTC) date and time at which this location was executed.",
                        ).optional(),
                      "importance": z.enum([
                        "important",
                        "essential",
                        "unimportant",
                      ]).describe(
                        'Specifies the importance of this location in understanding the code flow in which it occurs. The order from most to least important is "essential", "important", "unimportant". Default: "important".',
                      ).default("important"),
                      "webRequest": z.object({
                        "index": z.number().int().gte(-1).describe(
                          "The index within the run.webRequests array of the request object associated with this result.",
                        ).default(-1),
                        "protocol": z.string().describe(
                          "The request protocol. Example: 'http'.",
                        ).optional(),
                        "version": z.string().describe(
                          "The request version. Example: '1.1'.",
                        ).optional(),
                        "target": z.string().describe(
                          "The target of the request.",
                        ).optional(),
                        "method": z.string().describe(
                          "The HTTP method. Well-known values are 'GET', 'PUT', 'POST', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'.",
                        ).optional(),
                        "headers": z.record(z.string()).describe(
                          "The request headers.",
                        ).optional(),
                        "parameters": z.record(z.string()).describe(
                          "The request parameters.",
                        ).optional(),
                        "body": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe("Describes an HTTP request.")
                        .optional(),
                      "webResponse": z.object({
                        "index": z.number().int().gte(-1).describe(
                          "The index within the run.webResponses array of the response object associated with this result.",
                        ).default(-1),
                        "protocol": z.string().describe(
                          "The response protocol. Example: 'http'.",
                        ).optional(),
                        "version": z.string().describe(
                          "The response version. Example: '1.1'.",
                        ).optional(),
                        "statusCode": z.number().int().describe(
                          "The response status code. Example: 451.",
                        ).optional(),
                        "reasonPhrase": z.string().describe(
                          "The response reason. Example: 'Not found'.",
                        ).optional(),
                        "headers": z.record(z.string()).describe(
                          "The response headers.",
                        ).optional(),
                        "body": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "noResponseReceived": z.boolean().describe(
                          "Specifies whether a response was received from the server.",
                        ).default(false),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Describes the response to an HTTP request.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A location visited by an analysis tool while simulating or monitoring the execution of a program.",
                    ),
                  ).min(1).describe(
                    "A temporally ordered array of 'threadFlowLocation' objects, each of which describes a location visited by the tool while producing the result.",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Describes a sequence of code locations that specify a path through a single thread of execution such as an operating system or fiber.",
                ),
              ).min(1).describe(
                "An array of one or more unique threadFlow objects, each of which describes the progress of a program through a thread of execution.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A set of threadFlows which together describe a pattern of code execution relevant to detecting a result.",
            ),
          ).min(0).describe(
            "An array of 'codeFlow' objects relevant to the result.",
          ).default([]),
          "graphs": z.array(
            z.object({
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "nodes": z.array(
                z.object({
                  "id": z.string().describe(
                    "A string that uniquely identifies the node within its graph.",
                  ),
                  "label": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "location": z.object({
                    "id": z.number().int().gte(-1).describe(
                      "Value that distinguishes this location from all other locations within a single result object.",
                    ).default(-1),
                    "physicalLocation": z.object({
                      "address": z.object({
                        "absoluteAddress": z.number().int().gte(-1).describe(
                          "The address expressed as a byte offset from the start of the addressable region.",
                        ).default(-1),
                        "relativeAddress": z.number().int().describe(
                          "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                        ).optional(),
                        "length": z.number().int().describe(
                          "The number of bytes in this range of addresses.",
                        ).optional(),
                        "kind": z.string().describe(
                          "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                        ).optional(),
                        "name": z.string().describe(
                          "A name that is associated with the address, e.g., '.text'.",
                        ).optional(),
                        "fullyQualifiedName": z.string().describe(
                          "A human-readable fully qualified name that is associated with the address.",
                        ).optional(),
                        "offsetFromParent": z.number().int().describe(
                          "The byte offset of this address from the absolute or relative address of the parent object.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index within run.addresses of the cached object for this address.",
                        ).default(-1),
                        "parentIndex": z.number().int().gte(-1).describe(
                          "The index within run.addresses of the parent object.",
                        ).default(-1),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                      ).optional(),
                      "artifactLocation": z.object({
                        "uri": z.string().describe(
                          "A string containing a valid relative or absolute URI.",
                        ).optional(),
                        "uriBaseId": z.string().describe(
                          'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index within the run artifacts array of the artifact object associated with the artifact location.",
                        ).default(-1),
                        "description": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Specifies the location of an artifact.",
                      ).optional(),
                      "region": z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ).optional(),
                      "contextRegion": z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                    ).optional(),
                    "logicalLocations": z.array(
                      z.object({
                        "name": z.string().describe(
                          "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                        ).optional(),
                        "index": z.number().int().gte(-1).describe(
                          "The index within the logical locations array.",
                        ).default(-1),
                        "fullyQualifiedName": z.string().describe(
                          "The human-readable fully qualified name of the logical location.",
                        ).optional(),
                        "decoratedName": z.string().describe(
                          "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                        ).optional(),
                        "parentIndex": z.number().int().gte(-1).describe(
                          "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                        ).default(-1),
                        "kind": z.string().describe(
                          "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A logical location of a construct that produced a result.",
                      ),
                    ).min(0).describe(
                      "The logical locations associated with the result.",
                    ).default([]),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "annotations": z.array(
                      z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ),
                    ).min(0).describe(
                      "A set of regions relevant to the location.",
                    ).default([]),
                    "relationships": z.array(
                      z.object({
                        "target": z.number().int().gte(0).describe(
                          "A reference to the related location.",
                        ),
                        "kinds": z.array(z.string()).describe(
                          "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                        ).default(["relevant"]),
                        "description": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Information about the relation of one location to another.",
                      ),
                    ).min(0).describe(
                      "An array of objects that describe relationships between this location and others.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A location within a programming artifact.",
                  ).optional(),
                  "children": z.array(z.any()).min(0).describe(
                    "Array of child nodes.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Represents a node in a graph."),
              ).min(0).describe(
                "An array of node objects representing the nodes of the graph.",
              ).default([]),
              "edges": z.array(
                z.object({
                  "id": z.string().describe(
                    "A string that uniquely identifies the edge within its graph.",
                  ),
                  "label": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceNodeId": z.string().describe(
                    "Identifies the source node (the node at which the edge starts).",
                  ),
                  "targetNodeId": z.string().describe(
                    "Identifies the target node (the node at which the edge ends).",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Represents a directed edge in a graph."),
              ).min(0).describe(
                "An array of edge objects representing the edges of the graph.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A network of nodes and directed edges that describes some aspect of the structure of the code (for example, a call graph).",
            ),
          ).min(0).describe(
            "An array of zero or more unique graph objects associated with the result.",
          ).default([]),
          "graphTraversals": z.array(
            z.object({
              "runGraphIndex": z.number().int().gte(-1).describe(
                "The index within the run.graphs to be associated with the result.",
              ).default(-1),
              "resultGraphIndex": z.number().int().gte(-1).describe(
                "The index within the result.graphs to be associated with the result.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "initialState": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "Values of relevant expressions at the start of the graph traversal that may change during graph traversal.",
              ).optional(),
              "immutableState": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "Values of relevant expressions at the start of the graph traversal that remain constant for the graph traversal.",
              ).optional(),
              "edgeTraversals": z.array(
                z.object({
                  "edgeId": z.string().describe(
                    "Identifies the edge being traversed.",
                  ),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "finalState": z.record(
                    z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ),
                  ).describe(
                    "The values of relevant expressions after the edge has been traversed.",
                  ).optional(),
                  "stepOverEdgeCount": z.number().int().gte(0).describe(
                    "The number of edge traversals necessary to return from a nested graph.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Represents the traversal of a single edge during a graph traversal.",
                ),
              ).min(0).describe(
                "The sequences of edges traversed by this graph traversal.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(
              z.any().superRefine((x, ctx) => {
                const schemas = [z.any(), z.any()];
                const errors = schemas.reduce<z.ZodError[]>(
                  (errors, schema) =>
                    ((result) =>
                      result.error ? [...errors, result.error] : errors)(
                        schema.safeParse(x),
                      ),
                  [],
                );
                if (schemas.length - errors.length !== 1) {
                  ctx.addIssue({
                    path: ctx.path,
                    code: "invalid_union",
                    unionErrors: errors,
                    message: "Invalid input: Should pass single schema",
                  });
                }
              }),
            ).describe("Represents a path through a graph."),
          ).min(0).describe(
            "An array of one or more unique 'graphTraversal' objects.",
          ).default([]),
          "relatedLocations": z.array(
            z.object({
              "id": z.number().int().gte(-1).describe(
                "Value that distinguishes this location from all other locations within a single result object.",
              ).default(-1),
              "physicalLocation": z.object({
                "address": z.object({
                  "absoluteAddress": z.number().int().gte(-1).describe(
                    "The address expressed as a byte offset from the start of the addressable region.",
                  ).default(-1),
                  "relativeAddress": z.number().int().describe(
                    "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                  ).optional(),
                  "length": z.number().int().describe(
                    "The number of bytes in this range of addresses.",
                  ).optional(),
                  "kind": z.string().describe(
                    "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                  ).optional(),
                  "name": z.string().describe(
                    "A name that is associated with the address, e.g., '.text'.",
                  ).optional(),
                  "fullyQualifiedName": z.string().describe(
                    "A human-readable fully qualified name that is associated with the address.",
                  ).optional(),
                  "offsetFromParent": z.number().int().describe(
                    "The byte offset of this address from the absolute or relative address of the parent object.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within run.addresses of the cached object for this address.",
                  ).default(-1),
                  "parentIndex": z.number().int().gte(-1).describe(
                    "The index within run.addresses of the parent object.",
                  ).default(-1),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                ).optional(),
                "artifactLocation": z.object({
                  "uri": z.string().describe(
                    "A string containing a valid relative or absolute URI.",
                  ).optional(),
                  "uriBaseId": z.string().describe(
                    'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within the run artifacts array of the artifact object associated with the artifact location.",
                  ).default(-1),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Specifies the location of an artifact.")
                  .optional(),
                "region": z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ).optional(),
                "contextRegion": z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
              ).optional(),
              "logicalLocations": z.array(
                z.object({
                  "name": z.string().describe(
                    "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within the logical locations array.",
                  ).default(-1),
                  "fullyQualifiedName": z.string().describe(
                    "The human-readable fully qualified name of the logical location.",
                  ).optional(),
                  "decoratedName": z.string().describe(
                    "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                  ).optional(),
                  "parentIndex": z.number().int().gte(-1).describe(
                    "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                  ).default(-1),
                  "kind": z.string().describe(
                    "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A logical location of a construct that produced a result.",
                ),
              ).min(0).describe(
                "The logical locations associated with the result.",
              ).default([]),
              "message": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "annotations": z.array(
                z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ),
              ).min(0).describe("A set of regions relevant to the location.")
                .default([]),
              "relationships": z.array(
                z.object({
                  "target": z.number().int().gte(0).describe(
                    "A reference to the related location.",
                  ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one location to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this location and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("A location within a programming artifact."),
          ).min(0).describe("A set of locations relevant to this result.")
            .default([]),
          "suppressions": z.array(
            z.object({
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A stable, unique identifier for the suppression in the form of a GUID.",
              ).optional(),
              "kind": z.enum(["inSource", "external"]).describe(
                "A string that indicates where the suppression is persisted.",
              ),
              "state": z.enum(["accepted", "underReview", "rejected"]).describe(
                "A string that indicates the state of the suppression.",
              ).optional(),
              "justification": z.string().describe(
                "A string representing the justification for the suppression.",
              ).optional(),
              "location": z.object({
                "id": z.number().int().gte(-1).describe(
                  "Value that distinguishes this location from all other locations within a single result object.",
                ).default(-1),
                "physicalLocation": z.object({
                  "address": z.object({
                    "absoluteAddress": z.number().int().gte(-1).describe(
                      "The address expressed as a byte offset from the start of the addressable region.",
                    ).default(-1),
                    "relativeAddress": z.number().int().describe(
                      "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                    ).optional(),
                    "length": z.number().int().describe(
                      "The number of bytes in this range of addresses.",
                    ).optional(),
                    "kind": z.string().describe(
                      "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                    ).optional(),
                    "name": z.string().describe(
                      "A name that is associated with the address, e.g., '.text'.",
                    ).optional(),
                    "fullyQualifiedName": z.string().describe(
                      "A human-readable fully qualified name that is associated with the address.",
                    ).optional(),
                    "offsetFromParent": z.number().int().describe(
                      "The byte offset of this address from the absolute or relative address of the parent object.",
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within run.addresses of the cached object for this address.",
                    ).default(-1),
                    "parentIndex": z.number().int().gte(-1).describe(
                      "The index within run.addresses of the parent object.",
                    ).default(-1),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                  ).optional(),
                  "artifactLocation": z.object({
                    "uri": z.string().describe(
                      "A string containing a valid relative or absolute URI.",
                    ).optional(),
                    "uriBaseId": z.string().describe(
                      'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within the run artifacts array of the artifact object associated with the artifact location.",
                    ).default(-1),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe("Specifies the location of an artifact.")
                    .optional(),
                  "region": z.object({
                    "startLine": z.number().int().gte(1).describe(
                      "The line number of the first character in the region.",
                    ).optional(),
                    "startColumn": z.number().int().gte(1).describe(
                      "The column number of the first character in the region.",
                    ).optional(),
                    "endLine": z.number().int().gte(1).describe(
                      "The line number of the last character in the region.",
                    ).optional(),
                    "endColumn": z.number().int().gte(1).describe(
                      "The column number of the character following the end of the region.",
                    ).optional(),
                    "charOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                    ).default(-1),
                    "charLength": z.number().int().gte(0).describe(
                      "The length of the region in characters.",
                    ).optional(),
                    "byteOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                    ).default(-1),
                    "byteLength": z.number().int().gte(0).describe(
                      "The length of the region in bytes.",
                    ).optional(),
                    "snippet": z.object({
                      "text": z.string().describe(
                        "UTF-8-encoded content from a text artifact.",
                      ).optional(),
                      "binary": z.string().describe(
                        "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                      ).optional(),
                      "rendered": z.object({
                        "text": z.string().describe(
                          "A plain text message string or format string.",
                        ),
                        "markdown": z.string().describe(
                          "A Markdown message string or format string.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A message string or message format string rendered in multiple formats.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Represents the contents of an artifact.",
                    ).optional(),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "sourceLanguage": z.string().describe(
                      "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A region within an artifact where a result was detected.",
                  ).optional(),
                  "contextRegion": z.object({
                    "startLine": z.number().int().gte(1).describe(
                      "The line number of the first character in the region.",
                    ).optional(),
                    "startColumn": z.number().int().gte(1).describe(
                      "The column number of the first character in the region.",
                    ).optional(),
                    "endLine": z.number().int().gte(1).describe(
                      "The line number of the last character in the region.",
                    ).optional(),
                    "endColumn": z.number().int().gte(1).describe(
                      "The column number of the character following the end of the region.",
                    ).optional(),
                    "charOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                    ).default(-1),
                    "charLength": z.number().int().gte(0).describe(
                      "The length of the region in characters.",
                    ).optional(),
                    "byteOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                    ).default(-1),
                    "byteLength": z.number().int().gte(0).describe(
                      "The length of the region in bytes.",
                    ).optional(),
                    "snippet": z.object({
                      "text": z.string().describe(
                        "UTF-8-encoded content from a text artifact.",
                      ).optional(),
                      "binary": z.string().describe(
                        "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                      ).optional(),
                      "rendered": z.object({
                        "text": z.string().describe(
                          "A plain text message string or format string.",
                        ),
                        "markdown": z.string().describe(
                          "A Markdown message string or format string.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A message string or message format string rendered in multiple formats.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Represents the contents of an artifact.",
                    ).optional(),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "sourceLanguage": z.string().describe(
                      "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A region within an artifact where a result was detected.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
                ).optional(),
                "logicalLocations": z.array(
                  z.object({
                    "name": z.string().describe(
                      "Identifies the construct in which the result occurred. For example, this property might contain the name of a class or a method.",
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within the logical locations array.",
                    ).default(-1),
                    "fullyQualifiedName": z.string().describe(
                      "The human-readable fully qualified name of the logical location.",
                    ).optional(),
                    "decoratedName": z.string().describe(
                      "The machine-readable name for the logical location, such as a mangled function name provided by a C++ compiler that encodes calling convention, return type and other details along with the function name.",
                    ).optional(),
                    "parentIndex": z.number().int().gte(-1).describe(
                      "Identifies the index of the immediate parent of the construct in which the result was detected. For example, this property might point to a logical location that represents the namespace that holds a type.",
                    ).default(-1),
                    "kind": z.string().describe(
                      "The type of construct this logical location component refers to. Should be one of 'function', 'member', 'module', 'namespace', 'parameter', 'resource', 'returnType', 'type', 'variable', 'object', 'array', 'property', 'value', 'element', 'text', 'attribute', 'comment', 'declaration', 'dtd' or 'processingInstruction', if any of those accurately describe the construct.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A logical location of a construct that produced a result.",
                  ),
                ).min(0).describe(
                  "The logical locations associated with the result.",
                ).default([]),
                "message": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "annotations": z.array(
                  z.object({
                    "startLine": z.number().int().gte(1).describe(
                      "The line number of the first character in the region.",
                    ).optional(),
                    "startColumn": z.number().int().gte(1).describe(
                      "The column number of the first character in the region.",
                    ).optional(),
                    "endLine": z.number().int().gte(1).describe(
                      "The line number of the last character in the region.",
                    ).optional(),
                    "endColumn": z.number().int().gte(1).describe(
                      "The column number of the character following the end of the region.",
                    ).optional(),
                    "charOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first character in the region.",
                    ).default(-1),
                    "charLength": z.number().int().gte(0).describe(
                      "The length of the region in characters.",
                    ).optional(),
                    "byteOffset": z.number().int().gte(-1).describe(
                      "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                    ).default(-1),
                    "byteLength": z.number().int().gte(0).describe(
                      "The length of the region in bytes.",
                    ).optional(),
                    "snippet": z.object({
                      "text": z.string().describe(
                        "UTF-8-encoded content from a text artifact.",
                      ).optional(),
                      "binary": z.string().describe(
                        "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                      ).optional(),
                      "rendered": z.object({
                        "text": z.string().describe(
                          "A plain text message string or format string.",
                        ),
                        "markdown": z.string().describe(
                          "A Markdown message string or format string.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A message string or message format string rendered in multiple formats.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Represents the contents of an artifact.",
                    ).optional(),
                    "message": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "sourceLanguage": z.string().describe(
                      "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "A region within an artifact where a result was detected.",
                  ),
                ).min(0).describe("A set of regions relevant to the location.")
                  .default([]),
                "relationships": z.array(
                  z.object({
                    "target": z.number().int().gte(0).describe(
                      "A reference to the related location.",
                    ),
                    "kinds": z.array(z.string()).describe(
                      "A set of distinct strings that categorize the relationship. Well-known kinds include 'includes', 'isIncludedBy' and 'relevant'.",
                    ).default(["relevant"]),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Information about the relation of one location to another.",
                  ),
                ).min(0).describe(
                  "An array of objects that describe relationships between this location and others.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("A location within a programming artifact.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("A suppression that is relevant to a result."),
          ).min(0).describe("A set of suppressions relevant to this result.")
            .optional(),
          "baselineState": z.enum(["new", "unchanged", "updated", "absent"])
            .describe(
              "The state of a result relative to a baseline of a previous run.",
            ).optional(),
          "rank": z.number().gte(-1).lte(100).describe(
            "A number representing the priority or importance of the result.",
          ).default(-1),
          "attachments": z.array(
            z.object({
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "artifactLocation": z.object({
                "uri": z.string().describe(
                  "A string containing a valid relative or absolute URI.",
                ).optional(),
                "uriBaseId": z.string().describe(
                  'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "The index within the run artifacts array of the artifact object associated with the artifact location.",
                ).default(-1),
                "description": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe("Specifies the location of an artifact."),
              "regions": z.array(
                z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ),
              ).min(0).describe(
                "An array of regions of interest within the attachment.",
              ).default([]),
              "rectangles": z.array(
                z.object({
                  "top": z.number().describe(
                    "The Y coordinate of the top edge of the rectangle, measured in the image's natural units.",
                  ).optional(),
                  "left": z.number().describe(
                    "The X coordinate of the left edge of the rectangle, measured in the image's natural units.",
                  ).optional(),
                  "bottom": z.number().describe(
                    "The Y coordinate of the bottom edge of the rectangle, measured in the image's natural units.",
                  ).optional(),
                  "right": z.number().describe(
                    "The X coordinate of the right edge of the rectangle, measured in the image's natural units.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("An area within an image."),
              ).min(0).describe(
                "An array of rectangles specifying areas of interest within the image.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("An artifact relevant to a result."),
          ).min(0).describe("A set of artifacts relevant to the result.")
            .default([]),
          "hostedViewerUri": z.string().url().describe(
            "An absolute URI at which the result can be viewed.",
          ).optional(),
          "workItemUris": z.array(z.string().url()).min(0).describe(
            "The URIs of the work items associated with this result.",
          ).optional(),
          "provenance": z.object({
            "firstDetectionTimeUtc": z.string().datetime({ offset: true })
              .describe(
                'The Coordinated Universal Time (UTC) date and time at which the result was first detected. See "Date/time properties" in the SARIF spec for the required format.',
              ).optional(),
            "lastDetectionTimeUtc": z.string().datetime({ offset: true })
              .describe(
                'The Coordinated Universal Time (UTC) date and time at which the result was most recently detected. See "Date/time properties" in the SARIF spec for the required format.',
              ).optional(),
            "firstDetectionRunGuid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A GUID-valued string equal to the automationDetails.guid property of the run in which the result was first detected.",
            ).optional(),
            "lastDetectionRunGuid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A GUID-valued string equal to the automationDetails.guid property of the run in which the result was most recently detected.",
            ).optional(),
            "invocationIndex": z.number().int().gte(-1).describe(
              "The index within the run.invocations array of the invocation object which describes the tool invocation that detected the result.",
            ).default(-1),
            "conversionSources": z.array(
              z.object({
                "address": z.object({
                  "absoluteAddress": z.number().int().gte(-1).describe(
                    "The address expressed as a byte offset from the start of the addressable region.",
                  ).default(-1),
                  "relativeAddress": z.number().int().describe(
                    "The address expressed as a byte offset from the absolute address of the top-most parent object.",
                  ).optional(),
                  "length": z.number().int().describe(
                    "The number of bytes in this range of addresses.",
                  ).optional(),
                  "kind": z.string().describe(
                    "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
                  ).optional(),
                  "name": z.string().describe(
                    "A name that is associated with the address, e.g., '.text'.",
                  ).optional(),
                  "fullyQualifiedName": z.string().describe(
                    "A human-readable fully qualified name that is associated with the address.",
                  ).optional(),
                  "offsetFromParent": z.number().int().describe(
                    "The byte offset of this address from the absolute or relative address of the parent object.",
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within run.addresses of the cached object for this address.",
                  ).default(-1),
                  "parentIndex": z.number().int().gte(-1).describe(
                    "The index within run.addresses of the parent object.",
                  ).default(-1),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
                ).optional(),
                "artifactLocation": z.object({
                  "uri": z.string().describe(
                    "A string containing a valid relative or absolute URI.",
                  ).optional(),
                  "uriBaseId": z.string().describe(
                    'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                  ).optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index within the run artifacts array of the artifact object associated with the artifact location.",
                  ).default(-1),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("Specifies the location of an artifact.")
                  .optional(),
                "region": z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ).optional(),
                "contextRegion": z.object({
                  "startLine": z.number().int().gte(1).describe(
                    "The line number of the first character in the region.",
                  ).optional(),
                  "startColumn": z.number().int().gte(1).describe(
                    "The column number of the first character in the region.",
                  ).optional(),
                  "endLine": z.number().int().gte(1).describe(
                    "The line number of the last character in the region.",
                  ).optional(),
                  "endColumn": z.number().int().gte(1).describe(
                    "The column number of the character following the end of the region.",
                  ).optional(),
                  "charOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first character in the region.",
                  ).default(-1),
                  "charLength": z.number().int().gte(0).describe(
                    "The length of the region in characters.",
                  ).optional(),
                  "byteOffset": z.number().int().gte(-1).describe(
                    "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                  ).default(-1),
                  "byteLength": z.number().int().gte(0).describe(
                    "The length of the region in bytes.",
                  ).optional(),
                  "snippet": z.object({
                    "text": z.string().describe(
                      "UTF-8-encoded content from a text artifact.",
                    ).optional(),
                    "binary": z.string().describe(
                      "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                    ).optional(),
                    "rendered": z.object({
                      "text": z.string().describe(
                        "A plain text message string or format string.",
                      ),
                      "markdown": z.string().describe(
                        "A Markdown message string or format string.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "A message string or message format string rendered in multiple formats.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Represents the contents of an artifact.",
                  ).optional(),
                  "message": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "sourceLanguage": z.string().describe(
                    "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A region within an artifact where a result was detected.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "A physical location relevant to a result. Specifies a reference to a programming artifact together with a range of bytes or characters within that artifact.",
              ),
            ).min(0).describe(
              "An array of physicalLocation objects which specify the portions of an analysis tool's output that a converter transformed into the result.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Contains information about how and when a result was detected.",
          ).optional(),
          "fixes": z.array(
            z.object({
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "artifactChanges": z.array(
                z.object({
                  "artifactLocation": z.object({
                    "uri": z.string().describe(
                      "A string containing a valid relative or absolute URI.",
                    ).optional(),
                    "uriBaseId": z.string().describe(
                      'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index within the run artifacts array of the artifact object associated with the artifact location.",
                    ).default(-1),
                    "description": z.object({
                      "text": z.string().describe(
                        "A plain text message string.",
                      ).optional(),
                      "markdown": z.string().describe(
                        "A Markdown message string.",
                      ).optional(),
                      "id": z.string().describe(
                        "The identifier for this message.",
                      ).optional(),
                      "arguments": z.array(z.string()).min(0).describe(
                        "An array of strings to substitute into the message string.",
                      ).default([]),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().and(z.union([z.any(), z.any()])).describe(
                      "Encapsulates a message intended to be read by the end user.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Specifies the location of an artifact.",
                  ),
                  "replacements": z.array(
                    z.object({
                      "deletedRegion": z.object({
                        "startLine": z.number().int().gte(1).describe(
                          "The line number of the first character in the region.",
                        ).optional(),
                        "startColumn": z.number().int().gte(1).describe(
                          "The column number of the first character in the region.",
                        ).optional(),
                        "endLine": z.number().int().gte(1).describe(
                          "The line number of the last character in the region.",
                        ).optional(),
                        "endColumn": z.number().int().gte(1).describe(
                          "The column number of the character following the end of the region.",
                        ).optional(),
                        "charOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first character in the region.",
                        ).default(-1),
                        "charLength": z.number().int().gte(0).describe(
                          "The length of the region in characters.",
                        ).optional(),
                        "byteOffset": z.number().int().gte(-1).describe(
                          "The zero-based offset from the beginning of the artifact of the first byte in the region.",
                        ).default(-1),
                        "byteLength": z.number().int().gte(0).describe(
                          "The length of the region in bytes.",
                        ).optional(),
                        "snippet": z.object({
                          "text": z.string().describe(
                            "UTF-8-encoded content from a text artifact.",
                          ).optional(),
                          "binary": z.string().describe(
                            "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                          ).optional(),
                          "rendered": z.object({
                            "text": z.string().describe(
                              "A plain text message string or format string.",
                            ),
                            "markdown": z.string().describe(
                              "A Markdown message string or format string.",
                            ).optional(),
                            "properties": z.object({
                              "tags": z.array(z.string()).min(0).describe(
                                "A set of distinct strings that provide additional information.",
                              ).default([]),
                            }).catchall(z.any()).describe(
                              "Key/value pairs that provide additional information about the object.",
                            ).optional(),
                          }).strict().describe(
                            "A message string or message format string rendered in multiple formats.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "Represents the contents of an artifact.",
                        ).optional(),
                        "message": z.object({
                          "text": z.string().describe(
                            "A plain text message string.",
                          ).optional(),
                          "markdown": z.string().describe(
                            "A Markdown message string.",
                          ).optional(),
                          "id": z.string().describe(
                            "The identifier for this message.",
                          ).optional(),
                          "arguments": z.array(z.string()).min(0).describe(
                            "An array of strings to substitute into the message string.",
                          ).default([]),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().and(z.union([z.any(), z.any()])).describe(
                          "Encapsulates a message intended to be read by the end user.",
                        ).optional(),
                        "sourceLanguage": z.string().describe(
                          "Specifies the source language, if any, of the portion of the artifact specified by the region object.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "A region within an artifact where a result was detected.",
                      ),
                      "insertedContent": z.object({
                        "text": z.string().describe(
                          "UTF-8-encoded content from a text artifact.",
                        ).optional(),
                        "binary": z.string().describe(
                          "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
                        ).optional(),
                        "rendered": z.object({
                          "text": z.string().describe(
                            "A plain text message string or format string.",
                          ),
                          "markdown": z.string().describe(
                            "A Markdown message string or format string.",
                          ).optional(),
                          "properties": z.object({
                            "tags": z.array(z.string()).min(0).describe(
                              "A set of distinct strings that provide additional information.",
                            ).default([]),
                          }).catchall(z.any()).describe(
                            "Key/value pairs that provide additional information about the object.",
                          ).optional(),
                        }).strict().describe(
                          "A message string or message format string rendered in multiple formats.",
                        ).optional(),
                        "properties": z.object({
                          "tags": z.array(z.string()).min(0).describe(
                            "A set of distinct strings that provide additional information.",
                          ).default([]),
                        }).catchall(z.any()).describe(
                          "Key/value pairs that provide additional information about the object.",
                        ).optional(),
                      }).strict().describe(
                        "Represents the contents of an artifact.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "The replacement of a single region of an artifact.",
                    ),
                  ).min(1).describe(
                    "An array of replacement objects, each of which represents the replacement of a single region in a single artifact specified by 'artifactLocation'.",
                  ),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe("A change to a single artifact."),
              ).min(1).describe(
                "One or more artifact changes that comprise a fix for a result.",
              ),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A proposed fix for the problem represented by a result object. A fix specifies a set of artifacts to modify. For each artifact, it specifies a set of bytes to remove, and provides a set of new bytes to replace them.",
            ),
          ).min(0).describe(
            "An array of 'fix' objects, each of which represents a proposed fix to the problem indicated by the result.",
          ).default([]),
          "taxa": z.array(
            z.object({
              "id": z.string().describe("The id of the descriptor.").optional(),
              "index": z.number().int().gte(-1).describe(
                "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("A guid that uniquely identifies the descriptor.")
                .optional(),
              "toolComponent": z.object({
                "name": z.string().describe(
                  "The 'name' property of the referenced toolComponent.",
                ).optional(),
                "index": z.number().int().gte(-1).describe(
                  "An index into the referenced toolComponent in tool.extensions.",
                ).default(-1),
                "guid": z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ).describe(
                  "The 'guid' property of the referenced toolComponent.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Identifies a particular toolComponent object, either the driver or an extension.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
              "Information about how to locate a relevant reporting descriptor.",
            ),
          ).min(0).describe(
            "An array of references to taxonomy reporting descriptors that are applicable to the result.",
          ).default([]),
          "webRequest": z.object({
            "index": z.number().int().gte(-1).describe(
              "The index within the run.webRequests array of the request object associated with this result.",
            ).default(-1),
            "protocol": z.string().describe(
              "The request protocol. Example: 'http'.",
            ).optional(),
            "version": z.string().describe(
              "The request version. Example: '1.1'.",
            ).optional(),
            "target": z.string().describe("The target of the request.")
              .optional(),
            "method": z.string().describe(
              "The HTTP method. Well-known values are 'GET', 'PUT', 'POST', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'.",
            ).optional(),
            "headers": z.record(z.string()).describe("The request headers.")
              .optional(),
            "parameters": z.record(z.string()).describe(
              "The request parameters.",
            ).optional(),
            "body": z.object({
              "text": z.string().describe(
                "UTF-8-encoded content from a text artifact.",
              ).optional(),
              "binary": z.string().describe(
                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
              ).optional(),
              "rendered": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Represents the contents of an artifact.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Describes an HTTP request.").optional(),
          "webResponse": z.object({
            "index": z.number().int().gte(-1).describe(
              "The index within the run.webResponses array of the response object associated with this result.",
            ).default(-1),
            "protocol": z.string().describe(
              "The response protocol. Example: 'http'.",
            ).optional(),
            "version": z.string().describe(
              "The response version. Example: '1.1'.",
            ).optional(),
            "statusCode": z.number().int().describe(
              "The response status code. Example: 451.",
            ).optional(),
            "reasonPhrase": z.string().describe(
              "The response reason. Example: 'Not found'.",
            ).optional(),
            "headers": z.record(z.string()).describe("The response headers.")
              .optional(),
            "body": z.object({
              "text": z.string().describe(
                "UTF-8-encoded content from a text artifact.",
              ).optional(),
              "binary": z.string().describe(
                "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
              ).optional(),
              "rendered": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Represents the contents of an artifact.")
              .optional(),
            "noResponseReceived": z.boolean().describe(
              "Specifies whether a response was received from the server.",
            ).default(false),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Describes the response to an HTTP request.")
            .optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe("A result produced by an analysis tool."),
      ).min(0).describe(
        "An array of result objects that will be merged with a separate run.",
      ).default([]),
      "taxonomies": z.array(
        z.object({
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A unique identifier for the tool component in the form of a GUID.",
          ).optional(),
          "name": z.string().describe("The name of the tool component."),
          "organization": z.string().describe(
            "The organization or company that produced the tool component.",
          ).optional(),
          "product": z.string().describe(
            "A product suite to which the tool component belongs.",
          ).optional(),
          "productSuite": z.string().describe(
            "A localizable string containing the name of the suite of products to which the tool component belongs.",
          ).optional(),
          "shortDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullName": z.string().describe(
            "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
          ).optional(),
          "version": z.string().describe(
            "The tool component version, in whatever format the component natively provides.",
          ).optional(),
          "semanticVersion": z.string().describe(
            "The tool component version in the format specified by Semantic Versioning 2.0.",
          ).optional(),
          "dottedQuadFileVersion": z.string().regex(
            new RegExp("[0-9]+(\\.[0-9]+){3}"),
          ).describe(
            "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
          ).optional(),
          "releaseDateUtc": z.string().describe(
            "A string specifying the UTC date (and optionally, the time) of the component's release.",
          ).optional(),
          "downloadUri": z.string().url().describe(
            "The absolute URI from which the tool component can be downloaded.",
          ).optional(),
          "informationUri": z.string().url().describe(
            "The absolute URI at which information about this version of the tool component can be found.",
          ).optional(),
          "globalMessageStrings": z.record(
            z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ),
          ).describe(
            "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
          ).optional(),
          "notifications": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
          ).default([]),
          "rules": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
          ).default([]),
          "taxa": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
          ).default([]),
          "locations": z.array(
            z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact."),
          ).min(0).describe(
            "An array of the artifactLocation objects associated with the tool component.",
          ).default([]),
          "language": z.string().regex(
            new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
          ).describe(
            "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
          ).default("en-US"),
          "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
            .describe("The kinds of data contained in this object.").default([
              "localizedData",
              "nonLocalizedData",
            ]),
          "isComprehensive": z.boolean().describe(
            "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
          ).default(false),
          "localizedDataSemanticVersion": z.string().describe(
            "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
          ).optional(),
          "minimumRequiredLocalizedDataSemanticVersion": z.string().describe(
            "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
          ).optional(),
          "associatedComponent": z.object({
            "name": z.string().describe(
              "The 'name' property of the referenced toolComponent.",
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "An index into the referenced toolComponent in tool.extensions.",
            ).default(-1),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe("The 'guid' property of the referenced toolComponent.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Identifies a particular toolComponent object, either the driver or an extension.",
          ).optional(),
          "translationMetadata": z.object({
            "name": z.string().describe(
              "The name associated with the translation metadata.",
            ),
            "fullName": z.string().describe(
              "The full name associated with the translation metadata.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "downloadUri": z.string().url().describe(
              "The absolute URI from which the translation metadata can be downloaded.",
            ).optional(),
            "informationUri": z.string().url().describe(
              "The absolute URI from which information related to the translation metadata can be downloaded.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Provides additional metadata related to translation.",
          ).optional(),
          "supportedTaxonomies": z.array(
            z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ),
          ).min(0).describe(
            "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A component, such as a plug-in or the driver, of the analysis tool that was run.",
        ),
      ).min(0).describe(
        "Tool taxonomies that will be merged with a separate run.",
      ).default([]),
      "driver": z.object({
        "guid": z.string().regex(
          new RegExp(
            "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
          ),
        ).describe(
          "A unique identifier for the tool component in the form of a GUID.",
        ).optional(),
        "name": z.string().describe("The name of the tool component."),
        "organization": z.string().describe(
          "The organization or company that produced the tool component.",
        ).optional(),
        "product": z.string().describe(
          "A product suite to which the tool component belongs.",
        ).optional(),
        "productSuite": z.string().describe(
          "A localizable string containing the name of the suite of products to which the tool component belongs.",
        ).optional(),
        "shortDescription": z.object({
          "text": z.string().describe(
            "A plain text message string or format string.",
          ),
          "markdown": z.string().describe(
            "A Markdown message string or format string.",
          ).optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A message string or message format string rendered in multiple formats.",
        ).optional(),
        "fullDescription": z.object({
          "text": z.string().describe(
            "A plain text message string or format string.",
          ),
          "markdown": z.string().describe(
            "A Markdown message string or format string.",
          ).optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A message string or message format string rendered in multiple formats.",
        ).optional(),
        "fullName": z.string().describe(
          "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
        ).optional(),
        "version": z.string().describe(
          "The tool component version, in whatever format the component natively provides.",
        ).optional(),
        "semanticVersion": z.string().describe(
          "The tool component version in the format specified by Semantic Versioning 2.0.",
        ).optional(),
        "dottedQuadFileVersion": z.string().regex(
          new RegExp("[0-9]+(\\.[0-9]+){3}"),
        ).describe(
          "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
        ).optional(),
        "releaseDateUtc": z.string().describe(
          "A string specifying the UTC date (and optionally, the time) of the component's release.",
        ).optional(),
        "downloadUri": z.string().url().describe(
          "The absolute URI from which the tool component can be downloaded.",
        ).optional(),
        "informationUri": z.string().url().describe(
          "The absolute URI at which information about this version of the tool component can be found.",
        ).optional(),
        "globalMessageStrings": z.record(
          z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ),
        ).describe(
          "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
        ).optional(),
        "notifications": z.array(
          z.object({
            "id": z.string().describe(
              "A stable, opaque identifier for the report.",
            ),
            "deprecatedIds": z.array(z.string()).min(0).describe(
              "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
            ).optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A unique identifier for the reporting descriptor in the form of a GUID.",
            ).optional(),
            "deprecatedGuids": z.array(
              z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ),
            ).min(0).describe(
              "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
            ).optional(),
            "name": z.string().describe(
              "A report identifier that is understandable to an end user.",
            ).optional(),
            "deprecatedNames": z.array(z.string()).min(0).describe(
              "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "messageStrings": z.record(
              z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ),
            ).describe(
              "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
            ).optional(),
            "defaultConfiguration": z.object({
              "enabled": z.boolean().describe(
                "Specifies whether the report may be produced during the scan.",
              ).default(true),
              "level": z.enum(["none", "note", "warning", "error"]).describe(
                "Specifies the failure level for the report.",
              ).default("warning"),
              "rank": z.number().gte(-1).lte(100).describe(
                "Specifies the relative priority of the report. Used for analysis output only.",
              ).default(-1),
              "parameters": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Information about a rule or notification that can be configured at runtime.",
            ).optional(),
            "helpUri": z.string().url().describe(
              "A URI where the primary documentation for the report can be found.",
            ).optional(),
            "help": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "relationships": z.array(
              z.object({
                "target": z.object({
                  "id": z.string().describe("The id of the descriptor.")
                    .optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe("A guid that uniquely identifies the descriptor.")
                    .optional(),
                  "toolComponent": z.object({
                    "name": z.string().describe(
                      "The 'name' property of the referenced toolComponent.",
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "An index into the referenced toolComponent in tool.extensions.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "The 'guid' property of the referenced toolComponent.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Identifies a particular toolComponent object, either the driver or an extension.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                  "Information about how to locate a relevant reporting descriptor.",
                ),
                "kinds": z.array(z.string()).describe(
                  "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                ).default(["relevant"]),
                "description": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about the relation of one reporting descriptor to another.",
              ),
            ).min(0).describe(
              "An array of objects that describe relationships between this reporting descriptor and others.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
          ),
        ).min(0).describe(
          "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
        ).default([]),
        "rules": z.array(
          z.object({
            "id": z.string().describe(
              "A stable, opaque identifier for the report.",
            ),
            "deprecatedIds": z.array(z.string()).min(0).describe(
              "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
            ).optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A unique identifier for the reporting descriptor in the form of a GUID.",
            ).optional(),
            "deprecatedGuids": z.array(
              z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ),
            ).min(0).describe(
              "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
            ).optional(),
            "name": z.string().describe(
              "A report identifier that is understandable to an end user.",
            ).optional(),
            "deprecatedNames": z.array(z.string()).min(0).describe(
              "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "messageStrings": z.record(
              z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ),
            ).describe(
              "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
            ).optional(),
            "defaultConfiguration": z.object({
              "enabled": z.boolean().describe(
                "Specifies whether the report may be produced during the scan.",
              ).default(true),
              "level": z.enum(["none", "note", "warning", "error"]).describe(
                "Specifies the failure level for the report.",
              ).default("warning"),
              "rank": z.number().gte(-1).lte(100).describe(
                "Specifies the relative priority of the report. Used for analysis output only.",
              ).default(-1),
              "parameters": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Information about a rule or notification that can be configured at runtime.",
            ).optional(),
            "helpUri": z.string().url().describe(
              "A URI where the primary documentation for the report can be found.",
            ).optional(),
            "help": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "relationships": z.array(
              z.object({
                "target": z.object({
                  "id": z.string().describe("The id of the descriptor.")
                    .optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe("A guid that uniquely identifies the descriptor.")
                    .optional(),
                  "toolComponent": z.object({
                    "name": z.string().describe(
                      "The 'name' property of the referenced toolComponent.",
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "An index into the referenced toolComponent in tool.extensions.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "The 'guid' property of the referenced toolComponent.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Identifies a particular toolComponent object, either the driver or an extension.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                  "Information about how to locate a relevant reporting descriptor.",
                ),
                "kinds": z.array(z.string()).describe(
                  "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                ).default(["relevant"]),
                "description": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about the relation of one reporting descriptor to another.",
              ),
            ).min(0).describe(
              "An array of objects that describe relationships between this reporting descriptor and others.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
          ),
        ).min(0).describe(
          "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
        ).default([]),
        "taxa": z.array(
          z.object({
            "id": z.string().describe(
              "A stable, opaque identifier for the report.",
            ),
            "deprecatedIds": z.array(z.string()).min(0).describe(
              "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
            ).optional(),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe(
              "A unique identifier for the reporting descriptor in the form of a GUID.",
            ).optional(),
            "deprecatedGuids": z.array(
              z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ),
            ).min(0).describe(
              "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
            ).optional(),
            "name": z.string().describe(
              "A report identifier that is understandable to an end user.",
            ).optional(),
            "deprecatedNames": z.array(z.string()).min(0).describe(
              "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "messageStrings": z.record(
              z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ),
            ).describe(
              "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
            ).optional(),
            "defaultConfiguration": z.object({
              "enabled": z.boolean().describe(
                "Specifies whether the report may be produced during the scan.",
              ).default(true),
              "level": z.enum(["none", "note", "warning", "error"]).describe(
                "Specifies the failure level for the report.",
              ).default("warning"),
              "rank": z.number().gte(-1).lte(100).describe(
                "Specifies the relative priority of the report. Used for analysis output only.",
              ).default(-1),
              "parameters": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Information about a rule or notification that can be configured at runtime.",
            ).optional(),
            "helpUri": z.string().url().describe(
              "A URI where the primary documentation for the report can be found.",
            ).optional(),
            "help": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "relationships": z.array(
              z.object({
                "target": z.object({
                  "id": z.string().describe("The id of the descriptor.")
                    .optional(),
                  "index": z.number().int().gte(-1).describe(
                    "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                  ).default(-1),
                  "guid": z.string().regex(
                    new RegExp(
                      "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                    ),
                  ).describe("A guid that uniquely identifies the descriptor.")
                    .optional(),
                  "toolComponent": z.object({
                    "name": z.string().describe(
                      "The 'name' property of the referenced toolComponent.",
                    ).optional(),
                    "index": z.number().int().gte(-1).describe(
                      "An index into the referenced toolComponent in tool.extensions.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "The 'guid' property of the referenced toolComponent.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().describe(
                    "Identifies a particular toolComponent object, either the driver or an extension.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any(), z.any()])).describe(
                  "Information about how to locate a relevant reporting descriptor.",
                ),
                "kinds": z.array(z.string()).describe(
                  "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                ).default(["relevant"]),
                "description": z.object({
                  "text": z.string().describe("A plain text message string.")
                    .optional(),
                  "markdown": z.string().describe("A Markdown message string.")
                    .optional(),
                  "id": z.string().describe("The identifier for this message.")
                    .optional(),
                  "arguments": z.array(z.string()).min(0).describe(
                    "An array of strings to substitute into the message string.",
                  ).default([]),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().and(z.union([z.any(), z.any()])).describe(
                  "Encapsulates a message intended to be read by the end user.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about the relation of one reporting descriptor to another.",
              ),
            ).min(0).describe(
              "An array of objects that describe relationships between this reporting descriptor and others.",
            ).default([]),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
          ),
        ).min(0).describe(
          "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
        ).default([]),
        "locations": z.array(
          z.object({
            "uri": z.string().describe(
              "A string containing a valid relative or absolute URI.",
            ).optional(),
            "uriBaseId": z.string().describe(
              'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "The index within the run artifacts array of the artifact object associated with the artifact location.",
            ).default(-1),
            "description": z.object({
              "text": z.string().describe("A plain text message string.")
                .optional(),
              "markdown": z.string().describe("A Markdown message string.")
                .optional(),
              "id": z.string().describe("The identifier for this message.")
                .optional(),
              "arguments": z.array(z.string()).min(0).describe(
                "An array of strings to substitute into the message string.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().and(z.union([z.any(), z.any()])).describe(
              "Encapsulates a message intended to be read by the end user.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Specifies the location of an artifact."),
        ).min(0).describe(
          "An array of the artifactLocation objects associated with the tool component.",
        ).default([]),
        "language": z.string().regex(
          new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
        ).describe(
          "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
        ).default("en-US"),
        "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
          .describe("The kinds of data contained in this object.").default([
            "localizedData",
            "nonLocalizedData",
          ]),
        "isComprehensive": z.boolean().describe(
          "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
        ).default(false),
        "localizedDataSemanticVersion": z.string().describe(
          "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
        ).optional(),
        "minimumRequiredLocalizedDataSemanticVersion": z.string().describe(
          "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
        ).optional(),
        "associatedComponent": z.object({
          "name": z.string().describe(
            "The 'name' property of the referenced toolComponent.",
          ).optional(),
          "index": z.number().int().gte(-1).describe(
            "An index into the referenced toolComponent in tool.extensions.",
          ).default(-1),
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe("The 'guid' property of the referenced toolComponent.")
            .optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "Identifies a particular toolComponent object, either the driver or an extension.",
        ).optional(),
        "translationMetadata": z.object({
          "name": z.string().describe(
            "The name associated with the translation metadata.",
          ),
          "fullName": z.string().describe(
            "The full name associated with the translation metadata.",
          ).optional(),
          "shortDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "downloadUri": z.string().url().describe(
            "The absolute URI from which the translation metadata can be downloaded.",
          ).optional(),
          "informationUri": z.string().url().describe(
            "The absolute URI from which information related to the translation metadata can be downloaded.",
          ).optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "Provides additional metadata related to translation.",
        ).optional(),
        "supportedTaxonomies": z.array(
          z.object({
            "name": z.string().describe(
              "The 'name' property of the referenced toolComponent.",
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "An index into the referenced toolComponent in tool.extensions.",
            ).default(-1),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe("The 'guid' property of the referenced toolComponent.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Identifies a particular toolComponent object, either the driver or an extension.",
          ),
        ).min(0).describe(
          "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
        ).default([]),
        "properties": z.object({
          "tags": z.array(z.string()).min(0).describe(
            "A set of distinct strings that provide additional information.",
          ).default([]),
        }).catchall(z.any()).describe(
          "Key/value pairs that provide additional information about the object.",
        ).optional(),
      }).strict().describe(
        "A component, such as a plug-in or the driver, of the analysis tool that was run.",
      ).optional(),
      "extensions": z.array(
        z.object({
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A unique identifier for the tool component in the form of a GUID.",
          ).optional(),
          "name": z.string().describe("The name of the tool component."),
          "organization": z.string().describe(
            "The organization or company that produced the tool component.",
          ).optional(),
          "product": z.string().describe(
            "A product suite to which the tool component belongs.",
          ).optional(),
          "productSuite": z.string().describe(
            "A localizable string containing the name of the suite of products to which the tool component belongs.",
          ).optional(),
          "shortDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullName": z.string().describe(
            "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
          ).optional(),
          "version": z.string().describe(
            "The tool component version, in whatever format the component natively provides.",
          ).optional(),
          "semanticVersion": z.string().describe(
            "The tool component version in the format specified by Semantic Versioning 2.0.",
          ).optional(),
          "dottedQuadFileVersion": z.string().regex(
            new RegExp("[0-9]+(\\.[0-9]+){3}"),
          ).describe(
            "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
          ).optional(),
          "releaseDateUtc": z.string().describe(
            "A string specifying the UTC date (and optionally, the time) of the component's release.",
          ).optional(),
          "downloadUri": z.string().url().describe(
            "The absolute URI from which the tool component can be downloaded.",
          ).optional(),
          "informationUri": z.string().url().describe(
            "The absolute URI at which information about this version of the tool component can be found.",
          ).optional(),
          "globalMessageStrings": z.record(
            z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ),
          ).describe(
            "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
          ).optional(),
          "notifications": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
          ).default([]),
          "rules": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
          ).default([]),
          "taxa": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
          ).default([]),
          "locations": z.array(
            z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact."),
          ).min(0).describe(
            "An array of the artifactLocation objects associated with the tool component.",
          ).default([]),
          "language": z.string().regex(
            new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
          ).describe(
            "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
          ).default("en-US"),
          "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
            .describe("The kinds of data contained in this object.").default([
              "localizedData",
              "nonLocalizedData",
            ]),
          "isComprehensive": z.boolean().describe(
            "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
          ).default(false),
          "localizedDataSemanticVersion": z.string().describe(
            "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
          ).optional(),
          "minimumRequiredLocalizedDataSemanticVersion": z.string().describe(
            "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
          ).optional(),
          "associatedComponent": z.object({
            "name": z.string().describe(
              "The 'name' property of the referenced toolComponent.",
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "An index into the referenced toolComponent in tool.extensions.",
            ).default(-1),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe("The 'guid' property of the referenced toolComponent.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Identifies a particular toolComponent object, either the driver or an extension.",
          ).optional(),
          "translationMetadata": z.object({
            "name": z.string().describe(
              "The name associated with the translation metadata.",
            ),
            "fullName": z.string().describe(
              "The full name associated with the translation metadata.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "downloadUri": z.string().url().describe(
              "The absolute URI from which the translation metadata can be downloaded.",
            ).optional(),
            "informationUri": z.string().url().describe(
              "The absolute URI from which information related to the translation metadata can be downloaded.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Provides additional metadata related to translation.",
          ).optional(),
          "supportedTaxonomies": z.array(
            z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ),
          ).min(0).describe(
            "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A component, such as a plug-in or the driver, of the analysis tool that was run.",
        ),
      ).min(0).describe(
        "Tool extensions that will be merged with a separate run.",
      ).default([]),
      "policies": z.array(
        z.object({
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A unique identifier for the tool component in the form of a GUID.",
          ).optional(),
          "name": z.string().describe("The name of the tool component."),
          "organization": z.string().describe(
            "The organization or company that produced the tool component.",
          ).optional(),
          "product": z.string().describe(
            "A product suite to which the tool component belongs.",
          ).optional(),
          "productSuite": z.string().describe(
            "A localizable string containing the name of the suite of products to which the tool component belongs.",
          ).optional(),
          "shortDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullName": z.string().describe(
            "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
          ).optional(),
          "version": z.string().describe(
            "The tool component version, in whatever format the component natively provides.",
          ).optional(),
          "semanticVersion": z.string().describe(
            "The tool component version in the format specified by Semantic Versioning 2.0.",
          ).optional(),
          "dottedQuadFileVersion": z.string().regex(
            new RegExp("[0-9]+(\\.[0-9]+){3}"),
          ).describe(
            "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
          ).optional(),
          "releaseDateUtc": z.string().describe(
            "A string specifying the UTC date (and optionally, the time) of the component's release.",
          ).optional(),
          "downloadUri": z.string().url().describe(
            "The absolute URI from which the tool component can be downloaded.",
          ).optional(),
          "informationUri": z.string().url().describe(
            "The absolute URI at which information about this version of the tool component can be found.",
          ).optional(),
          "globalMessageStrings": z.record(
            z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ),
          ).describe(
            "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
          ).optional(),
          "notifications": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
          ).default([]),
          "rules": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
          ).default([]),
          "taxa": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
          ).default([]),
          "locations": z.array(
            z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact."),
          ).min(0).describe(
            "An array of the artifactLocation objects associated with the tool component.",
          ).default([]),
          "language": z.string().regex(
            new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
          ).describe(
            "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
          ).default("en-US"),
          "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
            .describe("The kinds of data contained in this object.").default([
              "localizedData",
              "nonLocalizedData",
            ]),
          "isComprehensive": z.boolean().describe(
            "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
          ).default(false),
          "localizedDataSemanticVersion": z.string().describe(
            "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
          ).optional(),
          "minimumRequiredLocalizedDataSemanticVersion": z.string().describe(
            "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
          ).optional(),
          "associatedComponent": z.object({
            "name": z.string().describe(
              "The 'name' property of the referenced toolComponent.",
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "An index into the referenced toolComponent in tool.extensions.",
            ).default(-1),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe("The 'guid' property of the referenced toolComponent.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Identifies a particular toolComponent object, either the driver or an extension.",
          ).optional(),
          "translationMetadata": z.object({
            "name": z.string().describe(
              "The name associated with the translation metadata.",
            ),
            "fullName": z.string().describe(
              "The full name associated with the translation metadata.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "downloadUri": z.string().url().describe(
              "The absolute URI from which the translation metadata can be downloaded.",
            ).optional(),
            "informationUri": z.string().url().describe(
              "The absolute URI from which information related to the translation metadata can be downloaded.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Provides additional metadata related to translation.",
          ).optional(),
          "supportedTaxonomies": z.array(
            z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ),
          ).min(0).describe(
            "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A component, such as a plug-in or the driver, of the analysis tool that was run.",
        ),
      ).min(0).describe(
        "Tool policies that will be merged with a separate run.",
      ).default([]),
      "translations": z.array(
        z.object({
          "guid": z.string().regex(
            new RegExp(
              "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
            ),
          ).describe(
            "A unique identifier for the tool component in the form of a GUID.",
          ).optional(),
          "name": z.string().describe("The name of the tool component."),
          "organization": z.string().describe(
            "The organization or company that produced the tool component.",
          ).optional(),
          "product": z.string().describe(
            "A product suite to which the tool component belongs.",
          ).optional(),
          "productSuite": z.string().describe(
            "A localizable string containing the name of the suite of products to which the tool component belongs.",
          ).optional(),
          "shortDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullDescription": z.object({
            "text": z.string().describe(
              "A plain text message string or format string.",
            ),
            "markdown": z.string().describe(
              "A Markdown message string or format string.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "A message string or message format string rendered in multiple formats.",
          ).optional(),
          "fullName": z.string().describe(
            "The name of the tool component along with its version and any other useful identifying information, such as its locale.",
          ).optional(),
          "version": z.string().describe(
            "The tool component version, in whatever format the component natively provides.",
          ).optional(),
          "semanticVersion": z.string().describe(
            "The tool component version in the format specified by Semantic Versioning 2.0.",
          ).optional(),
          "dottedQuadFileVersion": z.string().regex(
            new RegExp("[0-9]+(\\.[0-9]+){3}"),
          ).describe(
            "The binary version of the tool component's primary executable file expressed as four non-negative integers separated by a period (for operating systems that express file versions in this way).",
          ).optional(),
          "releaseDateUtc": z.string().describe(
            "A string specifying the UTC date (and optionally, the time) of the component's release.",
          ).optional(),
          "downloadUri": z.string().url().describe(
            "The absolute URI from which the tool component can be downloaded.",
          ).optional(),
          "informationUri": z.string().url().describe(
            "The absolute URI at which information about this version of the tool component can be found.",
          ).optional(),
          "globalMessageStrings": z.record(
            z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ),
          ).describe(
            "A dictionary, each of whose keys is a resource identifier and each of whose values is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
          ).optional(),
          "notifications": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the notifications related to the configuration and runtime execution of the tool component.",
          ).default([]),
          "rules": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the analysis performed by the tool component.",
          ).default([]),
          "taxa": z.array(
            z.object({
              "id": z.string().describe(
                "A stable, opaque identifier for the report.",
              ),
              "deprecatedIds": z.array(z.string()).min(0).describe(
                "An array of stable, opaque identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe(
                "A unique identifier for the reporting descriptor in the form of a GUID.",
              ).optional(),
              "deprecatedGuids": z.array(
                z.string().regex(
                  new RegExp(
                    "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                  ),
                ),
              ).min(0).describe(
                "An array of unique identifies in the form of a GUID by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "name": z.string().describe(
                "A report identifier that is understandable to an end user.",
              ).optional(),
              "deprecatedNames": z.array(z.string()).min(0).describe(
                "An array of readable identifiers by which this report was known in some previous version of the analysis tool.",
              ).optional(),
              "shortDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "fullDescription": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "messageStrings": z.record(
                z.object({
                  "text": z.string().describe(
                    "A plain text message string or format string.",
                  ),
                  "markdown": z.string().describe(
                    "A Markdown message string or format string.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "A message string or message format string rendered in multiple formats.",
                ),
              ).describe(
                "A set of name/value pairs with arbitrary names. Each value is a multiformatMessageString object, which holds message strings in plain text and (optionally) Markdown format. The strings can include placeholders, which can be used to construct a message in combination with an arbitrary number of additional string arguments.",
              ).optional(),
              "defaultConfiguration": z.object({
                "enabled": z.boolean().describe(
                  "Specifies whether the report may be produced during the scan.",
                ).default(true),
                "level": z.enum(["none", "note", "warning", "error"]).describe(
                  "Specifies the failure level for the report.",
                ).default("warning"),
                "rank": z.number().gte(-1).lte(100).describe(
                  "Specifies the relative priority of the report. Used for analysis output only.",
                ).default(-1),
                "parameters": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "Information about a rule or notification that can be configured at runtime.",
              ).optional(),
              "helpUri": z.string().url().describe(
                "A URI where the primary documentation for the report can be found.",
              ).optional(),
              "help": z.object({
                "text": z.string().describe(
                  "A plain text message string or format string.",
                ),
                "markdown": z.string().describe(
                  "A Markdown message string or format string.",
                ).optional(),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().describe(
                "A message string or message format string rendered in multiple formats.",
              ).optional(),
              "relationships": z.array(
                z.object({
                  "target": z.object({
                    "id": z.string().describe("The id of the descriptor.")
                      .optional(),
                    "index": z.number().int().gte(-1).describe(
                      "The index into an array of descriptors in toolComponent.ruleDescriptors, toolComponent.notificationDescriptors, or toolComponent.taxonomyDescriptors, depending on context.",
                    ).default(-1),
                    "guid": z.string().regex(
                      new RegExp(
                        "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                      ),
                    ).describe(
                      "A guid that uniquely identifies the descriptor.",
                    ).optional(),
                    "toolComponent": z.object({
                      "name": z.string().describe(
                        "The 'name' property of the referenced toolComponent.",
                      ).optional(),
                      "index": z.number().int().gte(-1).describe(
                        "An index into the referenced toolComponent in tool.extensions.",
                      ).default(-1),
                      "guid": z.string().regex(
                        new RegExp(
                          "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                        ),
                      ).describe(
                        "The 'guid' property of the referenced toolComponent.",
                      ).optional(),
                      "properties": z.object({
                        "tags": z.array(z.string()).min(0).describe(
                          "A set of distinct strings that provide additional information.",
                        ).default([]),
                      }).catchall(z.any()).describe(
                        "Key/value pairs that provide additional information about the object.",
                      ).optional(),
                    }).strict().describe(
                      "Identifies a particular toolComponent object, either the driver or an extension.",
                    ).optional(),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any(), z.any()]))
                    .describe(
                      "Information about how to locate a relevant reporting descriptor.",
                    ),
                  "kinds": z.array(z.string()).describe(
                    "A set of distinct strings that categorize the relationship. Well-known kinds include 'canPrecede', 'canFollow', 'willPrecede', 'willFollow', 'superset', 'subset', 'equal', 'disjoint', 'relevant', and 'incomparable'.",
                  ).default(["relevant"]),
                  "description": z.object({
                    "text": z.string().describe("A plain text message string.")
                      .optional(),
                    "markdown": z.string().describe(
                      "A Markdown message string.",
                    ).optional(),
                    "id": z.string().describe(
                      "The identifier for this message.",
                    ).optional(),
                    "arguments": z.array(z.string()).min(0).describe(
                      "An array of strings to substitute into the message string.",
                    ).default([]),
                    "properties": z.object({
                      "tags": z.array(z.string()).min(0).describe(
                        "A set of distinct strings that provide additional information.",
                      ).default([]),
                    }).catchall(z.any()).describe(
                      "Key/value pairs that provide additional information about the object.",
                    ).optional(),
                  }).strict().and(z.union([z.any(), z.any()])).describe(
                    "Encapsulates a message intended to be read by the end user.",
                  ).optional(),
                  "properties": z.object({
                    "tags": z.array(z.string()).min(0).describe(
                      "A set of distinct strings that provide additional information.",
                    ).default([]),
                  }).catchall(z.any()).describe(
                    "Key/value pairs that provide additional information about the object.",
                  ).optional(),
                }).strict().describe(
                  "Information about the relation of one reporting descriptor to another.",
                ),
              ).min(0).describe(
                "An array of objects that describe relationships between this reporting descriptor and others.",
              ).default([]),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Metadata that describes a specific report produced by the tool, as part of the analysis it provides or its runtime reporting.",
            ),
          ).min(0).describe(
            "An array of reportingDescriptor objects relevant to the definitions of both standalone and tool-defined taxonomies.",
          ).default([]),
          "locations": z.array(
            z.object({
              "uri": z.string().describe(
                "A string containing a valid relative or absolute URI.",
              ).optional(),
              "uriBaseId": z.string().describe(
                'A string which indirectly specifies the absolute URI with respect to which a relative URI in the "uri" property is interpreted.',
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "The index within the run artifacts array of the artifact object associated with the artifact location.",
              ).default(-1),
              "description": z.object({
                "text": z.string().describe("A plain text message string.")
                  .optional(),
                "markdown": z.string().describe("A Markdown message string.")
                  .optional(),
                "id": z.string().describe("The identifier for this message.")
                  .optional(),
                "arguments": z.array(z.string()).min(0).describe(
                  "An array of strings to substitute into the message string.",
                ).default([]),
                "properties": z.object({
                  "tags": z.array(z.string()).min(0).describe(
                    "A set of distinct strings that provide additional information.",
                  ).default([]),
                }).catchall(z.any()).describe(
                  "Key/value pairs that provide additional information about the object.",
                ).optional(),
              }).strict().and(z.union([z.any(), z.any()])).describe(
                "Encapsulates a message intended to be read by the end user.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe("Specifies the location of an artifact."),
          ).min(0).describe(
            "An array of the artifactLocation objects associated with the tool component.",
          ).default([]),
          "language": z.string().regex(
            new RegExp("^[a-zA-Z]{2}|^[a-zA-Z]{2}-[a-zA-Z]{2}?$"),
          ).describe(
            "The language of the messages emitted into the log file during this run (expressed as an ISO 639-1 two-letter lowercase language code) and an optional region (expressed as an ISO 3166-1 two-letter uppercase subculture code associated with a country or region). The casing is recommended but not required (in order for this data to conform to RFC5646).",
          ).default("en-US"),
          "contents": z.array(z.enum(["localizedData", "nonLocalizedData"]))
            .describe("The kinds of data contained in this object.").default([
              "localizedData",
              "nonLocalizedData",
            ]),
          "isComprehensive": z.boolean().describe(
            "Specifies whether this object contains a complete definition of the localizable and/or non-localizable data for this component, as opposed to including only data that is relevant to the results persisted to this log file.",
          ).default(false),
          "localizedDataSemanticVersion": z.string().describe(
            "The semantic version of the localized strings defined in this component; maintained by components that provide translations.",
          ).optional(),
          "minimumRequiredLocalizedDataSemanticVersion": z.string().describe(
            "The minimum value of localizedDataSemanticVersion required in translations consumed by this component; used by components that consume translations.",
          ).optional(),
          "associatedComponent": z.object({
            "name": z.string().describe(
              "The 'name' property of the referenced toolComponent.",
            ).optional(),
            "index": z.number().int().gte(-1).describe(
              "An index into the referenced toolComponent in tool.extensions.",
            ).default(-1),
            "guid": z.string().regex(
              new RegExp(
                "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
              ),
            ).describe("The 'guid' property of the referenced toolComponent.")
              .optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Identifies a particular toolComponent object, either the driver or an extension.",
          ).optional(),
          "translationMetadata": z.object({
            "name": z.string().describe(
              "The name associated with the translation metadata.",
            ),
            "fullName": z.string().describe(
              "The full name associated with the translation metadata.",
            ).optional(),
            "shortDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "fullDescription": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "downloadUri": z.string().url().describe(
              "The absolute URI from which the translation metadata can be downloaded.",
            ).optional(),
            "informationUri": z.string().url().describe(
              "The absolute URI from which information related to the translation metadata can be downloaded.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe(
            "Provides additional metadata related to translation.",
          ).optional(),
          "supportedTaxonomies": z.array(
            z.object({
              "name": z.string().describe(
                "The 'name' property of the referenced toolComponent.",
              ).optional(),
              "index": z.number().int().gte(-1).describe(
                "An index into the referenced toolComponent in tool.extensions.",
              ).default(-1),
              "guid": z.string().regex(
                new RegExp(
                  "^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$",
                ),
              ).describe("The 'guid' property of the referenced toolComponent.")
                .optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "Identifies a particular toolComponent object, either the driver or an extension.",
            ),
          ).min(0).describe(
            "An array of toolComponentReference objects to declare the taxonomies supported by the tool component.",
          ).default([]),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A component, such as a plug-in or the driver, of the analysis tool that was run.",
        ),
      ).min(0).describe(
        "Tool translations that will be merged with a separate run.",
      ).default([]),
      "addresses": z.array(
        z.object({
          "absoluteAddress": z.number().int().gte(-1).describe(
            "The address expressed as a byte offset from the start of the addressable region.",
          ).default(-1),
          "relativeAddress": z.number().int().describe(
            "The address expressed as a byte offset from the absolute address of the top-most parent object.",
          ).optional(),
          "length": z.number().int().describe(
            "The number of bytes in this range of addresses.",
          ).optional(),
          "kind": z.string().describe(
            "An open-ended string that identifies the address kind. 'data', 'function', 'header','instruction', 'module', 'page', 'section', 'segment', 'stack', 'stackFrame', 'table' are well-known values.",
          ).optional(),
          "name": z.string().describe(
            "A name that is associated with the address, e.g., '.text'.",
          ).optional(),
          "fullyQualifiedName": z.string().describe(
            "A human-readable fully qualified name that is associated with the address.",
          ).optional(),
          "offsetFromParent": z.number().int().describe(
            "The byte offset of this address from the absolute or relative address of the parent object.",
          ).optional(),
          "index": z.number().int().gte(-1).describe(
            "The index within run.addresses of the cached object for this address.",
          ).default(-1),
          "parentIndex": z.number().int().gte(-1).describe(
            "The index within run.addresses of the parent object.",
          ).default(-1),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe(
          "A physical or virtual address, or a range of addresses, in an 'addressable region' (memory or a binary file).",
        ),
      ).min(0).describe("Addresses that will be merged with a separate run.")
        .default([]),
      "webRequests": z.array(
        z.object({
          "index": z.number().int().gte(-1).describe(
            "The index within the run.webRequests array of the request object associated with this result.",
          ).default(-1),
          "protocol": z.string().describe(
            "The request protocol. Example: 'http'.",
          ).optional(),
          "version": z.string().describe("The request version. Example: '1.1'.")
            .optional(),
          "target": z.string().describe("The target of the request.")
            .optional(),
          "method": z.string().describe(
            "The HTTP method. Well-known values are 'GET', 'PUT', 'POST', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS', 'TRACE', 'CONNECT'.",
          ).optional(),
          "headers": z.record(z.string()).describe("The request headers.")
            .optional(),
          "parameters": z.record(z.string()).describe("The request parameters.")
            .optional(),
          "body": z.object({
            "text": z.string().describe(
              "UTF-8-encoded content from a text artifact.",
            ).optional(),
            "binary": z.string().describe(
              "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
            ).optional(),
            "rendered": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Represents the contents of an artifact.")
            .optional(),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe("Describes an HTTP request."),
      ).min(0).describe("Requests that will be merged with a separate run.")
        .default([]),
      "webResponses": z.array(
        z.object({
          "index": z.number().int().gte(-1).describe(
            "The index within the run.webResponses array of the response object associated with this result.",
          ).default(-1),
          "protocol": z.string().describe(
            "The response protocol. Example: 'http'.",
          ).optional(),
          "version": z.string().describe(
            "The response version. Example: '1.1'.",
          ).optional(),
          "statusCode": z.number().int().describe(
            "The response status code. Example: 451.",
          ).optional(),
          "reasonPhrase": z.string().describe(
            "The response reason. Example: 'Not found'.",
          ).optional(),
          "headers": z.record(z.string()).describe("The response headers.")
            .optional(),
          "body": z.object({
            "text": z.string().describe(
              "UTF-8-encoded content from a text artifact.",
            ).optional(),
            "binary": z.string().describe(
              "MIME Base64-encoded content from a binary artifact, or from a text artifact in its original encoding.",
            ).optional(),
            "rendered": z.object({
              "text": z.string().describe(
                "A plain text message string or format string.",
              ),
              "markdown": z.string().describe(
                "A Markdown message string or format string.",
              ).optional(),
              "properties": z.object({
                "tags": z.array(z.string()).min(0).describe(
                  "A set of distinct strings that provide additional information.",
                ).default([]),
              }).catchall(z.any()).describe(
                "Key/value pairs that provide additional information about the object.",
              ).optional(),
            }).strict().describe(
              "A message string or message format string rendered in multiple formats.",
            ).optional(),
            "properties": z.object({
              "tags": z.array(z.string()).min(0).describe(
                "A set of distinct strings that provide additional information.",
              ).default([]),
            }).catchall(z.any()).describe(
              "Key/value pairs that provide additional information about the object.",
            ).optional(),
          }).strict().describe("Represents the contents of an artifact.")
            .optional(),
          "noResponseReceived": z.boolean().describe(
            "Specifies whether a response was received from the server.",
          ).default(false),
          "properties": z.object({
            "tags": z.array(z.string()).min(0).describe(
              "A set of distinct strings that provide additional information.",
            ).default([]),
          }).catchall(z.any()).describe(
            "Key/value pairs that provide additional information about the object.",
          ).optional(),
        }).strict().describe("Describes the response to an HTTP request."),
      ).min(0).describe("Responses that will be merged with a separate run.")
        .default([]),
      "properties": z.object({
        "tags": z.array(z.string()).min(0).describe(
          "A set of distinct strings that provide additional information.",
        ).default([]),
      }).catchall(z.any()).describe(
        "Key/value pairs that provide additional information about the object.",
      ).optional(),
    }).strict().describe("The top-level element of an external property file."),
  ).min(0).describe(
    "References to external property files that share data between runs.",
  ).optional(),
  "properties": z.object({
    "tags": z.array(z.string()).min(0).describe(
      "A set of distinct strings that provide additional information.",
    ).default([]),
  }).catchall(z.any()).describe(
    "Key/value pairs that provide additional information about the object.",
  ).optional(),
}).strict().describe(
  "Static Analysis Results Format (SARIF) Version 2.1.0-rtm.4 JSON Schema: a standard format for the output of static analysis tools.",
);
export type SchemaType = z.infer<typeof Schema>;
